-- name: GetOutcomeDistribution :one
SELECT * FROM outcome_distributions
WHERE event_id = sqlc.arg(event_id)
  AND market_id = sqlc.arg(market_id)
  AND outcome = sqlc.arg(outcome);

-- name: UpsertOutcomeDistribution :one
INSERT INTO outcome_distributions (
    event_id,
    market_id,
    outcome,
    bet_percentage,
    implied_probability
) VALUES (
    sqlc.arg(event_id),
    sqlc.arg(market_id),
    sqlc.arg(outcome),
    sqlc.arg(bet_percentage),
    sqlc.arg(implied_probability)
)
ON CONFLICT (event_id, market_id, outcome) DO UPDATE SET
    bet_percentage = EXCLUDED.bet_percentage,
    implied_probability = EXCLUDED.implied_probability,
    last_updated = CURRENT_TIMESTAMP
RETURNING *;

-- name: CreateDistributionHistory :one
INSERT INTO outcome_distribution_history (
    event_id,
    market_id,
    outcome,
    bet_percentage,
    previous_percentage
) VALUES (
    sqlc.arg(event_id),
    sqlc.arg(market_id),
    sqlc.arg(outcome),
    sqlc.arg(bet_percentage),
    sqlc.arg(previous_percentage)
)
RETURNING *;

-- name: GetCurrentOddsForOutcome :many
SELECT co.* 
FROM current_odds co
WHERE co.event_id = sqlc.arg(event_id)
  AND co.outcome = sqlc.arg(outcome);

-- name: GetValueOpportunities :many
-- Find betting opportunities where public bias creates value
WITH odds_probabilities AS (
    SELECT 
        co.event_id,
        co.market_type_id,
        co.outcome,
        co.odds_value,
        CASE 
            WHEN co.odds_value > 0 THEN ROUND((1.0 / co.odds_value * 100)::numeric, 2)
            ELSE 0
        END as implied_probability
    FROM current_odds co
),
distribution_analysis AS (
    SELECT 
        od.event_id,
        od.market_id,
        od.outcome,
        od.bet_percentage,
        op.implied_probability,
        op.odds_value,
        od.bet_percentage - op.implied_probability as public_bias,
        CASE 
            WHEN od.bet_percentage > op.implied_probability + 10 THEN 'OVERBET'
            WHEN od.bet_percentage < op.implied_probability - 10 THEN 'UNDERBET'
            ELSE 'FAIR'
        END as bet_assessment
    FROM outcome_distributions od
    JOIN odds_probabilities op ON od.event_id = op.event_id 
        AND od.outcome = op.outcome
)
SELECT 
    e.slug as event_slug,
    ht.name || ' vs ' || at.name as match_name,
    e.event_date,
    'Market ' || da.market_id as market_name,
    da.outcome,
    da.odds_value as current_odds,
    da.implied_probability || '%' as implied_prob,
    da.bet_percentage || '%' as public_bets,
    da.public_bias as bias_percentage,
    da.bet_assessment,
    CASE 
        WHEN da.bet_assessment = 'UNDERBET' THEN 'Value opportunity - less bet than probability suggests'
        WHEN da.bet_assessment = 'OVERBET' THEN 'Avoid - public overvaluing this outcome'
        ELSE 'Market aligned with probabilities'
    END as recommendation
FROM distribution_analysis da
JOIN events e ON da.event_id = e.id
JOIN teams ht ON e.home_team_id = ht.id
JOIN teams at ON e.away_team_id = at.id
WHERE e.event_date > NOW()
  AND ABS(da.public_bias) > sqlc.arg(min_bias)
ORDER BY ABS(da.public_bias) DESC;

-- name: RefreshContrarianBets :exec
REFRESH MATERIALIZED VIEW contrarian_bets;

-- name: GetContrarianBets :many
SELECT * FROM contrarian_bets;

-- name: GetEventBettingPatterns :many
-- Analyze all betting distributions for an event
SELECT 
    od.market_id,
    od.outcome,
    od.bet_percentage,
    co.odds_value,
    ROUND((1.0 / co.odds_value * 100)::numeric, 2) as implied_probability,
    od.bet_percentage - ROUND((1.0 / co.odds_value * 100)::numeric, 2) as bias,
    CASE 
        WHEN od.bet_percentage > 70 THEN 'HEAVY_FAVORITE'
        WHEN od.bet_percentage > 50 THEN 'FAVORITE'
        WHEN od.bet_percentage < 20 THEN 'LONGSHOT'
        ELSE 'BALANCED'
    END as betting_pattern
FROM outcome_distributions od
LEFT JOIN current_odds co ON od.event_id = co.event_id 
    AND od.outcome = co.outcome
WHERE od.event_id = sqlc.arg(event_id)
ORDER BY od.market_id, od.outcome;

-- name: GetPublicVsSharpIndicators :one
-- Identify if betting patterns suggest public or sharp money
WITH event_stats AS (
    SELECT 
        e.betting_volume_percentage,
        COUNT(DISTINCT od.market_id) as markets_with_data,
        MAX(od.bet_percentage) as max_bet_percentage,
        MIN(od.bet_percentage) as min_bet_percentage,
        AVG(ABS(od.value_indicator)) as avg_value_indicator,
        SUM(CASE WHEN od.bet_percentage > 60 THEN 1 ELSE 0 END) as heavy_favorites_count
    FROM events e
    LEFT JOIN outcome_distributions od ON e.id = od.event_id
    WHERE e.id = sqlc.arg(event_id)
    GROUP BY e.id, e.betting_volume_percentage
)
SELECT 
    json_build_object(
        'volume_percentage', betting_volume_percentage,
        'pattern_indicators', json_build_object(
            'markets_tracked', markets_with_data,
            'max_concentration', max_bet_percentage,
            'distribution_range', max_bet_percentage - min_bet_percentage,
            'avg_value_indicator', ROUND(avg_value_indicator, 2),
            'heavy_favorites', heavy_favorites_count
        ),
        'likely_money_type', CASE 
            WHEN betting_volume_percentage > 5 AND heavy_favorites_count > 2 THEN 'PUBLIC'
            WHEN betting_volume_percentage < 1 AND avg_value_indicator > 10 THEN 'SHARP'
            WHEN betting_volume_percentage > 3 AND max_bet_percentage < 60 THEN 'MIXED'
            ELSE 'UNCLEAR'
        END,
        'confidence', CASE 
            WHEN markets_with_data > 5 THEN 'HIGH'
            WHEN markets_with_data > 2 THEN 'MEDIUM'
            ELSE 'LOW'
        END
    ) as analysis
FROM event_stats;