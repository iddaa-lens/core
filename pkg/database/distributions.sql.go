// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: distributions.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDistributionHistory = `-- name: CreateDistributionHistory :one
INSERT INTO outcome_distribution_history (
    event_id,
    market_id,
    outcome,
    bet_percentage,
    previous_percentage
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
RETURNING id, event_id, market_id, outcome, bet_percentage, previous_percentage, change_amount, recorded_at
`

type CreateDistributionHistoryParams struct {
	EventID            pgtype.Int4    `db:"event_id" json:"event_id"`
	MarketID           int32          `db:"market_id" json:"market_id"`
	Outcome            string         `db:"outcome" json:"outcome"`
	BetPercentage      pgtype.Numeric `db:"bet_percentage" json:"bet_percentage"`
	PreviousPercentage pgtype.Numeric `db:"previous_percentage" json:"previous_percentage"`
}

func (q *Queries) CreateDistributionHistory(ctx context.Context, arg CreateDistributionHistoryParams) (OutcomeDistributionHistory, error) {
	row := q.db.QueryRow(ctx, createDistributionHistory,
		arg.EventID,
		arg.MarketID,
		arg.Outcome,
		arg.BetPercentage,
		arg.PreviousPercentage,
	)
	var i OutcomeDistributionHistory
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.MarketID,
		&i.Outcome,
		&i.BetPercentage,
		&i.PreviousPercentage,
		&i.ChangeAmount,
		&i.RecordedAt,
	)
	return i, err
}

const getContrarianBets = `-- name: GetContrarianBets :many
SELECT slug, match_name, market, public_choice, public_backing, odds, overbet_by, strategy FROM contrarian_bets
`

func (q *Queries) GetContrarianBets(ctx context.Context) ([]ContrarianBet, error) {
	rows, err := q.db.Query(ctx, getContrarianBets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContrarianBet{}
	for rows.Next() {
		var i ContrarianBet
		if err := rows.Scan(
			&i.Slug,
			&i.MatchName,
			&i.Market,
			&i.PublicChoice,
			&i.PublicBacking,
			&i.Odds,
			&i.OverbetBy,
			&i.Strategy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentOddsForOutcome = `-- name: GetCurrentOddsForOutcome :many
SELECT co.id, co.event_id, co.market_type_id, co.outcome, co.odds_value, co.opening_value, co.highest_value, co.lowest_value, co.winning_odds, co.total_movement, co.movement_percentage, co.last_updated 
FROM current_odds co
WHERE co.event_id = $1
  AND co.outcome = $2
`

type GetCurrentOddsForOutcomeParams struct {
	EventID pgtype.Int4 `db:"event_id" json:"event_id"`
	Outcome string      `db:"outcome" json:"outcome"`
}

func (q *Queries) GetCurrentOddsForOutcome(ctx context.Context, arg GetCurrentOddsForOutcomeParams) ([]CurrentOdd, error) {
	rows, err := q.db.Query(ctx, getCurrentOddsForOutcome, arg.EventID, arg.Outcome)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CurrentOdd{}
	for rows.Next() {
		var i CurrentOdd
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.OpeningValue,
			&i.HighestValue,
			&i.LowestValue,
			&i.WinningOdds,
			&i.TotalMovement,
			&i.MovementPercentage,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistributionHistory = `-- name: GetDistributionHistory :many
SELECT id, event_id, market_id, outcome, bet_percentage, previous_percentage, change_amount, recorded_at FROM outcome_distribution_history
WHERE event_id = $1
  AND market_id = $2
  AND outcome = $3
ORDER BY recorded_at DESC
`

type GetDistributionHistoryParams struct {
	EventID  pgtype.Int4 `db:"event_id" json:"event_id"`
	MarketID int32       `db:"market_id" json:"market_id"`
	Outcome  string      `db:"outcome" json:"outcome"`
}

func (q *Queries) GetDistributionHistory(ctx context.Context, arg GetDistributionHistoryParams) ([]OutcomeDistributionHistory, error) {
	rows, err := q.db.Query(ctx, getDistributionHistory, arg.EventID, arg.MarketID, arg.Outcome)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OutcomeDistributionHistory{}
	for rows.Next() {
		var i OutcomeDistributionHistory
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketID,
			&i.Outcome,
			&i.BetPercentage,
			&i.PreviousPercentage,
			&i.ChangeAmount,
			&i.RecordedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventBettingPatterns = `-- name: GetEventBettingPatterns :many
SELECT 
    od.market_id,
    od.outcome,
    od.bet_percentage,
    co.odds_value,
    ROUND((1.0 / co.odds_value * 100)::numeric, 2) as implied_probability,
    od.bet_percentage - ROUND((1.0 / co.odds_value * 100)::numeric, 2) as bias,
    CASE 
        WHEN od.bet_percentage > 70 THEN 'HEAVY_FAVORITE'
        WHEN od.bet_percentage > 50 THEN 'FAVORITE'
        WHEN od.bet_percentage < 20 THEN 'LONGSHOT'
        ELSE 'BALANCED'
    END as betting_pattern
FROM outcome_distributions od
LEFT JOIN current_odds co ON od.event_id = co.event_id 
    AND od.outcome = co.outcome
WHERE od.event_id = $1
ORDER BY od.market_id, od.outcome
`

type GetEventBettingPatternsRow struct {
	MarketID           int32          `db:"market_id" json:"market_id"`
	Outcome            string         `db:"outcome" json:"outcome"`
	BetPercentage      pgtype.Numeric `db:"bet_percentage" json:"bet_percentage"`
	OddsValue          pgtype.Numeric `db:"odds_value" json:"odds_value"`
	ImpliedProbability pgtype.Numeric `db:"implied_probability" json:"implied_probability"`
	Bias               int32          `db:"bias" json:"bias"`
	BettingPattern     string         `db:"betting_pattern" json:"betting_pattern"`
}

// Analyze all betting distributions for an event
func (q *Queries) GetEventBettingPatterns(ctx context.Context, eventID pgtype.Int4) ([]GetEventBettingPatternsRow, error) {
	rows, err := q.db.Query(ctx, getEventBettingPatterns, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventBettingPatternsRow{}
	for rows.Next() {
		var i GetEventBettingPatternsRow
		if err := rows.Scan(
			&i.MarketID,
			&i.Outcome,
			&i.BetPercentage,
			&i.OddsValue,
			&i.ImpliedProbability,
			&i.Bias,
			&i.BettingPattern,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventDistributions = `-- name: GetEventDistributions :many
SELECT id, event_id, market_id, market_type_id, outcome, bet_percentage, implied_probability, value_indicator, last_updated FROM outcome_distributions
WHERE event_id = $1
ORDER BY market_id, outcome
`

func (q *Queries) GetEventDistributions(ctx context.Context, eventID pgtype.Int4) ([]OutcomeDistribution, error) {
	rows, err := q.db.Query(ctx, getEventDistributions, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OutcomeDistribution{}
	for rows.Next() {
		var i OutcomeDistribution
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.BetPercentage,
			&i.ImpliedProbability,
			&i.ValueIndicator,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOutcomeDistribution = `-- name: GetOutcomeDistribution :one
SELECT id, event_id, market_id, market_type_id, outcome, bet_percentage, implied_probability, value_indicator, last_updated FROM outcome_distributions
WHERE event_id = $1
  AND market_id = $2
  AND outcome = $3
`

type GetOutcomeDistributionParams struct {
	EventID  pgtype.Int4 `db:"event_id" json:"event_id"`
	MarketID int32       `db:"market_id" json:"market_id"`
	Outcome  string      `db:"outcome" json:"outcome"`
}

func (q *Queries) GetOutcomeDistribution(ctx context.Context, arg GetOutcomeDistributionParams) (OutcomeDistribution, error) {
	row := q.db.QueryRow(ctx, getOutcomeDistribution, arg.EventID, arg.MarketID, arg.Outcome)
	var i OutcomeDistribution
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.MarketID,
		&i.MarketTypeID,
		&i.Outcome,
		&i.BetPercentage,
		&i.ImpliedProbability,
		&i.ValueIndicator,
		&i.LastUpdated,
	)
	return i, err
}

const getTopDistributions = `-- name: GetTopDistributions :many
SELECT id, event_id, market_id, market_type_id, outcome, bet_percentage, implied_probability, value_indicator, last_updated FROM outcome_distributions
ORDER BY bet_percentage DESC
LIMIT $1
`

func (q *Queries) GetTopDistributions(ctx context.Context, limitCount int32) ([]OutcomeDistribution, error) {
	rows, err := q.db.Query(ctx, getTopDistributions, limitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OutcomeDistribution{}
	for rows.Next() {
		var i OutcomeDistribution
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.BetPercentage,
			&i.ImpliedProbability,
			&i.ValueIndicator,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshContrarianBets = `-- name: RefreshContrarianBets :exec
REFRESH MATERIALIZED VIEW contrarian_bets
`

func (q *Queries) RefreshContrarianBets(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshContrarianBets)
	return err
}

const upsertOutcomeDistribution = `-- name: UpsertOutcomeDistribution :one
INSERT INTO outcome_distributions (
    event_id,
    market_id,
    outcome,
    bet_percentage,
    implied_probability
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
ON CONFLICT (event_id, market_id, outcome) DO UPDATE SET
    bet_percentage = EXCLUDED.bet_percentage,
    implied_probability = EXCLUDED.implied_probability,
    last_updated = CURRENT_TIMESTAMP
RETURNING id, event_id, market_id, market_type_id, outcome, bet_percentage, implied_probability, value_indicator, last_updated
`

type UpsertOutcomeDistributionParams struct {
	EventID            pgtype.Int4    `db:"event_id" json:"event_id"`
	MarketID           int32          `db:"market_id" json:"market_id"`
	Outcome            string         `db:"outcome" json:"outcome"`
	BetPercentage      pgtype.Numeric `db:"bet_percentage" json:"bet_percentage"`
	ImpliedProbability pgtype.Numeric `db:"implied_probability" json:"implied_probability"`
}

func (q *Queries) UpsertOutcomeDistribution(ctx context.Context, arg UpsertOutcomeDistributionParams) (OutcomeDistribution, error) {
	row := q.db.QueryRow(ctx, upsertOutcomeDistribution,
		arg.EventID,
		arg.MarketID,
		arg.Outcome,
		arg.BetPercentage,
		arg.ImpliedProbability,
	)
	var i OutcomeDistribution
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.MarketID,
		&i.MarketTypeID,
		&i.Outcome,
		&i.BetPercentage,
		&i.ImpliedProbability,
		&i.ValueIndicator,
		&i.LastUpdated,
	)
	return i, err
}
