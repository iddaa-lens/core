// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: smart_money.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMovementAlert = `-- name: CreateMovementAlert :one
INSERT INTO
    movement_alerts (
        odds_history_id,
        alert_type,
        severity,
        title,
        message,
        change_percentage,
        multiplier,
        confidence_score,
        minutes_to_kickoff,
        expires_at
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        CURRENT_TIMESTAMP + INTERVAL '24 hours'
    ) ON CONFLICT (odds_history_id, alert_type) DO
UPDATE
SET
    severity = EXCLUDED.severity,
    title = EXCLUDED.title,
    message = EXCLUDED.message,
    change_percentage = EXCLUDED.change_percentage,
    multiplier = EXCLUDED.multiplier,
    confidence_score = EXCLUDED.confidence_score,
    minutes_to_kickoff = EXCLUDED.minutes_to_kickoff,
    expires_at = CURRENT_TIMESTAMP + INTERVAL '24 hours',
    updated_at = CURRENT_TIMESTAMP RETURNING id, odds_history_id, alert_type, severity, title, message, change_percentage, multiplier, confidence_score, minutes_to_kickoff, created_at, updated_at, deleted_at, expires_at, is_active, views, clicks
`

type CreateMovementAlertParams struct {
	OddsHistoryID    int32   `db:"odds_history_id" json:"odds_history_id"`
	AlertType        string  `db:"alert_type" json:"alert_type"`
	Severity         string  `db:"severity" json:"severity"`
	Title            string  `db:"title" json:"title"`
	Message          string  `db:"message" json:"message"`
	ChangePercentage float32 `db:"change_percentage" json:"change_percentage"`
	Multiplier       float64 `db:"multiplier" json:"multiplier"`
	ConfidenceScore  float32 `db:"confidence_score" json:"confidence_score"`
	MinutesToKickoff *int32  `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
}

func (q *Queries) CreateMovementAlert(ctx context.Context, arg CreateMovementAlertParams) (MovementAlert, error) {
	row := q.db.QueryRow(ctx, createMovementAlert,
		arg.OddsHistoryID,
		arg.AlertType,
		arg.Severity,
		arg.Title,
		arg.Message,
		arg.ChangePercentage,
		arg.Multiplier,
		arg.ConfidenceScore,
		arg.MinutesToKickoff,
	)
	var i MovementAlert
	err := row.Scan(
		&i.ID,
		&i.OddsHistoryID,
		&i.AlertType,
		&i.Severity,
		&i.Title,
		&i.Message,
		&i.ChangePercentage,
		&i.Multiplier,
		&i.ConfidenceScore,
		&i.MinutesToKickoff,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.Views,
		&i.Clicks,
	)
	return i, err
}

const deactivateExpiredAlerts = `-- name: DeactivateExpiredAlerts :exec
UPDATE
    movement_alerts
SET
    is_active = false
WHERE
    expires_at <= NOW()
    AND is_active = true
`

func (q *Queries) DeactivateExpiredAlerts(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deactivateExpiredAlerts)
	return err
}

const getActiveAlerts = `-- name: GetActiveAlerts :many
SELECT
    ma.id, ma.odds_history_id, ma.alert_type, ma.severity, ma.title, ma.message, ma.change_percentage, ma.multiplier, ma.confidence_score, ma.minutes_to_kickoff, ma.created_at, ma.updated_at, ma.deleted_at, ma.expires_at, ma.is_active, ma.views, ma.clicks,
    oh.event_id,
    oh.market_type_id,
    oh.outcome,
    e.external_id as event_external_id,
    e.event_date,
    e.home_team_id,
    e.away_team_id,
    ht.name as home_team_name,
    at.name as away_team_name,
    mt.code as market_code,
    mt.name as market_name
FROM
    movement_alerts ma
    JOIN odds_history oh ON ma.odds_history_id = oh.id
    JOIN events e ON oh.event_id = e.id
    LEFT JOIN teams ht ON e.home_team_id = ht.id
    LEFT JOIN teams at ON e.away_team_id = at.id
    JOIN market_types mt ON oh.market_type_id = mt.id
WHERE
    ma.is_active = true
    AND ma.expires_at > NOW()
    AND (
        $1 = ''
        OR ma.alert_type = $1
    )
    AND (
        $2 = ''
        OR (
            ma.severity = 'critical'
            AND $2 IN ('low', 'medium', 'high', 'critical')
        )
        OR (
            ma.severity = 'high'
            AND $2 IN ('low', 'medium', 'high')
        )
        OR (
            ma.severity = 'medium'
            AND $2 IN ('low', 'medium')
        )
        OR (
            ma.severity = 'low'
            AND $2 = 'low'
        )
    )
ORDER BY
    CASE
        ma.severity
        WHEN 'critical' THEN 4
        WHEN 'high' THEN 3
        WHEN 'medium' THEN 2
        ELSE 1
    END DESC,
    ma.created_at DESC
LIMIT
    $3
`

type GetActiveAlertsParams struct {
	AlertType   interface{} `db:"alert_type" json:"alert_type"`
	MinSeverity interface{} `db:"min_severity" json:"min_severity"`
	LimitCount  int64       `db:"limit_count" json:"limit_count"`
}

type GetActiveAlertsRow struct {
	ID               int32            `db:"id" json:"id"`
	OddsHistoryID    int32            `db:"odds_history_id" json:"odds_history_id"`
	AlertType        string           `db:"alert_type" json:"alert_type"`
	Severity         string           `db:"severity" json:"severity"`
	Title            string           `db:"title" json:"title"`
	Message          string           `db:"message" json:"message"`
	ChangePercentage float32          `db:"change_percentage" json:"change_percentage"`
	Multiplier       float64          `db:"multiplier" json:"multiplier"`
	ConfidenceScore  float32          `db:"confidence_score" json:"confidence_score"`
	MinutesToKickoff *int32           `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	CreatedAt        pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	DeletedAt        pgtype.Timestamp `db:"deleted_at" json:"deleted_at"`
	ExpiresAt        pgtype.Timestamp `db:"expires_at" json:"expires_at"`
	IsActive         bool             `db:"is_active" json:"is_active"`
	Views            int32            `db:"views" json:"views"`
	Clicks           int32            `db:"clicks" json:"clicks"`
	EventID          *int32           `db:"event_id" json:"event_id"`
	MarketTypeID     *int32           `db:"market_type_id" json:"market_type_id"`
	Outcome          string           `db:"outcome" json:"outcome"`
	EventExternalID  string           `db:"event_external_id" json:"event_external_id"`
	EventDate        pgtype.Timestamp `db:"event_date" json:"event_date"`
	HomeTeamID       *int32           `db:"home_team_id" json:"home_team_id"`
	AwayTeamID       *int32           `db:"away_team_id" json:"away_team_id"`
	HomeTeamName     *string          `db:"home_team_name" json:"home_team_name"`
	AwayTeamName     *string          `db:"away_team_name" json:"away_team_name"`
	MarketCode       string           `db:"market_code" json:"market_code"`
	MarketName       string           `db:"market_name" json:"market_name"`
}

func (q *Queries) GetActiveAlerts(ctx context.Context, arg GetActiveAlertsParams) ([]GetActiveAlertsRow, error) {
	rows, err := q.db.Query(ctx, getActiveAlerts, arg.AlertType, arg.MinSeverity, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveAlertsRow{}
	for rows.Next() {
		var i GetActiveAlertsRow
		if err := rows.Scan(
			&i.ID,
			&i.OddsHistoryID,
			&i.AlertType,
			&i.Severity,
			&i.Title,
			&i.Message,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.ConfidenceScore,
			&i.MinutesToKickoff,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ExpiresAt,
			&i.IsActive,
			&i.Views,
			&i.Clicks,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.EventExternalID,
			&i.EventDate,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.MarketCode,
			&i.MarketName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentBigMovers = `-- name: GetRecentBigMovers :many
SELECT
    oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff, oh.market_params, oh.recorded_at,
    e.external_id as event_external_id,
    e.event_date,
    e.home_team_id,
    e.away_team_id,
    e.is_live,
    ht.name as home_team_name,
    at.name as away_team_name,
    mt.code as market_code,
    mt.name as market_name
FROM
    odds_history oh
    JOIN events e ON oh.event_id = e.id
    LEFT JOIN teams ht ON e.home_team_id = ht.id
    LEFT JOIN teams at ON e.away_team_id = at.id
    JOIN market_types mt ON oh.market_type_id = mt.id
WHERE
    (
        ABS(oh.change_percentage) >= $1::float8
        OR oh.multiplier >= $2::float8
    )
    AND oh.recorded_at >= $3::timestamp
    AND e.event_date > NOW()
ORDER BY
    oh.recorded_at DESC
LIMIT
    $4::int
`

type GetRecentBigMoversParams struct {
	MinChangePct  float64          `db:"min_change_pct" json:"min_change_pct"`
	MinMultiplier float64          `db:"min_multiplier" json:"min_multiplier"`
	SinceTime     pgtype.Timestamp `db:"since_time" json:"since_time"`
	LimitCount    int32            `db:"limit_count" json:"limit_count"`
}

type GetRecentBigMoversRow struct {
	ID                  int32            `db:"id" json:"id"`
	EventID             *int32           `db:"event_id" json:"event_id"`
	MarketTypeID        *int32           `db:"market_type_id" json:"market_type_id"`
	Outcome             string           `db:"outcome" json:"outcome"`
	OddsValue           float64          `db:"odds_value" json:"odds_value"`
	PreviousValue       *float64         `db:"previous_value" json:"previous_value"`
	WinningOdds         *float64         `db:"winning_odds" json:"winning_odds"`
	ChangeAmount        *float64         `db:"change_amount" json:"change_amount"`
	ChangePercentage    *float32         `db:"change_percentage" json:"change_percentage"`
	Multiplier          *float64         `db:"multiplier" json:"multiplier"`
	SharpMoneyIndicator *float32         `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement   *bool            `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel   *string          `db:"significance_level" json:"significance_level"`
	MinutesToKickoff    *int32           `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	MarketParams        []byte           `db:"market_params" json:"market_params"`
	RecordedAt          pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	EventExternalID     string           `db:"event_external_id" json:"event_external_id"`
	EventDate           pgtype.Timestamp `db:"event_date" json:"event_date"`
	HomeTeamID          *int32           `db:"home_team_id" json:"home_team_id"`
	AwayTeamID          *int32           `db:"away_team_id" json:"away_team_id"`
	IsLive              *bool            `db:"is_live" json:"is_live"`
	HomeTeamName        *string          `db:"home_team_name" json:"home_team_name"`
	AwayTeamName        *string          `db:"away_team_name" json:"away_team_name"`
	MarketCode          string           `db:"market_code" json:"market_code"`
	MarketName          string           `db:"market_name" json:"market_name"`
}

// Smart Money Tracker queries
func (q *Queries) GetRecentBigMovers(ctx context.Context, arg GetRecentBigMoversParams) ([]GetRecentBigMoversRow, error) {
	rows, err := q.db.Query(ctx, getRecentBigMovers,
		arg.MinChangePct,
		arg.MinMultiplier,
		arg.SinceTime,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentBigMoversRow{}
	for rows.Next() {
		var i GetRecentBigMoversRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.MarketParams,
			&i.RecordedAt,
			&i.EventExternalID,
			&i.EventDate,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.IsLive,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.MarketCode,
			&i.MarketName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReverseLineMovements = `-- name: GetReverseLineMovements :many
SELECT
    oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff, oh.market_params, oh.recorded_at,
    e.external_id as event_external_id,
    e.event_date,
    e.home_team_id,
    e.away_team_id,
    e.betting_volume_percentage,
    ht.name as home_team_name,
    at.name as away_team_name,
    mt.code as market_code,
    mt.name as market_name,
    od.bet_percentage,
    od.implied_probability,
    -- Calculate the divergence between public betting and odds movement
    CASE 
        WHEN od.bet_percentage > 60 AND oh.change_percentage > 0 THEN 'public_heavy_odds_worse'
        WHEN od.bet_percentage < 40 AND oh.change_percentage < 0 THEN 'public_light_odds_better'
        ELSE 'normal'
    END as movement_type,
    -- Strength of reverse movement (public % * abs(odds change %))
    (od.bet_percentage * ABS(oh.change_percentage) / 100) as reverse_strength
FROM
    odds_history oh
    JOIN events e ON oh.event_id = e.id
    LEFT JOIN teams ht ON e.home_team_id = ht.id
    LEFT JOIN teams at ON e.away_team_id = at.id
    JOIN market_types mt ON oh.market_type_id = mt.id
    LEFT JOIN outcome_distributions od ON (
        oh.event_id = od.event_id 
        AND oh.market_type_id = od.market_type_id
        AND oh.outcome = od.outcome
    )
WHERE
    oh.recorded_at >= $1
    AND e.event_date > NOW()
    AND od.bet_percentage IS NOT NULL
    -- True reverse line movements:
    AND (
        -- Heavy public betting (>65%) but odds getting worse (going up)
        (od.bet_percentage > 65 AND oh.change_percentage > 5)
        OR
        -- Light public betting (<35%) but odds getting better (going down)
        (od.bet_percentage < 35 AND oh.change_percentage < -5)
    )
    -- Only significant movements
    AND ABS(oh.change_percentage) >= 5
ORDER BY
    (od.bet_percentage * ABS(oh.change_percentage) / 100) DESC
LIMIT
    $2
`

type GetReverseLineMovementsParams struct {
	SinceTime  pgtype.Timestamp `db:"since_time" json:"since_time"`
	LimitCount int64            `db:"limit_count" json:"limit_count"`
}

type GetReverseLineMovementsRow struct {
	ID                      int32            `db:"id" json:"id"`
	EventID                 *int32           `db:"event_id" json:"event_id"`
	MarketTypeID            *int32           `db:"market_type_id" json:"market_type_id"`
	Outcome                 string           `db:"outcome" json:"outcome"`
	OddsValue               float64          `db:"odds_value" json:"odds_value"`
	PreviousValue           *float64         `db:"previous_value" json:"previous_value"`
	WinningOdds             *float64         `db:"winning_odds" json:"winning_odds"`
	ChangeAmount            *float64         `db:"change_amount" json:"change_amount"`
	ChangePercentage        *float32         `db:"change_percentage" json:"change_percentage"`
	Multiplier              *float64         `db:"multiplier" json:"multiplier"`
	SharpMoneyIndicator     *float32         `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement       *bool            `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel       *string          `db:"significance_level" json:"significance_level"`
	MinutesToKickoff        *int32           `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	MarketParams            []byte           `db:"market_params" json:"market_params"`
	RecordedAt              pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	EventExternalID         string           `db:"event_external_id" json:"event_external_id"`
	EventDate               pgtype.Timestamp `db:"event_date" json:"event_date"`
	HomeTeamID              *int32           `db:"home_team_id" json:"home_team_id"`
	AwayTeamID              *int32           `db:"away_team_id" json:"away_team_id"`
	BettingVolumePercentage *float32         `db:"betting_volume_percentage" json:"betting_volume_percentage"`
	HomeTeamName            *string          `db:"home_team_name" json:"home_team_name"`
	AwayTeamName            *string          `db:"away_team_name" json:"away_team_name"`
	MarketCode              string           `db:"market_code" json:"market_code"`
	MarketName              string           `db:"market_name" json:"market_name"`
	BetPercentage           *float32         `db:"bet_percentage" json:"bet_percentage"`
	ImpliedProbability      *float32         `db:"implied_probability" json:"implied_probability"`
	MovementType            string           `db:"movement_type" json:"movement_type"`
	ReverseStrength         int32            `db:"reverse_strength" json:"reverse_strength"`
}

// Detect TRUE reverse line movements where odds move against public betting percentages
func (q *Queries) GetReverseLineMovements(ctx context.Context, arg GetReverseLineMovementsParams) ([]GetReverseLineMovementsRow, error) {
	rows, err := q.db.Query(ctx, getReverseLineMovements, arg.SinceTime, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReverseLineMovementsRow{}
	for rows.Next() {
		var i GetReverseLineMovementsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.MarketParams,
			&i.RecordedAt,
			&i.EventExternalID,
			&i.EventDate,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.BettingVolumePercentage,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.MarketCode,
			&i.MarketName,
			&i.BetPercentage,
			&i.ImpliedProbability,
			&i.MovementType,
			&i.ReverseStrength,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharpMoneyIndicators = `-- name: GetSharpMoneyIndicators :many
SELECT
    oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff, oh.market_params, oh.recorded_at,
    e.external_id as event_external_id,
    e.event_date,
    e.betting_volume_percentage,
    e.volume_rank,
    ht.name as home_team_name,
    at.name as away_team_name,
    mt.code as market_code,
    mt.name as market_name,
    od.bet_percentage,
    od.implied_probability,
    -- Sharp money score calculation
    (
        -- Reverse line movement factor (0-40 points)
        CASE 
            WHEN od.bet_percentage > 70 AND oh.change_percentage > 5 THEN 40
            WHEN od.bet_percentage > 60 AND oh.change_percentage > 3 THEN 30
            WHEN od.bet_percentage < 30 AND oh.change_percentage < -5 THEN 40
            WHEN od.bet_percentage < 40 AND oh.change_percentage < -3 THEN 30
            ELSE 0
        END +
        -- Volume factor (0-20 points) - lower volume with movement = sharper
        CASE
            WHEN e.betting_volume_percentage < 1 AND ABS(oh.change_percentage) > 10 THEN 20
            WHEN e.betting_volume_percentage < 2 AND ABS(oh.change_percentage) > 7 THEN 15
            WHEN e.betting_volume_percentage < 5 AND ABS(oh.change_percentage) > 5 THEN 10
            ELSE 0
        END +
        -- Timing factor (0-20 points) - late movement = sharper
        CASE
            WHEN EXTRACT(EPOCH FROM (e.event_date - oh.recorded_at)) / 3600 < 2 THEN 20
            WHEN EXTRACT(EPOCH FROM (e.event_date - oh.recorded_at)) / 3600 < 6 THEN 15
            WHEN EXTRACT(EPOCH FROM (e.event_date - oh.recorded_at)) / 3600 < 24 THEN 10
            ELSE 5
        END +
        -- Movement size factor (0-20 points)
        CASE
            WHEN ABS(oh.change_percentage) > 20 THEN 20
            WHEN ABS(oh.change_percentage) > 15 THEN 15
            WHEN ABS(oh.change_percentage) > 10 THEN 10
            WHEN ABS(oh.change_percentage) > 5 THEN 5
            ELSE 0
        END
    ) as sharp_money_score
FROM
    odds_history oh
    JOIN events e ON oh.event_id = e.id
    LEFT JOIN teams ht ON e.home_team_id = ht.id
    LEFT JOIN teams at ON e.away_team_id = at.id
    JOIN market_types mt ON oh.market_type_id = mt.id
    LEFT JOIN outcome_distributions od ON (
        oh.event_id = od.event_id 
        AND oh.market_type_id = od.market_type_id
        AND oh.outcome = od.outcome
    )
WHERE
    oh.recorded_at >= $1
    AND e.event_date > NOW()
    AND ABS(oh.change_percentage) >= 5
ORDER BY
    sharp_money_score DESC
LIMIT
    $2
`

type GetSharpMoneyIndicatorsParams struct {
	SinceTime  pgtype.Timestamp `db:"since_time" json:"since_time"`
	LimitCount int64            `db:"limit_count" json:"limit_count"`
}

type GetSharpMoneyIndicatorsRow struct {
	ID                      int32            `db:"id" json:"id"`
	EventID                 *int32           `db:"event_id" json:"event_id"`
	MarketTypeID            *int32           `db:"market_type_id" json:"market_type_id"`
	Outcome                 string           `db:"outcome" json:"outcome"`
	OddsValue               float64          `db:"odds_value" json:"odds_value"`
	PreviousValue           *float64         `db:"previous_value" json:"previous_value"`
	WinningOdds             *float64         `db:"winning_odds" json:"winning_odds"`
	ChangeAmount            *float64         `db:"change_amount" json:"change_amount"`
	ChangePercentage        *float32         `db:"change_percentage" json:"change_percentage"`
	Multiplier              *float64         `db:"multiplier" json:"multiplier"`
	SharpMoneyIndicator     *float32         `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement       *bool            `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel       *string          `db:"significance_level" json:"significance_level"`
	MinutesToKickoff        *int32           `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	MarketParams            []byte           `db:"market_params" json:"market_params"`
	RecordedAt              pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	EventExternalID         string           `db:"event_external_id" json:"event_external_id"`
	EventDate               pgtype.Timestamp `db:"event_date" json:"event_date"`
	BettingVolumePercentage *float32         `db:"betting_volume_percentage" json:"betting_volume_percentage"`
	VolumeRank              *int32           `db:"volume_rank" json:"volume_rank"`
	HomeTeamName            *string          `db:"home_team_name" json:"home_team_name"`
	AwayTeamName            *string          `db:"away_team_name" json:"away_team_name"`
	MarketCode              string           `db:"market_code" json:"market_code"`
	MarketName              string           `db:"market_name" json:"market_name"`
	BetPercentage           *float32         `db:"bet_percentage" json:"bet_percentage"`
	ImpliedProbability      *float32         `db:"implied_probability" json:"implied_probability"`
	SharpMoneyScore         int32            `db:"sharp_money_score" json:"sharp_money_score"`
}

// Comprehensive sharp money detection combining multiple factors
func (q *Queries) GetSharpMoneyIndicators(ctx context.Context, arg GetSharpMoneyIndicatorsParams) ([]GetSharpMoneyIndicatorsRow, error) {
	rows, err := q.db.Query(ctx, getSharpMoneyIndicators, arg.SinceTime, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSharpMoneyIndicatorsRow{}
	for rows.Next() {
		var i GetSharpMoneyIndicatorsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.MarketParams,
			&i.RecordedAt,
			&i.EventExternalID,
			&i.EventDate,
			&i.BettingVolumePercentage,
			&i.VolumeRank,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.MarketCode,
			&i.MarketName,
			&i.BetPercentage,
			&i.ImpliedProbability,
			&i.SharpMoneyScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSteamMoves = `-- name: GetSteamMoves :many
SELECT
    oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff, oh.market_params, oh.recorded_at,
    e.external_id as event_external_id,
    e.event_date,
    e.betting_volume_percentage,
    ht.name as home_team_name,
    at.name as away_team_name,
    mt.code as market_code,
    mt.name as market_name,
    -- Time since last movement
    EXTRACT(EPOCH FROM (oh.recorded_at - LAG(oh.recorded_at) OVER (
        PARTITION BY oh.event_id, oh.market_type_id, oh.outcome 
        ORDER BY oh.recorded_at
    ))) as seconds_since_last_move,
    -- Running total of movements in last hour
    COUNT(*) OVER (
        PARTITION BY oh.event_id, oh.market_type_id, oh.outcome 
        ORDER BY oh.recorded_at 
        RANGE BETWEEN INTERVAL '1 hour' PRECEDING AND CURRENT ROW
    ) as movements_last_hour
FROM
    odds_history oh
    JOIN events e ON oh.event_id = e.id
    LEFT JOIN teams ht ON e.home_team_id = ht.id
    LEFT JOIN teams at ON e.away_team_id = at.id
    JOIN market_types mt ON oh.market_type_id = mt.id
WHERE
    oh.recorded_at >= $1
    AND e.event_date > NOW()
    -- Significant movement
    AND ABS(oh.change_percentage) >= 3
    -- Multiple movements in short time indicates steam
    AND oh.event_id IN (
        SELECT event_id 
        FROM odds_history 
        WHERE recorded_at >= $1
        GROUP BY event_id, market_type_id, outcome
        HAVING COUNT(*) >= 3 -- At least 3 movements
    )
ORDER BY
    oh.recorded_at DESC
LIMIT
    $2
`

type GetSteamMovesParams struct {
	SinceTime  pgtype.Timestamp `db:"since_time" json:"since_time"`
	LimitCount int64            `db:"limit_count" json:"limit_count"`
}

type GetSteamMovesRow struct {
	ID                      int32            `db:"id" json:"id"`
	EventID                 *int32           `db:"event_id" json:"event_id"`
	MarketTypeID            *int32           `db:"market_type_id" json:"market_type_id"`
	Outcome                 string           `db:"outcome" json:"outcome"`
	OddsValue               float64          `db:"odds_value" json:"odds_value"`
	PreviousValue           *float64         `db:"previous_value" json:"previous_value"`
	WinningOdds             *float64         `db:"winning_odds" json:"winning_odds"`
	ChangeAmount            *float64         `db:"change_amount" json:"change_amount"`
	ChangePercentage        *float32         `db:"change_percentage" json:"change_percentage"`
	Multiplier              *float64         `db:"multiplier" json:"multiplier"`
	SharpMoneyIndicator     *float32         `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement       *bool            `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel       *string          `db:"significance_level" json:"significance_level"`
	MinutesToKickoff        *int32           `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	MarketParams            []byte           `db:"market_params" json:"market_params"`
	RecordedAt              pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	EventExternalID         string           `db:"event_external_id" json:"event_external_id"`
	EventDate               pgtype.Timestamp `db:"event_date" json:"event_date"`
	BettingVolumePercentage *float32         `db:"betting_volume_percentage" json:"betting_volume_percentage"`
	HomeTeamName            *string          `db:"home_team_name" json:"home_team_name"`
	AwayTeamName            *string          `db:"away_team_name" json:"away_team_name"`
	MarketCode              string           `db:"market_code" json:"market_code"`
	MarketName              string           `db:"market_name" json:"market_name"`
	SecondsSinceLastMove    float64          `db:"seconds_since_last_move" json:"seconds_since_last_move"`
	MovementsLastHour       int64            `db:"movements_last_hour" json:"movements_last_hour"`
}

// Detect rapid odds movements across multiple bookmakers (steam moves)
func (q *Queries) GetSteamMoves(ctx context.Context, arg GetSteamMovesParams) ([]GetSteamMovesRow, error) {
	rows, err := q.db.Query(ctx, getSteamMoves, arg.SinceTime, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSteamMovesRow{}
	for rows.Next() {
		var i GetSteamMovesRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.MarketParams,
			&i.RecordedAt,
			&i.EventExternalID,
			&i.EventDate,
			&i.BettingVolumePercentage,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.MarketCode,
			&i.MarketName,
			&i.SecondsSinceLastMove,
			&i.MovementsLastHour,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValueSpots = `-- name: GetValueSpots :many
SELECT
    oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff, oh.market_params, oh.recorded_at,
    od.bet_percentage,
    od.implied_probability,
    e.external_id as event_external_id,
    e.event_date,
    e.home_team_id,
    e.away_team_id,
    ht.name as home_team_name,
    at.name as away_team_name,
    mt.code as market_code,
    mt.name as market_name,
    (od.bet_percentage - od.implied_probability) as public_bias
FROM
    odds_history oh
    JOIN events e ON oh.event_id = e.id
    LEFT JOIN teams ht ON e.home_team_id = ht.id
    LEFT JOIN teams at ON e.away_team_id = at.id
    JOIN market_types mt ON oh.market_type_id = mt.id
    LEFT JOIN outcome_distributions od ON (
        oh.event_id = od.event_id
        AND oh.market_type_id = od.market_type_id
        AND oh.outcome = od.outcome
    )
WHERE
    oh.recorded_at >= $1
    AND e.event_date > NOW()
    AND od.bet_percentage > od.implied_probability + $2::float8
    AND ABS(oh.change_percentage) >= $3::float8
ORDER BY
    (od.bet_percentage - od.implied_probability) DESC
LIMIT
    $4
`

type GetValueSpotsParams struct {
	SinceTime      pgtype.Timestamp `db:"since_time" json:"since_time"`
	MinBiasPct     float64          `db:"min_bias_pct" json:"min_bias_pct"`
	MinMovementPct float64          `db:"min_movement_pct" json:"min_movement_pct"`
	LimitCount     int64            `db:"limit_count" json:"limit_count"`
}

type GetValueSpotsRow struct {
	ID                  int32            `db:"id" json:"id"`
	EventID             *int32           `db:"event_id" json:"event_id"`
	MarketTypeID        *int32           `db:"market_type_id" json:"market_type_id"`
	Outcome             string           `db:"outcome" json:"outcome"`
	OddsValue           float64          `db:"odds_value" json:"odds_value"`
	PreviousValue       *float64         `db:"previous_value" json:"previous_value"`
	WinningOdds         *float64         `db:"winning_odds" json:"winning_odds"`
	ChangeAmount        *float64         `db:"change_amount" json:"change_amount"`
	ChangePercentage    *float32         `db:"change_percentage" json:"change_percentage"`
	Multiplier          *float64         `db:"multiplier" json:"multiplier"`
	SharpMoneyIndicator *float32         `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement   *bool            `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel   *string          `db:"significance_level" json:"significance_level"`
	MinutesToKickoff    *int32           `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	MarketParams        []byte           `db:"market_params" json:"market_params"`
	RecordedAt          pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	BetPercentage       *float32         `db:"bet_percentage" json:"bet_percentage"`
	ImpliedProbability  *float32         `db:"implied_probability" json:"implied_probability"`
	EventExternalID     string           `db:"event_external_id" json:"event_external_id"`
	EventDate           pgtype.Timestamp `db:"event_date" json:"event_date"`
	HomeTeamID          *int32           `db:"home_team_id" json:"home_team_id"`
	AwayTeamID          *int32           `db:"away_team_id" json:"away_team_id"`
	HomeTeamName        *string          `db:"home_team_name" json:"home_team_name"`
	AwayTeamName        *string          `db:"away_team_name" json:"away_team_name"`
	MarketCode          string           `db:"market_code" json:"market_code"`
	MarketName          string           `db:"market_name" json:"market_name"`
	PublicBias          int32            `db:"public_bias" json:"public_bias"`
}

func (q *Queries) GetValueSpots(ctx context.Context, arg GetValueSpotsParams) ([]GetValueSpotsRow, error) {
	rows, err := q.db.Query(ctx, getValueSpots,
		arg.SinceTime,
		arg.MinBiasPct,
		arg.MinMovementPct,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetValueSpotsRow{}
	for rows.Next() {
		var i GetValueSpotsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.MarketParams,
			&i.RecordedAt,
			&i.BetPercentage,
			&i.ImpliedProbability,
			&i.EventExternalID,
			&i.EventDate,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.MarketCode,
			&i.MarketName,
			&i.PublicBias,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAlertClicked = `-- name: MarkAlertClicked :exec
UPDATE
    movement_alerts
SET
    clicks = clicks + 1
WHERE
    id = $1
`

func (q *Queries) MarkAlertClicked(ctx context.Context, alertID int32) error {
	_, err := q.db.Exec(ctx, markAlertClicked, alertID)
	return err
}

const markAlertViewed = `-- name: MarkAlertViewed :exec
UPDATE
    movement_alerts
SET
    views = views + 1
WHERE
    id = $1
`

// COMMENTED OUT: Requires smart_money_preferences table
// -- name: GetAlertsByUser :many
// SELECT
//
//	ma.*,
//	oh.event_id,
//	oh.outcome,
//	e.external_id as event_external_id,
//	e.event_date,
//	ht.name as home_team_name,
//	at.name as away_team_name,
//	mt.name as market_name
//
// FROM movement_alerts ma
// JOIN odds_history oh ON ma.odds_history_id = oh.id
// JOIN events e ON oh.event_id = e.id
// LEFT JOIN teams ht ON e.home_team_id = ht.id
// LEFT JOIN teams at ON e.away_team_id = at.id
// JOIN market_types mt ON oh.market_type_id = mt.id
// JOIN smart_money_preferences smp ON smp.user_id = sqlc.arg(user_id)
// WHERE
//
//	ma.is_active = true
//	AND ma.expires_at > NOW()
//	AND ma.change_percentage >= smp.min_change_percentage
//	AND ma.multiplier >= smp.min_multiplier
//	AND ma.confidence_score >= smp.min_confidence_score
//	AND (
//	    (ma.alert_type = 'big_mover' AND smp.big_mover_alerts = true) OR
//	    (ma.alert_type = 'reverse_line' AND smp.reverse_line_alerts = true) OR
//	    (ma.alert_type = 'sharp_money' AND smp.sharp_money_alerts = true) OR
//	    (ma.alert_type = 'value_spot' AND smp.value_spot_alerts = true)
//	)
//	-- Filter by preferred sports/leagues if specified
//	AND (
//	    smp.preferred_sports = '[]'::jsonb OR
//	    e.sport_id::text = ANY(SELECT jsonb_array_elements_text(smp.preferred_sports))
//	)
//
// ORDER BY ma.created_at DESC
// LIMIT sqlc.arg(limit_count);
func (q *Queries) MarkAlertViewed(ctx context.Context, alertID int32) error {
	_, err := q.db.Exec(ctx, markAlertViewed, alertID)
	return err
}
