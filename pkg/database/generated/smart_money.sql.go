// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: smart_money.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMovementAlert = `-- name: CreateMovementAlert :one
INSERT INTO
    movement_alerts (
        odds_history_id,
        alert_type,
        severity,
        title,
        message,
        change_percentage,
        multiplier,
        confidence_score,
        minutes_to_kickoff,
        expires_at
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        CURRENT_TIMESTAMP + INTERVAL '24 hours'
    ) ON CONFLICT (odds_history_id, alert_type) DO
UPDATE
SET
    severity = EXCLUDED.severity,
    title = EXCLUDED.title,
    message = EXCLUDED.message,
    change_percentage = EXCLUDED.change_percentage,
    multiplier = EXCLUDED.multiplier,
    confidence_score = EXCLUDED.confidence_score,
    minutes_to_kickoff = EXCLUDED.minutes_to_kickoff,
    expires_at = CURRENT_TIMESTAMP + INTERVAL '24 hours',
    updated_at = CURRENT_TIMESTAMP RETURNING id, odds_history_id, alert_type, severity, title, message, change_percentage, multiplier, confidence_score, minutes_to_kickoff, created_at, updated_at, deleted_at, expires_at, is_active, views, clicks
`

type CreateMovementAlertParams struct {
	OddsHistoryID    int32   `db:"odds_history_id" json:"odds_history_id"`
	AlertType        string  `db:"alert_type" json:"alert_type"`
	Severity         string  `db:"severity" json:"severity"`
	Title            string  `db:"title" json:"title"`
	Message          string  `db:"message" json:"message"`
	ChangePercentage float32 `db:"change_percentage" json:"change_percentage"`
	Multiplier       float64 `db:"multiplier" json:"multiplier"`
	ConfidenceScore  float32 `db:"confidence_score" json:"confidence_score"`
	MinutesToKickoff *int32  `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
}

func (q *Queries) CreateMovementAlert(ctx context.Context, arg CreateMovementAlertParams) (MovementAlert, error) {
	row := q.db.QueryRow(ctx, createMovementAlert,
		arg.OddsHistoryID,
		arg.AlertType,
		arg.Severity,
		arg.Title,
		arg.Message,
		arg.ChangePercentage,
		arg.Multiplier,
		arg.ConfidenceScore,
		arg.MinutesToKickoff,
	)
	var i MovementAlert
	err := row.Scan(
		&i.ID,
		&i.OddsHistoryID,
		&i.AlertType,
		&i.Severity,
		&i.Title,
		&i.Message,
		&i.ChangePercentage,
		&i.Multiplier,
		&i.ConfidenceScore,
		&i.MinutesToKickoff,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.Views,
		&i.Clicks,
	)
	return i, err
}

const deactivateExpiredAlerts = `-- name: DeactivateExpiredAlerts :exec
UPDATE
    movement_alerts
SET
    is_active = false
WHERE
    expires_at <= NOW()
    AND is_active = true
`

func (q *Queries) DeactivateExpiredAlerts(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deactivateExpiredAlerts)
	return err
}

const getActiveAlerts = `-- name: GetActiveAlerts :many
SELECT
    ma.id, ma.odds_history_id, ma.alert_type, ma.severity, ma.title, ma.message, ma.change_percentage, ma.multiplier, ma.confidence_score, ma.minutes_to_kickoff, ma.created_at, ma.updated_at, ma.deleted_at, ma.expires_at, ma.is_active, ma.views, ma.clicks,
    oh.event_id,
    oh.market_type_id,
    oh.outcome,
    e.external_id as event_external_id,
    e.event_date,
    e.home_team_id,
    e.away_team_id,
    ht.name as home_team_name,
    at.name as away_team_name,
    mt.code as market_code,
    mt.name as market_name
FROM
    movement_alerts ma
    JOIN odds_history oh ON ma.odds_history_id = oh.id
    JOIN events e ON oh.event_id = e.id
    LEFT JOIN teams ht ON e.home_team_id = ht.id
    LEFT JOIN teams at ON e.away_team_id = at.id
    JOIN market_types mt ON oh.market_type_id = mt.id
WHERE
    ma.is_active = true
    AND ma.expires_at > NOW()
    AND (
        $1 = ''
        OR ma.alert_type = $1
    )
    AND (
        $2 = ''
        OR (
            ma.severity = 'critical'
            AND $2 IN ('low', 'medium', 'high', 'critical')
        )
        OR (
            ma.severity = 'high'
            AND $2 IN ('low', 'medium', 'high')
        )
        OR (
            ma.severity = 'medium'
            AND $2 IN ('low', 'medium')
        )
        OR (
            ma.severity = 'low'
            AND $2 = 'low'
        )
    )
ORDER BY
    CASE
        ma.severity
        WHEN 'critical' THEN 4
        WHEN 'high' THEN 3
        WHEN 'medium' THEN 2
        ELSE 1
    END DESC,
    ma.created_at DESC
LIMIT
    $3
`

type GetActiveAlertsParams struct {
	AlertType   interface{} `db:"alert_type" json:"alert_type"`
	MinSeverity interface{} `db:"min_severity" json:"min_severity"`
	LimitCount  int64       `db:"limit_count" json:"limit_count"`
}

type GetActiveAlertsRow struct {
	ID               int32            `db:"id" json:"id"`
	OddsHistoryID    int32            `db:"odds_history_id" json:"odds_history_id"`
	AlertType        string           `db:"alert_type" json:"alert_type"`
	Severity         string           `db:"severity" json:"severity"`
	Title            string           `db:"title" json:"title"`
	Message          string           `db:"message" json:"message"`
	ChangePercentage float32          `db:"change_percentage" json:"change_percentage"`
	Multiplier       float64          `db:"multiplier" json:"multiplier"`
	ConfidenceScore  float32          `db:"confidence_score" json:"confidence_score"`
	MinutesToKickoff *int32           `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	CreatedAt        pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	DeletedAt        pgtype.Timestamp `db:"deleted_at" json:"deleted_at"`
	ExpiresAt        pgtype.Timestamp `db:"expires_at" json:"expires_at"`
	IsActive         bool             `db:"is_active" json:"is_active"`
	Views            int32            `db:"views" json:"views"`
	Clicks           int32            `db:"clicks" json:"clicks"`
	EventID          *int32           `db:"event_id" json:"event_id"`
	MarketTypeID     *int32           `db:"market_type_id" json:"market_type_id"`
	Outcome          string           `db:"outcome" json:"outcome"`
	EventExternalID  string           `db:"event_external_id" json:"event_external_id"`
	EventDate        pgtype.Timestamp `db:"event_date" json:"event_date"`
	HomeTeamID       *int32           `db:"home_team_id" json:"home_team_id"`
	AwayTeamID       *int32           `db:"away_team_id" json:"away_team_id"`
	HomeTeamName     *string          `db:"home_team_name" json:"home_team_name"`
	AwayTeamName     *string          `db:"away_team_name" json:"away_team_name"`
	MarketCode       string           `db:"market_code" json:"market_code"`
	MarketName       string           `db:"market_name" json:"market_name"`
}

func (q *Queries) GetActiveAlerts(ctx context.Context, arg GetActiveAlertsParams) ([]GetActiveAlertsRow, error) {
	rows, err := q.db.Query(ctx, getActiveAlerts, arg.AlertType, arg.MinSeverity, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveAlertsRow{}
	for rows.Next() {
		var i GetActiveAlertsRow
		if err := rows.Scan(
			&i.ID,
			&i.OddsHistoryID,
			&i.AlertType,
			&i.Severity,
			&i.Title,
			&i.Message,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.ConfidenceScore,
			&i.MinutesToKickoff,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ExpiresAt,
			&i.IsActive,
			&i.Views,
			&i.Clicks,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.EventExternalID,
			&i.EventDate,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.MarketCode,
			&i.MarketName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentBigMovers = `-- name: GetRecentBigMovers :many
SELECT
    oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff, oh.market_params, oh.recorded_at,
    e.external_id as event_external_id,
    e.event_date,
    e.home_team_id,
    e.away_team_id,
    e.is_live,
    ht.name as home_team_name,
    at.name as away_team_name,
    mt.code as market_code,
    mt.name as market_name
FROM
    odds_history oh
    JOIN events e ON oh.event_id = e.id
    LEFT JOIN teams ht ON e.home_team_id = ht.id
    LEFT JOIN teams at ON e.away_team_id = at.id
    JOIN market_types mt ON oh.market_type_id = mt.id
WHERE
    (
        ABS(oh.change_percentage) >= $1::float8
        OR oh.multiplier >= $2::float8
    )
    AND oh.recorded_at >= $3::timestamp
    AND e.event_date > NOW()
ORDER BY
    oh.recorded_at DESC
LIMIT
    $4::int
`

type GetRecentBigMoversParams struct {
	MinChangePct  float64          `db:"min_change_pct" json:"min_change_pct"`
	MinMultiplier float64          `db:"min_multiplier" json:"min_multiplier"`
	SinceTime     pgtype.Timestamp `db:"since_time" json:"since_time"`
	LimitCount    int32            `db:"limit_count" json:"limit_count"`
}

type GetRecentBigMoversRow struct {
	ID                  int32            `db:"id" json:"id"`
	EventID             *int32           `db:"event_id" json:"event_id"`
	MarketTypeID        *int32           `db:"market_type_id" json:"market_type_id"`
	Outcome             string           `db:"outcome" json:"outcome"`
	OddsValue           float64          `db:"odds_value" json:"odds_value"`
	PreviousValue       *float64         `db:"previous_value" json:"previous_value"`
	WinningOdds         *float64         `db:"winning_odds" json:"winning_odds"`
	ChangeAmount        *float64         `db:"change_amount" json:"change_amount"`
	ChangePercentage    *float32         `db:"change_percentage" json:"change_percentage"`
	Multiplier          *float64         `db:"multiplier" json:"multiplier"`
	SharpMoneyIndicator *float32         `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement   *bool            `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel   *string          `db:"significance_level" json:"significance_level"`
	MinutesToKickoff    *int32           `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	MarketParams        []byte           `db:"market_params" json:"market_params"`
	RecordedAt          pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	EventExternalID     string           `db:"event_external_id" json:"event_external_id"`
	EventDate           pgtype.Timestamp `db:"event_date" json:"event_date"`
	HomeTeamID          *int32           `db:"home_team_id" json:"home_team_id"`
	AwayTeamID          *int32           `db:"away_team_id" json:"away_team_id"`
	IsLive              *bool            `db:"is_live" json:"is_live"`
	HomeTeamName        *string          `db:"home_team_name" json:"home_team_name"`
	AwayTeamName        *string          `db:"away_team_name" json:"away_team_name"`
	MarketCode          string           `db:"market_code" json:"market_code"`
	MarketName          string           `db:"market_name" json:"market_name"`
}

// Smart Money Tracker queries
func (q *Queries) GetRecentBigMovers(ctx context.Context, arg GetRecentBigMoversParams) ([]GetRecentBigMoversRow, error) {
	rows, err := q.db.Query(ctx, getRecentBigMovers,
		arg.MinChangePct,
		arg.MinMultiplier,
		arg.SinceTime,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentBigMoversRow{}
	for rows.Next() {
		var i GetRecentBigMoversRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.MarketParams,
			&i.RecordedAt,
			&i.EventExternalID,
			&i.EventDate,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.IsLive,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.MarketCode,
			&i.MarketName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReverseLineMovements = `-- name: GetReverseLineMovements :many
SELECT
    oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff, oh.market_params, oh.recorded_at,
    e.external_id as event_external_id,
    e.event_date,
    e.home_team_id,
    e.away_team_id,
    ht.name as home_team_name,
    at.name as away_team_name,
    mt.code as market_code,
    mt.name as market_name
FROM
    odds_history oh
    JOIN events e ON oh.event_id = e.id
    LEFT JOIN teams ht ON e.home_team_id = ht.id
    LEFT JOIN teams at ON e.away_team_id = at.id
    JOIN market_types mt ON oh.market_type_id = mt.id
WHERE
    oh.recorded_at >= $1
    AND e.event_date > NOW() -- Look for movements against typical patterns
    AND (
        (
            oh.previous_value < 2.0
            AND oh.change_percentage > 15
        )
        OR -- Favorites drifting
        (
            oh.previous_value > 4.0
            AND oh.change_percentage < -15
        ) -- Big underdogs shortening
    )
ORDER BY
    ABS(oh.change_percentage) DESC
LIMIT
    $2
`

type GetReverseLineMovementsParams struct {
	SinceTime  pgtype.Timestamp `db:"since_time" json:"since_time"`
	LimitCount int64            `db:"limit_count" json:"limit_count"`
}

type GetReverseLineMovementsRow struct {
	ID                  int32            `db:"id" json:"id"`
	EventID             *int32           `db:"event_id" json:"event_id"`
	MarketTypeID        *int32           `db:"market_type_id" json:"market_type_id"`
	Outcome             string           `db:"outcome" json:"outcome"`
	OddsValue           float64          `db:"odds_value" json:"odds_value"`
	PreviousValue       *float64         `db:"previous_value" json:"previous_value"`
	WinningOdds         *float64         `db:"winning_odds" json:"winning_odds"`
	ChangeAmount        *float64         `db:"change_amount" json:"change_amount"`
	ChangePercentage    *float32         `db:"change_percentage" json:"change_percentage"`
	Multiplier          *float64         `db:"multiplier" json:"multiplier"`
	SharpMoneyIndicator *float32         `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement   *bool            `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel   *string          `db:"significance_level" json:"significance_level"`
	MinutesToKickoff    *int32           `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	MarketParams        []byte           `db:"market_params" json:"market_params"`
	RecordedAt          pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	EventExternalID     string           `db:"event_external_id" json:"event_external_id"`
	EventDate           pgtype.Timestamp `db:"event_date" json:"event_date"`
	HomeTeamID          *int32           `db:"home_team_id" json:"home_team_id"`
	AwayTeamID          *int32           `db:"away_team_id" json:"away_team_id"`
	HomeTeamName        *string          `db:"home_team_name" json:"home_team_name"`
	AwayTeamName        *string          `db:"away_team_name" json:"away_team_name"`
	MarketCode          string           `db:"market_code" json:"market_code"`
	MarketName          string           `db:"market_name" json:"market_name"`
}

func (q *Queries) GetReverseLineMovements(ctx context.Context, arg GetReverseLineMovementsParams) ([]GetReverseLineMovementsRow, error) {
	rows, err := q.db.Query(ctx, getReverseLineMovements, arg.SinceTime, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReverseLineMovementsRow{}
	for rows.Next() {
		var i GetReverseLineMovementsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.MarketParams,
			&i.RecordedAt,
			&i.EventExternalID,
			&i.EventDate,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.MarketCode,
			&i.MarketName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValueSpots = `-- name: GetValueSpots :many
SELECT
    oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff, oh.market_params, oh.recorded_at,
    od.bet_percentage,
    od.implied_probability,
    e.external_id as event_external_id,
    e.event_date,
    e.home_team_id,
    e.away_team_id,
    ht.name as home_team_name,
    at.name as away_team_name,
    mt.code as market_code,
    mt.name as market_name,
    (od.bet_percentage - od.implied_probability) as public_bias
FROM
    odds_history oh
    JOIN events e ON oh.event_id = e.id
    LEFT JOIN teams ht ON e.home_team_id = ht.id
    LEFT JOIN teams at ON e.away_team_id = at.id
    JOIN market_types mt ON oh.market_type_id = mt.id
    LEFT JOIN outcome_distributions od ON (
        oh.event_id = od.event_id
        AND oh.market_type_id = od.market_type_id
        AND oh.outcome = od.outcome
    )
WHERE
    oh.recorded_at >= $1
    AND e.event_date > NOW()
    AND od.bet_percentage > od.implied_probability + $2::float8
    AND ABS(oh.change_percentage) >= $3::float8
ORDER BY
    (od.bet_percentage - od.implied_probability) DESC
LIMIT
    $4
`

type GetValueSpotsParams struct {
	SinceTime      pgtype.Timestamp `db:"since_time" json:"since_time"`
	MinBiasPct     float64          `db:"min_bias_pct" json:"min_bias_pct"`
	MinMovementPct float64          `db:"min_movement_pct" json:"min_movement_pct"`
	LimitCount     int64            `db:"limit_count" json:"limit_count"`
}

type GetValueSpotsRow struct {
	ID                  int32            `db:"id" json:"id"`
	EventID             *int32           `db:"event_id" json:"event_id"`
	MarketTypeID        *int32           `db:"market_type_id" json:"market_type_id"`
	Outcome             string           `db:"outcome" json:"outcome"`
	OddsValue           float64          `db:"odds_value" json:"odds_value"`
	PreviousValue       *float64         `db:"previous_value" json:"previous_value"`
	WinningOdds         *float64         `db:"winning_odds" json:"winning_odds"`
	ChangeAmount        *float64         `db:"change_amount" json:"change_amount"`
	ChangePercentage    *float32         `db:"change_percentage" json:"change_percentage"`
	Multiplier          *float64         `db:"multiplier" json:"multiplier"`
	SharpMoneyIndicator *float32         `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement   *bool            `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel   *string          `db:"significance_level" json:"significance_level"`
	MinutesToKickoff    *int32           `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	MarketParams        []byte           `db:"market_params" json:"market_params"`
	RecordedAt          pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	BetPercentage       *float32         `db:"bet_percentage" json:"bet_percentage"`
	ImpliedProbability  *float32         `db:"implied_probability" json:"implied_probability"`
	EventExternalID     string           `db:"event_external_id" json:"event_external_id"`
	EventDate           pgtype.Timestamp `db:"event_date" json:"event_date"`
	HomeTeamID          *int32           `db:"home_team_id" json:"home_team_id"`
	AwayTeamID          *int32           `db:"away_team_id" json:"away_team_id"`
	HomeTeamName        *string          `db:"home_team_name" json:"home_team_name"`
	AwayTeamName        *string          `db:"away_team_name" json:"away_team_name"`
	MarketCode          string           `db:"market_code" json:"market_code"`
	MarketName          string           `db:"market_name" json:"market_name"`
	PublicBias          int32            `db:"public_bias" json:"public_bias"`
}

func (q *Queries) GetValueSpots(ctx context.Context, arg GetValueSpotsParams) ([]GetValueSpotsRow, error) {
	rows, err := q.db.Query(ctx, getValueSpots,
		arg.SinceTime,
		arg.MinBiasPct,
		arg.MinMovementPct,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetValueSpotsRow{}
	for rows.Next() {
		var i GetValueSpotsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.MarketParams,
			&i.RecordedAt,
			&i.BetPercentage,
			&i.ImpliedProbability,
			&i.EventExternalID,
			&i.EventDate,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.MarketCode,
			&i.MarketName,
			&i.PublicBias,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAlertClicked = `-- name: MarkAlertClicked :exec
UPDATE
    movement_alerts
SET
    clicks = clicks + 1
WHERE
    id = $1
`

func (q *Queries) MarkAlertClicked(ctx context.Context, alertID int32) error {
	_, err := q.db.Exec(ctx, markAlertClicked, alertID)
	return err
}

const markAlertViewed = `-- name: MarkAlertViewed :exec
UPDATE
    movement_alerts
SET
    views = views + 1
WHERE
    id = $1
`

// COMMENTED OUT: Requires smart_money_preferences table
// -- name: GetAlertsByUser :many
// SELECT
//
//	ma.*,
//	oh.event_id,
//	oh.outcome,
//	e.external_id as event_external_id,
//	e.event_date,
//	ht.name as home_team_name,
//	at.name as away_team_name,
//	mt.name as market_name
//
// FROM movement_alerts ma
// JOIN odds_history oh ON ma.odds_history_id = oh.id
// JOIN events e ON oh.event_id = e.id
// LEFT JOIN teams ht ON e.home_team_id = ht.id
// LEFT JOIN teams at ON e.away_team_id = at.id
// JOIN market_types mt ON oh.market_type_id = mt.id
// JOIN smart_money_preferences smp ON smp.user_id = sqlc.arg(user_id)
// WHERE
//
//	ma.is_active = true
//	AND ma.expires_at > NOW()
//	AND ma.change_percentage >= smp.min_change_percentage
//	AND ma.multiplier >= smp.min_multiplier
//	AND ma.confidence_score >= smp.min_confidence_score
//	AND (
//	    (ma.alert_type = 'big_mover' AND smp.big_mover_alerts = true) OR
//	    (ma.alert_type = 'reverse_line' AND smp.reverse_line_alerts = true) OR
//	    (ma.alert_type = 'sharp_money' AND smp.sharp_money_alerts = true) OR
//	    (ma.alert_type = 'value_spot' AND smp.value_spot_alerts = true)
//	)
//	-- Filter by preferred sports/leagues if specified
//	AND (
//	    smp.preferred_sports = '[]'::jsonb OR
//	    e.sport_id::text = ANY(SELECT jsonb_array_elements_text(smp.preferred_sports))
//	)
//
// ORDER BY ma.created_at DESC
// LIMIT sqlc.arg(limit_count);
func (q *Queries) MarkAlertViewed(ctx context.Context, alertID int32) error {
	_, err := q.db.Exec(ctx, markAlertViewed, alertID)
	return err
}
