// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: teams.sql

package generated

import (
	"context"
)

const bulkUpsertTeams = `-- name: BulkUpsertTeams :many
INSERT INTO
    teams (external_id, name, slug, created_at, updated_at)
SELECT
    unnest($1::text[]) as external_id,
    unnest($2::text[]) as name,
    unnest($3::text[]) as slug,
    NOW() as created_at,
    NOW() as updated_at ON CONFLICT (external_id) DO
UPDATE
SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    updated_at = NOW() RETURNING id,
    external_id
`

type BulkUpsertTeamsParams struct {
	ExternalIds []string `db:"external_ids" json:"external_ids"`
	Names       []string `db:"names" json:"names"`
	Slugs       []string `db:"slugs" json:"slugs"`
}

type BulkUpsertTeamsRow struct {
	ID         int32  `db:"id" json:"id"`
	ExternalID string `db:"external_id" json:"external_id"`
}

func (q *Queries) BulkUpsertTeams(ctx context.Context, arg BulkUpsertTeamsParams) ([]BulkUpsertTeamsRow, error) {
	rows, err := q.db.Query(ctx, bulkUpsertTeams, arg.ExternalIds, arg.Names, arg.Slugs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BulkUpsertTeamsRow{}
	for rows.Next() {
		var i BulkUpsertTeamsRow
		if err := rows.Scan(&i.ID, &i.ExternalID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO
    teams (external_id, name, slug, country, logo_url)
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5
    ) RETURNING id, external_id, name, country, logo_url, is_active, slug, api_football_id, team_code, founded_year, is_national_team, venue_id, venue_name, venue_address, venue_city, venue_capacity, venue_surface, venue_image_url, api_enrichment_data, last_api_update, created_at, updated_at
`

type CreateTeamParams struct {
	ExternalID string  `db:"external_id" json:"external_id"`
	Name       string  `db:"name" json:"name"`
	Slug       string  `db:"slug" json:"slug"`
	Country    *string `db:"country" json:"country"`
	LogoUrl    *string `db:"logo_url" json:"logo_url"`
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (Team, error) {
	row := q.db.QueryRow(ctx, createTeam,
		arg.ExternalID,
		arg.Name,
		arg.Slug,
		arg.Country,
		arg.LogoUrl,
	)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Country,
		&i.LogoUrl,
		&i.IsActive,
		&i.Slug,
		&i.ApiFootballID,
		&i.TeamCode,
		&i.FoundedYear,
		&i.IsNationalTeam,
		&i.VenueID,
		&i.VenueName,
		&i.VenueAddress,
		&i.VenueCity,
		&i.VenueCapacity,
		&i.VenueSurface,
		&i.VenueImageUrl,
		&i.ApiEnrichmentData,
		&i.LastApiUpdate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const enrichTeamWithAPIFootball = `-- name: EnrichTeamWithAPIFootball :one
UPDATE
    teams
SET
    api_football_id = $1,
    team_code = $2,
    founded_year = $3,
    is_national_team = $4,
    venue_id = $5,
    venue_name = $6,
    venue_address = $7,
    venue_city = $8,
    venue_capacity = $9,
    venue_surface = $10,
    venue_image_url = $11,
    api_enrichment_data = $12,
    last_api_update = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE
    id = $13 RETURNING id, external_id, name, country, logo_url, is_active, slug, api_football_id, team_code, founded_year, is_national_team, venue_id, venue_name, venue_address, venue_city, venue_capacity, venue_surface, venue_image_url, api_enrichment_data, last_api_update, created_at, updated_at
`

type EnrichTeamWithAPIFootballParams struct {
	ApiFootballID     *int32  `db:"api_football_id" json:"api_football_id"`
	TeamCode          *string `db:"team_code" json:"team_code"`
	FoundedYear       *int32  `db:"founded_year" json:"founded_year"`
	IsNationalTeam    *bool   `db:"is_national_team" json:"is_national_team"`
	VenueID           *int32  `db:"venue_id" json:"venue_id"`
	VenueName         *string `db:"venue_name" json:"venue_name"`
	VenueAddress      *string `db:"venue_address" json:"venue_address"`
	VenueCity         *string `db:"venue_city" json:"venue_city"`
	VenueCapacity     *int32  `db:"venue_capacity" json:"venue_capacity"`
	VenueSurface      *string `db:"venue_surface" json:"venue_surface"`
	VenueImageUrl     *string `db:"venue_image_url" json:"venue_image_url"`
	ApiEnrichmentData []byte  `db:"api_enrichment_data" json:"api_enrichment_data"`
	ID                int32   `db:"id" json:"id"`
}

func (q *Queries) EnrichTeamWithAPIFootball(ctx context.Context, arg EnrichTeamWithAPIFootballParams) (Team, error) {
	row := q.db.QueryRow(ctx, enrichTeamWithAPIFootball,
		arg.ApiFootballID,
		arg.TeamCode,
		arg.FoundedYear,
		arg.IsNationalTeam,
		arg.VenueID,
		arg.VenueName,
		arg.VenueAddress,
		arg.VenueCity,
		arg.VenueCapacity,
		arg.VenueSurface,
		arg.VenueImageUrl,
		arg.ApiEnrichmentData,
		arg.ID,
	)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Country,
		&i.LogoUrl,
		&i.IsActive,
		&i.Slug,
		&i.ApiFootballID,
		&i.TeamCode,
		&i.FoundedYear,
		&i.IsNationalTeam,
		&i.VenueID,
		&i.VenueName,
		&i.VenueAddress,
		&i.VenueCity,
		&i.VenueCapacity,
		&i.VenueSurface,
		&i.VenueImageUrl,
		&i.ApiEnrichmentData,
		&i.LastApiUpdate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNationalTeams = `-- name: GetNationalTeams :many
SELECT
    id, external_id, name, country, logo_url, is_active, slug, api_football_id, team_code, founded_year, is_national_team, venue_id, venue_name, venue_address, venue_city, venue_capacity, venue_surface, venue_image_url, api_enrichment_data, last_api_update, created_at, updated_at
FROM
    teams
WHERE
    is_national_team = true
ORDER BY
    name
`

func (q *Queries) GetNationalTeams(ctx context.Context) ([]Team, error) {
	rows, err := q.db.Query(ctx, getNationalTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.LogoUrl,
			&i.IsActive,
			&i.Slug,
			&i.ApiFootballID,
			&i.TeamCode,
			&i.FoundedYear,
			&i.IsNationalTeam,
			&i.VenueID,
			&i.VenueName,
			&i.VenueAddress,
			&i.VenueCity,
			&i.VenueCapacity,
			&i.VenueSurface,
			&i.VenueImageUrl,
			&i.ApiEnrichmentData,
			&i.LastApiUpdate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeam = `-- name: GetTeam :one
SELECT
    id, external_id, name, country, logo_url, is_active, slug, api_football_id, team_code, founded_year, is_national_team, venue_id, venue_name, venue_address, venue_city, venue_capacity, venue_surface, venue_image_url, api_enrichment_data, last_api_update, created_at, updated_at
FROM
    teams
WHERE
    id = $1
`

func (q *Queries) GetTeam(ctx context.Context, id int32) (Team, error) {
	row := q.db.QueryRow(ctx, getTeam, id)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Country,
		&i.LogoUrl,
		&i.IsActive,
		&i.Slug,
		&i.ApiFootballID,
		&i.TeamCode,
		&i.FoundedYear,
		&i.IsNationalTeam,
		&i.VenueID,
		&i.VenueName,
		&i.VenueAddress,
		&i.VenueCity,
		&i.VenueCapacity,
		&i.VenueSurface,
		&i.VenueImageUrl,
		&i.ApiEnrichmentData,
		&i.LastApiUpdate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTeamByExternalID = `-- name: GetTeamByExternalID :one
SELECT
    id, external_id, name, country, logo_url, is_active, slug, api_football_id, team_code, founded_year, is_national_team, venue_id, venue_name, venue_address, venue_city, venue_capacity, venue_surface, venue_image_url, api_enrichment_data, last_api_update, created_at, updated_at
FROM
    teams
WHERE
    external_id = $1
`

func (q *Queries) GetTeamByExternalID(ctx context.Context, externalID string) (Team, error) {
	row := q.db.QueryRow(ctx, getTeamByExternalID, externalID)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Country,
		&i.LogoUrl,
		&i.IsActive,
		&i.Slug,
		&i.ApiFootballID,
		&i.TeamCode,
		&i.FoundedYear,
		&i.IsNationalTeam,
		&i.VenueID,
		&i.VenueName,
		&i.VenueAddress,
		&i.VenueCity,
		&i.VenueCapacity,
		&i.VenueSurface,
		&i.VenueImageUrl,
		&i.ApiEnrichmentData,
		&i.LastApiUpdate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTeamsByAPIFootballID = `-- name: GetTeamsByAPIFootballID :one
SELECT
    id, external_id, name, country, logo_url, is_active, slug, api_football_id, team_code, founded_year, is_national_team, venue_id, venue_name, venue_address, venue_city, venue_capacity, venue_surface, venue_image_url, api_enrichment_data, last_api_update, created_at, updated_at
FROM
    teams
WHERE
    api_football_id = $1
`

func (q *Queries) GetTeamsByAPIFootballID(ctx context.Context, apiFootballID *int32) (Team, error) {
	row := q.db.QueryRow(ctx, getTeamsByAPIFootballID, apiFootballID)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Country,
		&i.LogoUrl,
		&i.IsActive,
		&i.Slug,
		&i.ApiFootballID,
		&i.TeamCode,
		&i.FoundedYear,
		&i.IsNationalTeam,
		&i.VenueID,
		&i.VenueName,
		&i.VenueAddress,
		&i.VenueCity,
		&i.VenueCapacity,
		&i.VenueSurface,
		&i.VenueImageUrl,
		&i.ApiEnrichmentData,
		&i.LastApiUpdate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTeamsByFoundedRange = `-- name: GetTeamsByFoundedRange :many
SELECT
    id, external_id, name, country, logo_url, is_active, slug, api_football_id, team_code, founded_year, is_national_team, venue_id, venue_name, venue_address, venue_city, venue_capacity, venue_surface, venue_image_url, api_enrichment_data, last_api_update, created_at, updated_at
FROM
    teams
WHERE
    founded_year >= $1
    AND founded_year <= $2
ORDER BY
    founded_year DESC,
    name
`

type GetTeamsByFoundedRangeParams struct {
	MinYear *int32 `db:"min_year" json:"min_year"`
	MaxYear *int32 `db:"max_year" json:"max_year"`
}

func (q *Queries) GetTeamsByFoundedRange(ctx context.Context, arg GetTeamsByFoundedRangeParams) ([]Team, error) {
	rows, err := q.db.Query(ctx, getTeamsByFoundedRange, arg.MinYear, arg.MaxYear)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.LogoUrl,
			&i.IsActive,
			&i.Slug,
			&i.ApiFootballID,
			&i.TeamCode,
			&i.FoundedYear,
			&i.IsNationalTeam,
			&i.VenueID,
			&i.VenueName,
			&i.VenueAddress,
			&i.VenueCity,
			&i.VenueCapacity,
			&i.VenueSurface,
			&i.VenueImageUrl,
			&i.ApiEnrichmentData,
			&i.LastApiUpdate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsByVenueCapacity = `-- name: GetTeamsByVenueCapacity :many
SELECT
    id, external_id, name, country, logo_url, is_active, slug, api_football_id, team_code, founded_year, is_national_team, venue_id, venue_name, venue_address, venue_city, venue_capacity, venue_surface, venue_image_url, api_enrichment_data, last_api_update, created_at, updated_at
FROM
    teams
WHERE
    venue_capacity >= $1
ORDER BY
    venue_capacity DESC,
    name
LIMIT
    $2
`

type GetTeamsByVenueCapacityParams struct {
	MinCapacity *int32 `db:"min_capacity" json:"min_capacity"`
	LimitCount  int64  `db:"limit_count" json:"limit_count"`
}

func (q *Queries) GetTeamsByVenueCapacity(ctx context.Context, arg GetTeamsByVenueCapacityParams) ([]Team, error) {
	rows, err := q.db.Query(ctx, getTeamsByVenueCapacity, arg.MinCapacity, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.LogoUrl,
			&i.IsActive,
			&i.Slug,
			&i.ApiFootballID,
			&i.TeamCode,
			&i.FoundedYear,
			&i.IsNationalTeam,
			&i.VenueID,
			&i.VenueName,
			&i.VenueAddress,
			&i.VenueCity,
			&i.VenueCapacity,
			&i.VenueSurface,
			&i.VenueImageUrl,
			&i.ApiEnrichmentData,
			&i.LastApiUpdate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsNeedingEnrichment = `-- name: GetTeamsNeedingEnrichment :many
SELECT
    id, external_id, name, country, logo_url, is_active, slug, api_football_id, team_code, founded_year, is_national_team, venue_id, venue_name, venue_address, venue_city, venue_capacity, venue_surface, venue_image_url, api_enrichment_data, last_api_update, created_at, updated_at
FROM
    teams
WHERE
    api_football_id IS NULL
    OR last_api_update IS NULL
    OR last_api_update < (CURRENT_TIMESTAMP - INTERVAL '7 days')
ORDER BY
    last_api_update ASC NULLS FIRST
LIMIT
    $1
`

func (q *Queries) GetTeamsNeedingEnrichment(ctx context.Context, limitCount int64) ([]Team, error) {
	rows, err := q.db.Query(ctx, getTeamsNeedingEnrichment, limitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.LogoUrl,
			&i.IsActive,
			&i.Slug,
			&i.ApiFootballID,
			&i.TeamCode,
			&i.FoundedYear,
			&i.IsNationalTeam,
			&i.VenueID,
			&i.VenueName,
			&i.VenueAddress,
			&i.VenueCity,
			&i.VenueCapacity,
			&i.VenueSurface,
			&i.VenueImageUrl,
			&i.ApiEnrichmentData,
			&i.LastApiUpdate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamsByLeagueID = `-- name: ListTeamsByLeagueID :many
SELECT
    DISTINCT t.id, t.external_id, t.name, t.country, t.logo_url, t.is_active, t.slug, t.api_football_id, t.team_code, t.founded_year, t.is_national_team, t.venue_id, t.venue_name, t.venue_address, t.venue_city, t.venue_capacity, t.venue_surface, t.venue_image_url, t.api_enrichment_data, t.last_api_update, t.created_at, t.updated_at
FROM
    teams t
    INNER JOIN events e ON (
        t.id = e.home_team_id
        OR t.id = e.away_team_id
    )
WHERE
    e.league_id = $1
ORDER BY
    t.name
`

func (q *Queries) ListTeamsByLeagueID(ctx context.Context, leagueID *int32) ([]Team, error) {
	rows, err := q.db.Query(ctx, listTeamsByLeagueID, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.LogoUrl,
			&i.IsActive,
			&i.Slug,
			&i.ApiFootballID,
			&i.TeamCode,
			&i.FoundedYear,
			&i.IsNationalTeam,
			&i.VenueID,
			&i.VenueName,
			&i.VenueAddress,
			&i.VenueCity,
			&i.VenueCapacity,
			&i.VenueSurface,
			&i.VenueImageUrl,
			&i.ApiEnrichmentData,
			&i.LastApiUpdate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmappedTeams = `-- name: ListUnmappedTeams :many
SELECT
    t.id, t.external_id, t.name, t.country, t.logo_url, t.is_active, t.slug, t.api_football_id, t.team_code, t.founded_year, t.is_national_team, t.venue_id, t.venue_name, t.venue_address, t.venue_city, t.venue_capacity, t.venue_surface, t.venue_image_url, t.api_enrichment_data, t.last_api_update, t.created_at, t.updated_at
FROM
    teams t
    LEFT JOIN team_mappings tm ON t.id = tm.internal_team_id
WHERE
    tm.id IS NULL
`

func (q *Queries) ListUnmappedTeams(ctx context.Context) ([]Team, error) {
	rows, err := q.db.Query(ctx, listUnmappedTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.LogoUrl,
			&i.IsActive,
			&i.Slug,
			&i.ApiFootballID,
			&i.TeamCode,
			&i.FoundedYear,
			&i.IsNationalTeam,
			&i.VenueID,
			&i.VenueName,
			&i.VenueAddress,
			&i.VenueCity,
			&i.VenueCapacity,
			&i.VenueSurface,
			&i.VenueImageUrl,
			&i.ApiEnrichmentData,
			&i.LastApiUpdate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTeams = `-- name: SearchTeams :many
SELECT
    id, external_id, name, country, logo_url, is_active, slug, api_football_id, team_code, founded_year, is_national_team, venue_id, venue_name, venue_address, venue_city, venue_capacity, venue_surface, venue_image_url, api_enrichment_data, last_api_update, created_at, updated_at
FROM
    teams
WHERE
    name ILIKE '%' || $1 || '%'
ORDER BY
    name
LIMIT
    $2
`

type SearchTeamsParams struct {
	SearchTerm *string `db:"search_term" json:"search_term"`
	LimitCount int64   `db:"limit_count" json:"limit_count"`
}

func (q *Queries) SearchTeams(ctx context.Context, arg SearchTeamsParams) ([]Team, error) {
	rows, err := q.db.Query(ctx, searchTeams, arg.SearchTerm, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.LogoUrl,
			&i.IsActive,
			&i.Slug,
			&i.ApiFootballID,
			&i.TeamCode,
			&i.FoundedYear,
			&i.IsNationalTeam,
			&i.VenueID,
			&i.VenueName,
			&i.VenueAddress,
			&i.VenueCity,
			&i.VenueCapacity,
			&i.VenueSurface,
			&i.VenueImageUrl,
			&i.ApiEnrichmentData,
			&i.LastApiUpdate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTeamsByCode = `-- name: SearchTeamsByCode :many
SELECT
    id, external_id, name, country, logo_url, is_active, slug, api_football_id, team_code, founded_year, is_national_team, venue_id, venue_name, venue_address, venue_city, venue_capacity, venue_surface, venue_image_url, api_enrichment_data, last_api_update, created_at, updated_at
FROM
    teams
WHERE
    team_code ILIKE '%' || $1 || '%'
ORDER BY
    name
LIMIT
    $2
`

type SearchTeamsByCodeParams struct {
	CodeSearch *string `db:"code_search" json:"code_search"`
	LimitCount int64   `db:"limit_count" json:"limit_count"`
}

func (q *Queries) SearchTeamsByCode(ctx context.Context, arg SearchTeamsByCodeParams) ([]Team, error) {
	rows, err := q.db.Query(ctx, searchTeamsByCode, arg.CodeSearch, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.LogoUrl,
			&i.IsActive,
			&i.Slug,
			&i.ApiFootballID,
			&i.TeamCode,
			&i.FoundedYear,
			&i.IsNationalTeam,
			&i.VenueID,
			&i.VenueName,
			&i.VenueAddress,
			&i.VenueCity,
			&i.VenueCapacity,
			&i.VenueSurface,
			&i.VenueImageUrl,
			&i.ApiEnrichmentData,
			&i.LastApiUpdate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTeam = `-- name: UpdateTeam :one
UPDATE
    teams
SET
    name = $1,
    country = $2,
    logo_url = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE
    id = $4 RETURNING id, external_id, name, country, logo_url, is_active, slug, api_football_id, team_code, founded_year, is_national_team, venue_id, venue_name, venue_address, venue_city, venue_capacity, venue_surface, venue_image_url, api_enrichment_data, last_api_update, created_at, updated_at
`

type UpdateTeamParams struct {
	Name    string  `db:"name" json:"name"`
	Country *string `db:"country" json:"country"`
	LogoUrl *string `db:"logo_url" json:"logo_url"`
	ID      int32   `db:"id" json:"id"`
}

func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) (Team, error) {
	row := q.db.QueryRow(ctx, updateTeam,
		arg.Name,
		arg.Country,
		arg.LogoUrl,
		arg.ID,
	)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Country,
		&i.LogoUrl,
		&i.IsActive,
		&i.Slug,
		&i.ApiFootballID,
		&i.TeamCode,
		&i.FoundedYear,
		&i.IsNationalTeam,
		&i.VenueID,
		&i.VenueName,
		&i.VenueAddress,
		&i.VenueCity,
		&i.VenueCapacity,
		&i.VenueSurface,
		&i.VenueImageUrl,
		&i.ApiEnrichmentData,
		&i.LastApiUpdate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTeamApiFootballID = `-- name: UpdateTeamApiFootballID :exec
UPDATE
    teams
SET
    api_football_id = $1,
    updated_at = CURRENT_TIMESTAMP
WHERE
    id = $2
`

type UpdateTeamApiFootballIDParams struct {
	ApiFootballID *int32 `db:"api_football_id" json:"api_football_id"`
	ID            int32  `db:"id" json:"id"`
}

func (q *Queries) UpdateTeamApiFootballID(ctx context.Context, arg UpdateTeamApiFootballIDParams) error {
	_, err := q.db.Exec(ctx, updateTeamApiFootballID, arg.ApiFootballID, arg.ID)
	return err
}

const upsertTeam = `-- name: UpsertTeam :one
INSERT INTO
    teams (external_id, name, slug)
VALUES
    (
        $1,
        $2,
        $3
    ) ON CONFLICT (external_id) DO
UPDATE
SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    updated_at = CURRENT_TIMESTAMP RETURNING id, external_id, name, country, logo_url, is_active, slug, api_football_id, team_code, founded_year, is_national_team, venue_id, venue_name, venue_address, venue_city, venue_capacity, venue_surface, venue_image_url, api_enrichment_data, last_api_update, created_at, updated_at
`

type UpsertTeamParams struct {
	ExternalID string `db:"external_id" json:"external_id"`
	Name       string `db:"name" json:"name"`
	Slug       string `db:"slug" json:"slug"`
}

func (q *Queries) UpsertTeam(ctx context.Context, arg UpsertTeamParams) (Team, error) {
	row := q.db.QueryRow(ctx, upsertTeam, arg.ExternalID, arg.Name, arg.Slug)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Country,
		&i.LogoUrl,
		&i.IsActive,
		&i.Slug,
		&i.ApiFootballID,
		&i.TeamCode,
		&i.FoundedYear,
		&i.IsNationalTeam,
		&i.VenueID,
		&i.VenueName,
		&i.VenueAddress,
		&i.VenueCity,
		&i.VenueCapacity,
		&i.VenueSurface,
		&i.VenueImageUrl,
		&i.ApiEnrichmentData,
		&i.LastApiUpdate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertTeamMapping = `-- name: UpsertTeamMapping :one
INSERT INTO
    team_mappings (
        internal_team_id,
        football_api_team_id,
        confidence,
        mapping_method
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4
    ) ON CONFLICT (internal_team_id) DO
UPDATE
SET
    football_api_team_id = EXCLUDED.football_api_team_id,
    confidence = EXCLUDED.confidence,
    mapping_method = EXCLUDED.mapping_method,
    updated_at = CURRENT_TIMESTAMP RETURNING id, internal_team_id, football_api_team_id, confidence, mapping_method, translated_team_name, translated_country, translated_league, original_team_name, original_country, original_league, match_factors, needs_review, ai_translation_used, normalization_applied, match_score, created_at, updated_at
`

type UpsertTeamMappingParams struct {
	InternalTeamID    int32   `db:"internal_team_id" json:"internal_team_id"`
	FootballApiTeamID int32   `db:"football_api_team_id" json:"football_api_team_id"`
	Confidence        float32 `db:"confidence" json:"confidence"`
	MappingMethod     string  `db:"mapping_method" json:"mapping_method"`
}

func (q *Queries) UpsertTeamMapping(ctx context.Context, arg UpsertTeamMappingParams) (TeamMapping, error) {
	row := q.db.QueryRow(ctx, upsertTeamMapping,
		arg.InternalTeamID,
		arg.FootballApiTeamID,
		arg.Confidence,
		arg.MappingMethod,
	)
	var i TeamMapping
	err := row.Scan(
		&i.ID,
		&i.InternalTeamID,
		&i.FootballApiTeamID,
		&i.Confidence,
		&i.MappingMethod,
		&i.TranslatedTeamName,
		&i.TranslatedCountry,
		&i.TranslatedLeague,
		&i.OriginalTeamName,
		&i.OriginalCountry,
		&i.OriginalLeague,
		&i.MatchFactors,
		&i.NeedsReview,
		&i.AiTranslationUsed,
		&i.NormalizationApplied,
		&i.MatchScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
