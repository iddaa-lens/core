// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: leagues.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkUpsertLeagues = `-- name: BulkUpsertLeagues :execrows
INSERT INTO leagues (external_id, name, country, sport_id, is_active)
VALUES (
    unnest($1::text[]),
    unnest($2::text[]),
    unnest($3::text[]),
    unnest($4::int[]),
    unnest($5::boolean[])
)
ON CONFLICT (external_id) DO UPDATE SET
    name = EXCLUDED.name,
    country = EXCLUDED.country,
    sport_id = EXCLUDED.sport_id,
    is_active = EXCLUDED.is_active,
    updated_at = CURRENT_TIMESTAMP
`

type BulkUpsertLeaguesParams struct {
	ExternalIds []string `db:"external_ids" json:"external_ids"`
	Names       []string `db:"names" json:"names"`
	Countries   []string `db:"countries" json:"countries"`
	SportIds    []int32  `db:"sport_ids" json:"sport_ids"`
	IsActives   []bool   `db:"is_actives" json:"is_actives"`
}

func (q *Queries) BulkUpsertLeagues(ctx context.Context, arg BulkUpsertLeaguesParams) (int64, error) {
	result, err := q.db.Exec(ctx, bulkUpsertLeagues,
		arg.ExternalIds,
		arg.Names,
		arg.Countries,
		arg.SportIds,
		arg.IsActives,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createEnhancedLeagueMapping = `-- name: CreateEnhancedLeagueMapping :one
INSERT INTO league_mappings (
    internal_league_id,
    football_api_league_id,
    confidence,
    mapping_method,
    translated_league_name,
    translated_country,
    original_league_name,
    original_country,
    match_factors,
    needs_review,
    ai_translation_used,
    normalization_applied,
    match_score
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13
) RETURNING id, internal_league_id, football_api_league_id, confidence, mapping_method, translated_league_name, translated_country, original_league_name, original_country, match_factors, needs_review, ai_translation_used, normalization_applied, match_score, created_at, updated_at
`

type CreateEnhancedLeagueMappingParams struct {
	InternalLeagueID     int32    `db:"internal_league_id" json:"internal_league_id"`
	FootballApiLeagueID  int32    `db:"football_api_league_id" json:"football_api_league_id"`
	Confidence           float32  `db:"confidence" json:"confidence"`
	MappingMethod        string   `db:"mapping_method" json:"mapping_method"`
	TranslatedLeagueName *string  `db:"translated_league_name" json:"translated_league_name"`
	TranslatedCountry    *string  `db:"translated_country" json:"translated_country"`
	OriginalLeagueName   *string  `db:"original_league_name" json:"original_league_name"`
	OriginalCountry      *string  `db:"original_country" json:"original_country"`
	MatchFactors         []byte   `db:"match_factors" json:"match_factors"`
	NeedsReview          *bool    `db:"needs_review" json:"needs_review"`
	AiTranslationUsed    *bool    `db:"ai_translation_used" json:"ai_translation_used"`
	NormalizationApplied *bool    `db:"normalization_applied" json:"normalization_applied"`
	MatchScore           *float32 `db:"match_score" json:"match_score"`
}

func (q *Queries) CreateEnhancedLeagueMapping(ctx context.Context, arg CreateEnhancedLeagueMappingParams) (LeagueMapping, error) {
	row := q.db.QueryRow(ctx, createEnhancedLeagueMapping,
		arg.InternalLeagueID,
		arg.FootballApiLeagueID,
		arg.Confidence,
		arg.MappingMethod,
		arg.TranslatedLeagueName,
		arg.TranslatedCountry,
		arg.OriginalLeagueName,
		arg.OriginalCountry,
		arg.MatchFactors,
		arg.NeedsReview,
		arg.AiTranslationUsed,
		arg.NormalizationApplied,
		arg.MatchScore,
	)
	var i LeagueMapping
	err := row.Scan(
		&i.ID,
		&i.InternalLeagueID,
		&i.FootballApiLeagueID,
		&i.Confidence,
		&i.MappingMethod,
		&i.TranslatedLeagueName,
		&i.TranslatedCountry,
		&i.OriginalLeagueName,
		&i.OriginalCountry,
		&i.MatchFactors,
		&i.NeedsReview,
		&i.AiTranslationUsed,
		&i.NormalizationApplied,
		&i.MatchScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEnhancedTeamMapping = `-- name: CreateEnhancedTeamMapping :one
INSERT INTO team_mappings (
    internal_team_id,
    football_api_team_id,
    confidence,
    mapping_method,
    translated_team_name,
    translated_country,
    translated_league,
    original_team_name,
    original_country,
    original_league,
    match_factors,
    needs_review,
    ai_translation_used,
    normalization_applied,
    match_score
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15
) RETURNING id, internal_team_id, football_api_team_id, confidence, mapping_method, translated_team_name, translated_country, translated_league, original_team_name, original_country, original_league, match_factors, needs_review, ai_translation_used, normalization_applied, match_score, created_at, updated_at
`

type CreateEnhancedTeamMappingParams struct {
	InternalTeamID       int32    `db:"internal_team_id" json:"internal_team_id"`
	FootballApiTeamID    int32    `db:"football_api_team_id" json:"football_api_team_id"`
	Confidence           float32  `db:"confidence" json:"confidence"`
	MappingMethod        string   `db:"mapping_method" json:"mapping_method"`
	TranslatedTeamName   *string  `db:"translated_team_name" json:"translated_team_name"`
	TranslatedCountry    *string  `db:"translated_country" json:"translated_country"`
	TranslatedLeague     *string  `db:"translated_league" json:"translated_league"`
	OriginalTeamName     *string  `db:"original_team_name" json:"original_team_name"`
	OriginalCountry      *string  `db:"original_country" json:"original_country"`
	OriginalLeague       *string  `db:"original_league" json:"original_league"`
	MatchFactors         []byte   `db:"match_factors" json:"match_factors"`
	NeedsReview          *bool    `db:"needs_review" json:"needs_review"`
	AiTranslationUsed    *bool    `db:"ai_translation_used" json:"ai_translation_used"`
	NormalizationApplied *bool    `db:"normalization_applied" json:"normalization_applied"`
	MatchScore           *float32 `db:"match_score" json:"match_score"`
}

func (q *Queries) CreateEnhancedTeamMapping(ctx context.Context, arg CreateEnhancedTeamMappingParams) (TeamMapping, error) {
	row := q.db.QueryRow(ctx, createEnhancedTeamMapping,
		arg.InternalTeamID,
		arg.FootballApiTeamID,
		arg.Confidence,
		arg.MappingMethod,
		arg.TranslatedTeamName,
		arg.TranslatedCountry,
		arg.TranslatedLeague,
		arg.OriginalTeamName,
		arg.OriginalCountry,
		arg.OriginalLeague,
		arg.MatchFactors,
		arg.NeedsReview,
		arg.AiTranslationUsed,
		arg.NormalizationApplied,
		arg.MatchScore,
	)
	var i TeamMapping
	err := row.Scan(
		&i.ID,
		&i.InternalTeamID,
		&i.FootballApiTeamID,
		&i.Confidence,
		&i.MappingMethod,
		&i.TranslatedTeamName,
		&i.TranslatedCountry,
		&i.TranslatedLeague,
		&i.OriginalTeamName,
		&i.OriginalCountry,
		&i.OriginalLeague,
		&i.MatchFactors,
		&i.NeedsReview,
		&i.AiTranslationUsed,
		&i.NormalizationApplied,
		&i.MatchScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLeagueMapping = `-- name: CreateLeagueMapping :one
INSERT INTO league_mappings (
    internal_league_id, 
    football_api_league_id, 
    confidence, 
    mapping_method
) VALUES (
    $1, $2, $3, $4
) RETURNING id, internal_league_id, football_api_league_id, confidence, mapping_method, translated_league_name, translated_country, original_league_name, original_country, match_factors, needs_review, ai_translation_used, normalization_applied, match_score, created_at, updated_at
`

type CreateLeagueMappingParams struct {
	InternalLeagueID    int32   `db:"internal_league_id" json:"internal_league_id"`
	FootballApiLeagueID int32   `db:"football_api_league_id" json:"football_api_league_id"`
	Confidence          float32 `db:"confidence" json:"confidence"`
	MappingMethod       string  `db:"mapping_method" json:"mapping_method"`
}

func (q *Queries) CreateLeagueMapping(ctx context.Context, arg CreateLeagueMappingParams) (LeagueMapping, error) {
	row := q.db.QueryRow(ctx, createLeagueMapping,
		arg.InternalLeagueID,
		arg.FootballApiLeagueID,
		arg.Confidence,
		arg.MappingMethod,
	)
	var i LeagueMapping
	err := row.Scan(
		&i.ID,
		&i.InternalLeagueID,
		&i.FootballApiLeagueID,
		&i.Confidence,
		&i.MappingMethod,
		&i.TranslatedLeagueName,
		&i.TranslatedCountry,
		&i.OriginalLeagueName,
		&i.OriginalCountry,
		&i.MatchFactors,
		&i.NeedsReview,
		&i.AiTranslationUsed,
		&i.NormalizationApplied,
		&i.MatchScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTeamMapping = `-- name: CreateTeamMapping :one
INSERT INTO team_mappings (
    internal_team_id, 
    football_api_team_id, 
    confidence, 
    mapping_method
) VALUES (
    $1, $2, $3, $4
) RETURNING id, internal_team_id, football_api_team_id, confidence, mapping_method, translated_team_name, translated_country, translated_league, original_team_name, original_country, original_league, match_factors, needs_review, ai_translation_used, normalization_applied, match_score, created_at, updated_at
`

type CreateTeamMappingParams struct {
	InternalTeamID    int32   `db:"internal_team_id" json:"internal_team_id"`
	FootballApiTeamID int32   `db:"football_api_team_id" json:"football_api_team_id"`
	Confidence        float32 `db:"confidence" json:"confidence"`
	MappingMethod     string  `db:"mapping_method" json:"mapping_method"`
}

func (q *Queries) CreateTeamMapping(ctx context.Context, arg CreateTeamMappingParams) (TeamMapping, error) {
	row := q.db.QueryRow(ctx, createTeamMapping,
		arg.InternalTeamID,
		arg.FootballApiTeamID,
		arg.Confidence,
		arg.MappingMethod,
	)
	var i TeamMapping
	err := row.Scan(
		&i.ID,
		&i.InternalTeamID,
		&i.FootballApiTeamID,
		&i.Confidence,
		&i.MappingMethod,
		&i.TranslatedTeamName,
		&i.TranslatedCountry,
		&i.TranslatedLeague,
		&i.OriginalTeamName,
		&i.OriginalCountry,
		&i.OriginalLeague,
		&i.MatchFactors,
		&i.NeedsReview,
		&i.AiTranslationUsed,
		&i.NormalizationApplied,
		&i.MatchScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLeague = `-- name: DeleteLeague :exec
DELETE FROM leagues WHERE id = $1
`

func (q *Queries) DeleteLeague(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteLeague, id)
	return err
}

const enrichLeagueWithAPIFootball = `-- name: EnrichLeagueWithAPIFootball :one
UPDATE leagues SET
    api_football_id = $1,
    league_type = $2,
    logo_url = $3,
    country_code = $4,
    country_flag_url = $5,
    has_standings = $6,
    has_fixtures = $7,
    has_players = $8,
    has_top_scorers = $9,
    has_injuries = $10,
    has_predictions = $11,
    has_odds = $12,
    current_season_year = $13,
    current_season_start = $14,
    current_season_end = $15,
    api_enrichment_data = $16,
    last_api_update = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $17
RETURNING id, external_id, name, country, sport_id, is_active, slug, api_football_id, league_type, logo_url, country_code, country_flag_url, has_standings, has_fixtures, has_players, has_top_scorers, has_injuries, has_predictions, has_odds, current_season_year, current_season_start, current_season_end, api_enrichment_data, last_api_update, created_at, updated_at
`

type EnrichLeagueWithAPIFootballParams struct {
	ApiFootballID      *int32      `db:"api_football_id" json:"api_football_id"`
	LeagueType         *string     `db:"league_type" json:"league_type"`
	LogoUrl            *string     `db:"logo_url" json:"logo_url"`
	CountryCode        *string     `db:"country_code" json:"country_code"`
	CountryFlagUrl     *string     `db:"country_flag_url" json:"country_flag_url"`
	HasStandings       *bool       `db:"has_standings" json:"has_standings"`
	HasFixtures        *bool       `db:"has_fixtures" json:"has_fixtures"`
	HasPlayers         *bool       `db:"has_players" json:"has_players"`
	HasTopScorers      *bool       `db:"has_top_scorers" json:"has_top_scorers"`
	HasInjuries        *bool       `db:"has_injuries" json:"has_injuries"`
	HasPredictions     *bool       `db:"has_predictions" json:"has_predictions"`
	HasOdds            *bool       `db:"has_odds" json:"has_odds"`
	CurrentSeasonYear  *int32      `db:"current_season_year" json:"current_season_year"`
	CurrentSeasonStart pgtype.Date `db:"current_season_start" json:"current_season_start"`
	CurrentSeasonEnd   pgtype.Date `db:"current_season_end" json:"current_season_end"`
	ApiEnrichmentData  []byte      `db:"api_enrichment_data" json:"api_enrichment_data"`
	ID                 int32       `db:"id" json:"id"`
}

func (q *Queries) EnrichLeagueWithAPIFootball(ctx context.Context, arg EnrichLeagueWithAPIFootballParams) (League, error) {
	row := q.db.QueryRow(ctx, enrichLeagueWithAPIFootball,
		arg.ApiFootballID,
		arg.LeagueType,
		arg.LogoUrl,
		arg.CountryCode,
		arg.CountryFlagUrl,
		arg.HasStandings,
		arg.HasFixtures,
		arg.HasPlayers,
		arg.HasTopScorers,
		arg.HasInjuries,
		arg.HasPredictions,
		arg.HasOdds,
		arg.CurrentSeasonYear,
		arg.CurrentSeasonStart,
		arg.CurrentSeasonEnd,
		arg.ApiEnrichmentData,
		arg.ID,
	)
	var i League
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Country,
		&i.SportID,
		&i.IsActive,
		&i.Slug,
		&i.ApiFootballID,
		&i.LeagueType,
		&i.LogoUrl,
		&i.CountryCode,
		&i.CountryFlagUrl,
		&i.HasStandings,
		&i.HasFixtures,
		&i.HasPlayers,
		&i.HasTopScorers,
		&i.HasInjuries,
		&i.HasPredictions,
		&i.HasOdds,
		&i.CurrentSeasonYear,
		&i.CurrentSeasonStart,
		&i.CurrentSeasonEnd,
		&i.ApiEnrichmentData,
		&i.LastApiUpdate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeague = `-- name: GetLeague :one
SELECT id, external_id, name, country, sport_id, is_active, slug, api_football_id, league_type, logo_url, country_code, country_flag_url, has_standings, has_fixtures, has_players, has_top_scorers, has_injuries, has_predictions, has_odds, current_season_year, current_season_start, current_season_end, api_enrichment_data, last_api_update, created_at, updated_at FROM leagues WHERE id = $1
`

func (q *Queries) GetLeague(ctx context.Context, id int32) (League, error) {
	row := q.db.QueryRow(ctx, getLeague, id)
	var i League
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Country,
		&i.SportID,
		&i.IsActive,
		&i.Slug,
		&i.ApiFootballID,
		&i.LeagueType,
		&i.LogoUrl,
		&i.CountryCode,
		&i.CountryFlagUrl,
		&i.HasStandings,
		&i.HasFixtures,
		&i.HasPlayers,
		&i.HasTopScorers,
		&i.HasInjuries,
		&i.HasPredictions,
		&i.HasOdds,
		&i.CurrentSeasonYear,
		&i.CurrentSeasonStart,
		&i.CurrentSeasonEnd,
		&i.ApiEnrichmentData,
		&i.LastApiUpdate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeagueByExternalID = `-- name: GetLeagueByExternalID :one
SELECT id, external_id, name, country, sport_id, is_active, slug, api_football_id, league_type, logo_url, country_code, country_flag_url, has_standings, has_fixtures, has_players, has_top_scorers, has_injuries, has_predictions, has_odds, current_season_year, current_season_start, current_season_end, api_enrichment_data, last_api_update, created_at, updated_at FROM leagues WHERE external_id = $1
`

func (q *Queries) GetLeagueByExternalID(ctx context.Context, externalID string) (League, error) {
	row := q.db.QueryRow(ctx, getLeagueByExternalID, externalID)
	var i League
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Country,
		&i.SportID,
		&i.IsActive,
		&i.Slug,
		&i.ApiFootballID,
		&i.LeagueType,
		&i.LogoUrl,
		&i.CountryCode,
		&i.CountryFlagUrl,
		&i.HasStandings,
		&i.HasFixtures,
		&i.HasPlayers,
		&i.HasTopScorers,
		&i.HasInjuries,
		&i.HasPredictions,
		&i.HasOdds,
		&i.CurrentSeasonYear,
		&i.CurrentSeasonStart,
		&i.CurrentSeasonEnd,
		&i.ApiEnrichmentData,
		&i.LastApiUpdate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeagueMapping = `-- name: GetLeagueMapping :one
SELECT id, internal_league_id, football_api_league_id, confidence, mapping_method, translated_league_name, translated_country, original_league_name, original_country, match_factors, needs_review, ai_translation_used, normalization_applied, match_score, created_at, updated_at FROM league_mappings 
WHERE internal_league_id = $1
`

func (q *Queries) GetLeagueMapping(ctx context.Context, internalLeagueID int32) (LeagueMapping, error) {
	row := q.db.QueryRow(ctx, getLeagueMapping, internalLeagueID)
	var i LeagueMapping
	err := row.Scan(
		&i.ID,
		&i.InternalLeagueID,
		&i.FootballApiLeagueID,
		&i.Confidence,
		&i.MappingMethod,
		&i.TranslatedLeagueName,
		&i.TranslatedCountry,
		&i.OriginalLeagueName,
		&i.OriginalCountry,
		&i.MatchFactors,
		&i.NeedsReview,
		&i.AiTranslationUsed,
		&i.NormalizationApplied,
		&i.MatchScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeaguesByAPIFootballID = `-- name: GetLeaguesByAPIFootballID :many
SELECT id, external_id, name, country, sport_id, is_active, slug, api_football_id, league_type, logo_url, country_code, country_flag_url, has_standings, has_fixtures, has_players, has_top_scorers, has_injuries, has_predictions, has_odds, current_season_year, current_season_start, current_season_end, api_enrichment_data, last_api_update, created_at, updated_at FROM leagues WHERE api_football_id = $1
`

func (q *Queries) GetLeaguesByAPIFootballID(ctx context.Context, apiFootballID *int32) ([]League, error) {
	rows, err := q.db.Query(ctx, getLeaguesByAPIFootballID, apiFootballID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []League{}
	for rows.Next() {
		var i League
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.SportID,
			&i.IsActive,
			&i.Slug,
			&i.ApiFootballID,
			&i.LeagueType,
			&i.LogoUrl,
			&i.CountryCode,
			&i.CountryFlagUrl,
			&i.HasStandings,
			&i.HasFixtures,
			&i.HasPlayers,
			&i.HasTopScorers,
			&i.HasInjuries,
			&i.HasPredictions,
			&i.HasOdds,
			&i.CurrentSeasonYear,
			&i.CurrentSeasonStart,
			&i.CurrentSeasonEnd,
			&i.ApiEnrichmentData,
			&i.LastApiUpdate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamMapping = `-- name: GetTeamMapping :one
SELECT id, internal_team_id, football_api_team_id, confidence, mapping_method, translated_team_name, translated_country, translated_league, original_team_name, original_country, original_league, match_factors, needs_review, ai_translation_used, normalization_applied, match_score, created_at, updated_at FROM team_mappings 
WHERE internal_team_id = $1
`

func (q *Queries) GetTeamMapping(ctx context.Context, internalTeamID int32) (TeamMapping, error) {
	row := q.db.QueryRow(ctx, getTeamMapping, internalTeamID)
	var i TeamMapping
	err := row.Scan(
		&i.ID,
		&i.InternalTeamID,
		&i.FootballApiTeamID,
		&i.Confidence,
		&i.MappingMethod,
		&i.TranslatedTeamName,
		&i.TranslatedCountry,
		&i.TranslatedLeague,
		&i.OriginalTeamName,
		&i.OriginalCountry,
		&i.OriginalLeague,
		&i.MatchFactors,
		&i.NeedsReview,
		&i.AiTranslationUsed,
		&i.NormalizationApplied,
		&i.MatchScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listLeagueMappings = `-- name: ListLeagueMappings :many
SELECT id, internal_league_id, football_api_league_id, confidence, mapping_method, translated_league_name, translated_country, original_league_name, original_country, match_factors, needs_review, ai_translation_used, normalization_applied, match_score, created_at, updated_at FROM league_mappings ORDER BY confidence DESC
`

func (q *Queries) ListLeagueMappings(ctx context.Context) ([]LeagueMapping, error) {
	rows, err := q.db.Query(ctx, listLeagueMappings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LeagueMapping{}
	for rows.Next() {
		var i LeagueMapping
		if err := rows.Scan(
			&i.ID,
			&i.InternalLeagueID,
			&i.FootballApiLeagueID,
			&i.Confidence,
			&i.MappingMethod,
			&i.TranslatedLeagueName,
			&i.TranslatedCountry,
			&i.OriginalLeagueName,
			&i.OriginalCountry,
			&i.MatchFactors,
			&i.NeedsReview,
			&i.AiTranslationUsed,
			&i.NormalizationApplied,
			&i.MatchScore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeagues = `-- name: ListLeagues :many
SELECT id, external_id, name, country, sport_id, is_active, slug, api_football_id, league_type, logo_url, country_code, country_flag_url, has_standings, has_fixtures, has_players, has_top_scorers, has_injuries, has_predictions, has_odds, current_season_year, current_season_start, current_season_end, api_enrichment_data, last_api_update, created_at, updated_at FROM leagues ORDER BY name
`

func (q *Queries) ListLeagues(ctx context.Context) ([]League, error) {
	rows, err := q.db.Query(ctx, listLeagues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []League{}
	for rows.Next() {
		var i League
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.SportID,
			&i.IsActive,
			&i.Slug,
			&i.ApiFootballID,
			&i.LeagueType,
			&i.LogoUrl,
			&i.CountryCode,
			&i.CountryFlagUrl,
			&i.HasStandings,
			&i.HasFixtures,
			&i.HasPlayers,
			&i.HasTopScorers,
			&i.HasInjuries,
			&i.HasPredictions,
			&i.HasOdds,
			&i.CurrentSeasonYear,
			&i.CurrentSeasonStart,
			&i.CurrentSeasonEnd,
			&i.ApiEnrichmentData,
			&i.LastApiUpdate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeaguesForAPIEnrichment = `-- name: ListLeaguesForAPIEnrichment :many
SELECT l.id, l.external_id, l.name, l.country, l.sport_id, l.is_active, l.slug, l.api_football_id, l.league_type, l.logo_url, l.country_code, l.country_flag_url, l.has_standings, l.has_fixtures, l.has_players, l.has_top_scorers, l.has_injuries, l.has_predictions, l.has_odds, l.current_season_year, l.current_season_start, l.current_season_end, l.api_enrichment_data, l.last_api_update, l.created_at, l.updated_at FROM leagues l
INNER JOIN league_mappings lm ON l.id = lm.internal_league_id
WHERE l.last_api_update IS NULL 
   OR l.last_api_update < NOW() - INTERVAL '7 days'
ORDER BY l.updated_at ASC
LIMIT $1
`

func (q *Queries) ListLeaguesForAPIEnrichment(ctx context.Context, limitCount int64) ([]League, error) {
	rows, err := q.db.Query(ctx, listLeaguesForAPIEnrichment, limitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []League{}
	for rows.Next() {
		var i League
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.SportID,
			&i.IsActive,
			&i.Slug,
			&i.ApiFootballID,
			&i.LeagueType,
			&i.LogoUrl,
			&i.CountryCode,
			&i.CountryFlagUrl,
			&i.HasStandings,
			&i.HasFixtures,
			&i.HasPlayers,
			&i.HasTopScorers,
			&i.HasInjuries,
			&i.HasPredictions,
			&i.HasOdds,
			&i.CurrentSeasonYear,
			&i.CurrentSeasonStart,
			&i.CurrentSeasonEnd,
			&i.ApiEnrichmentData,
			&i.LastApiUpdate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamMappings = `-- name: ListTeamMappings :many
SELECT id, internal_team_id, football_api_team_id, confidence, mapping_method, translated_team_name, translated_country, translated_league, original_team_name, original_country, original_league, match_factors, needs_review, ai_translation_used, normalization_applied, match_score, created_at, updated_at FROM team_mappings ORDER BY confidence DESC
`

func (q *Queries) ListTeamMappings(ctx context.Context) ([]TeamMapping, error) {
	rows, err := q.db.Query(ctx, listTeamMappings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TeamMapping{}
	for rows.Next() {
		var i TeamMapping
		if err := rows.Scan(
			&i.ID,
			&i.InternalTeamID,
			&i.FootballApiTeamID,
			&i.Confidence,
			&i.MappingMethod,
			&i.TranslatedTeamName,
			&i.TranslatedCountry,
			&i.TranslatedLeague,
			&i.OriginalTeamName,
			&i.OriginalCountry,
			&i.OriginalLeague,
			&i.MatchFactors,
			&i.NeedsReview,
			&i.AiTranslationUsed,
			&i.NormalizationApplied,
			&i.MatchScore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamsByLeague = `-- name: ListTeamsByLeague :many
SELECT t.id, t.external_id, t.name, t.country, t.logo_url, t.is_active, t.slug, t.api_football_id, t.team_code, t.founded_year, t.is_national_team, t.venue_id, t.venue_name, t.venue_address, t.venue_city, t.venue_capacity, t.venue_surface, t.venue_image_url, t.api_enrichment_data, t.last_api_update, t.created_at, t.updated_at FROM teams t
INNER JOIN events e ON (t.id = e.home_team_id OR t.id = e.away_team_id)
WHERE e.league_id = $1
GROUP BY t.id, t.external_id, t.name, t.country, t.logo_url, t.is_active, t.slug, t.created_at, t.updated_at
`

func (q *Queries) ListTeamsByLeague(ctx context.Context, leagueID *int32) ([]Team, error) {
	rows, err := q.db.Query(ctx, listTeamsByLeague, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.LogoUrl,
			&i.IsActive,
			&i.Slug,
			&i.ApiFootballID,
			&i.TeamCode,
			&i.FoundedYear,
			&i.IsNationalTeam,
			&i.VenueID,
			&i.VenueName,
			&i.VenueAddress,
			&i.VenueCity,
			&i.VenueCapacity,
			&i.VenueSurface,
			&i.VenueImageUrl,
			&i.ApiEnrichmentData,
			&i.LastApiUpdate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmappedFootballLeagues = `-- name: ListUnmappedFootballLeagues :many
SELECT l.id, l.external_id, l.name, l.country, l.sport_id, l.is_active, l.slug, l.api_football_id, l.league_type, l.logo_url, l.country_code, l.country_flag_url, l.has_standings, l.has_fixtures, l.has_players, l.has_top_scorers, l.has_injuries, l.has_predictions, l.has_odds, l.current_season_year, l.current_season_start, l.current_season_end, l.api_enrichment_data, l.last_api_update, l.created_at, l.updated_at FROM leagues l 
LEFT JOIN league_mappings lm ON l.id = lm.internal_league_id 
WHERE lm.id IS NULL AND l.sport_id = 1
`

func (q *Queries) ListUnmappedFootballLeagues(ctx context.Context) ([]League, error) {
	rows, err := q.db.Query(ctx, listUnmappedFootballLeagues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []League{}
	for rows.Next() {
		var i League
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.SportID,
			&i.IsActive,
			&i.Slug,
			&i.ApiFootballID,
			&i.LeagueType,
			&i.LogoUrl,
			&i.CountryCode,
			&i.CountryFlagUrl,
			&i.HasStandings,
			&i.HasFixtures,
			&i.HasPlayers,
			&i.HasTopScorers,
			&i.HasInjuries,
			&i.HasPredictions,
			&i.HasOdds,
			&i.CurrentSeasonYear,
			&i.CurrentSeasonStart,
			&i.CurrentSeasonEnd,
			&i.ApiEnrichmentData,
			&i.LastApiUpdate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmappedLeagues = `-- name: ListUnmappedLeagues :many
SELECT l.id, l.external_id, l.name, l.country, l.sport_id, l.is_active, l.slug, l.api_football_id, l.league_type, l.logo_url, l.country_code, l.country_flag_url, l.has_standings, l.has_fixtures, l.has_players, l.has_top_scorers, l.has_injuries, l.has_predictions, l.has_odds, l.current_season_year, l.current_season_start, l.current_season_end, l.api_enrichment_data, l.last_api_update, l.created_at, l.updated_at FROM leagues l 
LEFT JOIN league_mappings lm ON l.id = lm.internal_league_id 
WHERE lm.id IS NULL
`

func (q *Queries) ListUnmappedLeagues(ctx context.Context) ([]League, error) {
	rows, err := q.db.Query(ctx, listUnmappedLeagues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []League{}
	for rows.Next() {
		var i League
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.SportID,
			&i.IsActive,
			&i.Slug,
			&i.ApiFootballID,
			&i.LeagueType,
			&i.LogoUrl,
			&i.CountryCode,
			&i.CountryFlagUrl,
			&i.HasStandings,
			&i.HasFixtures,
			&i.HasPlayers,
			&i.HasTopScorers,
			&i.HasInjuries,
			&i.HasPredictions,
			&i.HasOdds,
			&i.CurrentSeasonYear,
			&i.CurrentSeasonStart,
			&i.CurrentSeasonEnd,
			&i.ApiEnrichmentData,
			&i.LastApiUpdate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLeague = `-- name: UpdateLeague :one
UPDATE leagues 
SET name = $1, country = $2, sport_id = $3, is_active = $4, updated_at = CURRENT_TIMESTAMP
WHERE id = $5
RETURNING id, external_id, name, country, sport_id, is_active, slug, api_football_id, league_type, logo_url, country_code, country_flag_url, has_standings, has_fixtures, has_players, has_top_scorers, has_injuries, has_predictions, has_odds, current_season_year, current_season_start, current_season_end, api_enrichment_data, last_api_update, created_at, updated_at
`

type UpdateLeagueParams struct {
	Name     string  `db:"name" json:"name"`
	Country  *string `db:"country" json:"country"`
	SportID  *int32  `db:"sport_id" json:"sport_id"`
	IsActive *bool   `db:"is_active" json:"is_active"`
	ID       int32   `db:"id" json:"id"`
}

func (q *Queries) UpdateLeague(ctx context.Context, arg UpdateLeagueParams) (League, error) {
	row := q.db.QueryRow(ctx, updateLeague,
		arg.Name,
		arg.Country,
		arg.SportID,
		arg.IsActive,
		arg.ID,
	)
	var i League
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Country,
		&i.SportID,
		&i.IsActive,
		&i.Slug,
		&i.ApiFootballID,
		&i.LeagueType,
		&i.LogoUrl,
		&i.CountryCode,
		&i.CountryFlagUrl,
		&i.HasStandings,
		&i.HasFixtures,
		&i.HasPlayers,
		&i.HasTopScorers,
		&i.HasInjuries,
		&i.HasPredictions,
		&i.HasOdds,
		&i.CurrentSeasonYear,
		&i.CurrentSeasonStart,
		&i.CurrentSeasonEnd,
		&i.ApiEnrichmentData,
		&i.LastApiUpdate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLeagueApiFootballID = `-- name: UpdateLeagueApiFootballID :exec
UPDATE leagues 
SET api_football_id = $1, updated_at = CURRENT_TIMESTAMP
WHERE id = $2
`

type UpdateLeagueApiFootballIDParams struct {
	ApiFootballID *int32 `db:"api_football_id" json:"api_football_id"`
	ID            int32  `db:"id" json:"id"`
}

func (q *Queries) UpdateLeagueApiFootballID(ctx context.Context, arg UpdateLeagueApiFootballIDParams) error {
	_, err := q.db.Exec(ctx, updateLeagueApiFootballID, arg.ApiFootballID, arg.ID)
	return err
}

const upsertLeague = `-- name: UpsertLeague :one
INSERT INTO leagues (external_id, name, country, sport_id, is_active)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (external_id) DO UPDATE SET
    name = EXCLUDED.name,
    country = EXCLUDED.country,
    sport_id = EXCLUDED.sport_id,
    is_active = EXCLUDED.is_active,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, external_id, name, country, sport_id, is_active, slug, api_football_id, league_type, logo_url, country_code, country_flag_url, has_standings, has_fixtures, has_players, has_top_scorers, has_injuries, has_predictions, has_odds, current_season_year, current_season_start, current_season_end, api_enrichment_data, last_api_update, created_at, updated_at
`

type UpsertLeagueParams struct {
	ExternalID string  `db:"external_id" json:"external_id"`
	Name       string  `db:"name" json:"name"`
	Country    *string `db:"country" json:"country"`
	SportID    *int32  `db:"sport_id" json:"sport_id"`
	IsActive   *bool   `db:"is_active" json:"is_active"`
}

func (q *Queries) UpsertLeague(ctx context.Context, arg UpsertLeagueParams) (League, error) {
	row := q.db.QueryRow(ctx, upsertLeague,
		arg.ExternalID,
		arg.Name,
		arg.Country,
		arg.SportID,
		arg.IsActive,
	)
	var i League
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Country,
		&i.SportID,
		&i.IsActive,
		&i.Slug,
		&i.ApiFootballID,
		&i.LeagueType,
		&i.LogoUrl,
		&i.CountryCode,
		&i.CountryFlagUrl,
		&i.HasStandings,
		&i.HasFixtures,
		&i.HasPlayers,
		&i.HasTopScorers,
		&i.HasInjuries,
		&i.HasPredictions,
		&i.HasOdds,
		&i.CurrentSeasonYear,
		&i.CurrentSeasonStart,
		&i.CurrentSeasonEnd,
		&i.ApiEnrichmentData,
		&i.LastApiUpdate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertLeagueMapping = `-- name: UpsertLeagueMapping :one
INSERT INTO league_mappings (
    internal_league_id, 
    football_api_league_id, 
    confidence, 
    mapping_method
) VALUES (
    $1, 
    $2, 
    $3, 
    $4
) 
ON CONFLICT (internal_league_id) 
DO UPDATE SET
    football_api_league_id = EXCLUDED.football_api_league_id,
    confidence = EXCLUDED.confidence,
    mapping_method = EXCLUDED.mapping_method,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, internal_league_id, football_api_league_id, confidence, mapping_method, translated_league_name, translated_country, original_league_name, original_country, match_factors, needs_review, ai_translation_used, normalization_applied, match_score, created_at, updated_at
`

type UpsertLeagueMappingParams struct {
	InternalLeagueID    int32   `db:"internal_league_id" json:"internal_league_id"`
	FootballApiLeagueID int32   `db:"football_api_league_id" json:"football_api_league_id"`
	Confidence          float32 `db:"confidence" json:"confidence"`
	MappingMethod       string  `db:"mapping_method" json:"mapping_method"`
}

func (q *Queries) UpsertLeagueMapping(ctx context.Context, arg UpsertLeagueMappingParams) (LeagueMapping, error) {
	row := q.db.QueryRow(ctx, upsertLeagueMapping,
		arg.InternalLeagueID,
		arg.FootballApiLeagueID,
		arg.Confidence,
		arg.MappingMethod,
	)
	var i LeagueMapping
	err := row.Scan(
		&i.ID,
		&i.InternalLeagueID,
		&i.FootballApiLeagueID,
		&i.Confidence,
		&i.MappingMethod,
		&i.TranslatedLeagueName,
		&i.TranslatedCountry,
		&i.OriginalLeagueName,
		&i.OriginalCountry,
		&i.MatchFactors,
		&i.NeedsReview,
		&i.AiTranslationUsed,
		&i.NormalizationApplied,
		&i.MatchScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
