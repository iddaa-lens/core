// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: market_types.sql

package generated

import (
	"context"
)

const bulkUpsertMarketTypes = `-- name: BulkUpsertMarketTypes :exec
WITH input_data AS (
    SELECT
        unnest($1::text[]) as code,
        unnest($2::text[]) as name,
        unnest($3::text[]) as slug,
        unnest($4::text[]) as description,
        unnest($5::int[]) as iddaa_market_id,
        unnest($6::boolean[]) as is_live,
        unnest($7::int[]) as market_type,
        unnest($8::int[]) as min_market_default_value,
        unnest($9::int[]) as max_market_limit_value,
        unnest($10::int[]) as priority,
        unnest($11::int[]) as sport_type,
        unnest($12::int[]) as market_sub_type,
        unnest($13::int[]) as min_default_value,
        unnest($14::int[]) as max_limit_value,
        unnest($15::boolean[]) as is_active
)
INSERT INTO
    market_types (
        code,
        name,
        slug,
        description,
        iddaa_market_id,
        is_live,
        market_type,
        min_market_default_value,
        max_market_limit_value,
        priority,
        sport_type,
        market_sub_type,
        min_default_value,
        max_limit_value,
        is_active,
        created_at,
        updated_at
    )
SELECT
    code,
    name,
    slug,
    NULLIF(description, ''),
    iddaa_market_id,
    is_live,
    market_type,
    min_market_default_value,
    max_market_limit_value,
    priority,
    sport_type,
    market_sub_type,
    min_default_value,
    max_limit_value,
    is_active,
    NOW(),
    NOW()
FROM input_data
ON CONFLICT (code) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    description = EXCLUDED.description,
    iddaa_market_id = EXCLUDED.iddaa_market_id,
    is_live = EXCLUDED.is_live,
    market_type = EXCLUDED.market_type,
    min_market_default_value = EXCLUDED.min_market_default_value,
    max_market_limit_value = EXCLUDED.max_market_limit_value,
    priority = EXCLUDED.priority,
    sport_type = EXCLUDED.sport_type,
    market_sub_type = EXCLUDED.market_sub_type,
    min_default_value = EXCLUDED.min_default_value,
    max_limit_value = EXCLUDED.max_limit_value,
    is_active = EXCLUDED.is_active,
    updated_at = CURRENT_TIMESTAMP
`

type BulkUpsertMarketTypesParams struct {
	Codes                  []string `db:"codes" json:"codes"`
	Names                  []string `db:"names" json:"names"`
	Slugs                  []string `db:"slugs" json:"slugs"`
	Descriptions           []string `db:"descriptions" json:"descriptions"`
	IddaaMarketIds         []int32  `db:"iddaa_market_ids" json:"iddaa_market_ids"`
	IsLives                []bool   `db:"is_lives" json:"is_lives"`
	MarketTypes            []int32  `db:"market_types" json:"market_types"`
	MinMarketDefaultValues []int32  `db:"min_market_default_values" json:"min_market_default_values"`
	MaxMarketLimitValues   []int32  `db:"max_market_limit_values" json:"max_market_limit_values"`
	Priorities             []int32  `db:"priorities" json:"priorities"`
	SportTypes             []int32  `db:"sport_types" json:"sport_types"`
	MarketSubTypes         []int32  `db:"market_sub_types" json:"market_sub_types"`
	MinDefaultValues       []int32  `db:"min_default_values" json:"min_default_values"`
	MaxLimitValues         []int32  `db:"max_limit_values" json:"max_limit_values"`
	IsActives              []bool   `db:"is_actives" json:"is_actives"`
}

func (q *Queries) BulkUpsertMarketTypes(ctx context.Context, arg BulkUpsertMarketTypesParams) error {
	_, err := q.db.Exec(ctx, bulkUpsertMarketTypes,
		arg.Codes,
		arg.Names,
		arg.Slugs,
		arg.Descriptions,
		arg.IddaaMarketIds,
		arg.IsLives,
		arg.MarketTypes,
		arg.MinMarketDefaultValues,
		arg.MaxMarketLimitValues,
		arg.Priorities,
		arg.SportTypes,
		arg.MarketSubTypes,
		arg.MinDefaultValues,
		arg.MaxLimitValues,
		arg.IsActives,
	)
	return err
}

const getMarketType = `-- name: GetMarketType :one
SELECT
    id, code, name, slug, description, iddaa_market_id, is_live, market_type, min_market_default_value, max_market_limit_value, priority, sport_type, market_sub_type, min_default_value, max_limit_value, is_active, created_at, updated_at
FROM
    market_types
WHERE
    code = $1
LIMIT
    1
`

func (q *Queries) GetMarketType(ctx context.Context, code string) (MarketType, error) {
	row := q.db.QueryRow(ctx, getMarketType, code)
	var i MarketType
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.IddaaMarketID,
		&i.IsLive,
		&i.MarketType,
		&i.MinMarketDefaultValue,
		&i.MaxMarketLimitValue,
		&i.Priority,
		&i.SportType,
		&i.MarketSubType,
		&i.MinDefaultValue,
		&i.MaxLimitValue,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMarketTypeByID = `-- name: GetMarketTypeByID :one
SELECT
    id, code, name, slug, description, iddaa_market_id, is_live, market_type, min_market_default_value, max_market_limit_value, priority, sport_type, market_sub_type, min_default_value, max_limit_value, is_active, created_at, updated_at
FROM
    market_types
WHERE
    id = $1
LIMIT
    1
`

func (q *Queries) GetMarketTypeByID(ctx context.Context, id int32) (MarketType, error) {
	row := q.db.QueryRow(ctx, getMarketTypeByID, id)
	var i MarketType
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.IddaaMarketID,
		&i.IsLive,
		&i.MarketType,
		&i.MinMarketDefaultValue,
		&i.MaxMarketLimitValue,
		&i.Priority,
		&i.SportType,
		&i.MarketSubType,
		&i.MinDefaultValue,
		&i.MaxLimitValue,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listMarketTypes = `-- name: ListMarketTypes :many
SELECT
    id, code, name, slug, description, iddaa_market_id, is_live, market_type, min_market_default_value, max_market_limit_value, priority, sport_type, market_sub_type, min_default_value, max_limit_value, is_active, created_at, updated_at
FROM
    market_types
ORDER BY
    code
`

func (q *Queries) ListMarketTypes(ctx context.Context) ([]MarketType, error) {
	rows, err := q.db.Query(ctx, listMarketTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MarketType{}
	for rows.Next() {
		var i MarketType
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.IddaaMarketID,
			&i.IsLive,
			&i.MarketType,
			&i.MinMarketDefaultValue,
			&i.MaxMarketLimitValue,
			&i.Priority,
			&i.SportType,
			&i.MarketSubType,
			&i.MinDefaultValue,
			&i.MaxLimitValue,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertMarketType = `-- name: UpsertMarketType :one
INSERT INTO
    market_types (
        code,
        name,
        slug,
        description,
        iddaa_market_id,
        is_live,
        market_type,
        min_market_default_value,
        max_market_limit_value,
        priority,
        sport_type,
        market_sub_type,
        min_default_value,
        max_limit_value,
        is_active
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        $14,
        $15
    ) ON CONFLICT (code) DO
UPDATE
SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    description = EXCLUDED.description,
    iddaa_market_id = EXCLUDED.iddaa_market_id,
    is_live = EXCLUDED.is_live,
    market_type = EXCLUDED.market_type,
    min_market_default_value = EXCLUDED.min_market_default_value,
    max_market_limit_value = EXCLUDED.max_market_limit_value,
    priority = EXCLUDED.priority,
    sport_type = EXCLUDED.sport_type,
    market_sub_type = EXCLUDED.market_sub_type,
    min_default_value = EXCLUDED.min_default_value,
    max_limit_value = EXCLUDED.max_limit_value,
    is_active = EXCLUDED.is_active,
    updated_at = CURRENT_TIMESTAMP RETURNING id, code, name, slug, description, iddaa_market_id, is_live, market_type, min_market_default_value, max_market_limit_value, priority, sport_type, market_sub_type, min_default_value, max_limit_value, is_active, created_at, updated_at
`

type UpsertMarketTypeParams struct {
	Code                  string  `db:"code" json:"code"`
	Name                  string  `db:"name" json:"name"`
	Slug                  string  `db:"slug" json:"slug"`
	Description           *string `db:"description" json:"description"`
	IddaaMarketID         *int32  `db:"iddaa_market_id" json:"iddaa_market_id"`
	IsLive                *bool   `db:"is_live" json:"is_live"`
	MarketType            *int32  `db:"market_type" json:"market_type"`
	MinMarketDefaultValue *int32  `db:"min_market_default_value" json:"min_market_default_value"`
	MaxMarketLimitValue   *int32  `db:"max_market_limit_value" json:"max_market_limit_value"`
	Priority              *int32  `db:"priority" json:"priority"`
	SportType             *int32  `db:"sport_type" json:"sport_type"`
	MarketSubType         *int32  `db:"market_sub_type" json:"market_sub_type"`
	MinDefaultValue       *int32  `db:"min_default_value" json:"min_default_value"`
	MaxLimitValue         *int32  `db:"max_limit_value" json:"max_limit_value"`
	IsActive              *bool   `db:"is_active" json:"is_active"`
}

func (q *Queries) UpsertMarketType(ctx context.Context, arg UpsertMarketTypeParams) (MarketType, error) {
	row := q.db.QueryRow(ctx, upsertMarketType,
		arg.Code,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.IddaaMarketID,
		arg.IsLive,
		arg.MarketType,
		arg.MinMarketDefaultValue,
		arg.MaxMarketLimitValue,
		arg.Priority,
		arg.SportType,
		arg.MarketSubType,
		arg.MinDefaultValue,
		arg.MaxLimitValue,
		arg.IsActive,
	)
	var i MarketType
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.IddaaMarketID,
		&i.IsLive,
		&i.MarketType,
		&i.MinMarketDefaultValue,
		&i.MaxMarketLimitValue,
		&i.Priority,
		&i.SportType,
		&i.MarketSubType,
		&i.MinDefaultValue,
		&i.MaxLimitValue,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertMarketTypeByExternalID = `-- name: UpsertMarketTypeByExternalID :one
INSERT INTO
    market_types (code, name, description)
VALUES
    (
        $1::text,
        $2,
        $3
    ) ON CONFLICT (code) DO
UPDATE
SET
    name = EXCLUDED.name,
    description = EXCLUDED.description,
    updated_at = CURRENT_TIMESTAMP RETURNING id, code, name, slug, description, iddaa_market_id, is_live, market_type, min_market_default_value, max_market_limit_value, priority, sport_type, market_sub_type, min_default_value, max_limit_value, is_active, created_at, updated_at
`

type UpsertMarketTypeByExternalIDParams struct {
	ExternalID  string  `db:"external_id" json:"external_id"`
	Name        string  `db:"name" json:"name"`
	Description *string `db:"description" json:"description"`
}

func (q *Queries) UpsertMarketTypeByExternalID(ctx context.Context, arg UpsertMarketTypeByExternalIDParams) (MarketType, error) {
	row := q.db.QueryRow(ctx, upsertMarketTypeByExternalID, arg.ExternalID, arg.Name, arg.Description)
	var i MarketType
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.IddaaMarketID,
		&i.IsLive,
		&i.MarketType,
		&i.MinMarketDefaultValue,
		&i.MaxMarketLimitValue,
		&i.Priority,
		&i.SportType,
		&i.MarketSubType,
		&i.MinDefaultValue,
		&i.MaxLimitValue,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
