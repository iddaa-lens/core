// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: distributions.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkInsertDistributionHistory = `-- name: BulkInsertDistributionHistory :execrows
WITH input_data AS (
  SELECT 
    unnest($1::text[]) as external_id,
    unnest($2::int4[]) as market_id,
    unnest($3::text[]) as outcome,
    unnest($4::float4[]) as bet_percentage,
    unnest($5::float4[]) as previous_percentage
)
INSERT INTO outcome_distribution_history (
  event_id,
  market_id,
  outcome,
  bet_percentage,
  previous_percentage
)
SELECT
  e.id,
  i.market_id,
  i.outcome,
  i.bet_percentage,
  i.previous_percentage
FROM input_data i
JOIN events e ON e.external_id = i.external_id
`

type BulkInsertDistributionHistoryParams struct {
	ExternalIds         []string  `db:"external_ids" json:"external_ids"`
	MarketIds           []int64   `db:"market_ids" json:"market_ids"`
	Outcomes            []string  `db:"outcomes" json:"outcomes"`
	BetPercentages      []float64 `db:"bet_percentages" json:"bet_percentages"`
	PreviousPercentages []float64 `db:"previous_percentages" json:"previous_percentages"`
}

// Bulk insert distribution history for changed values
func (q *Queries) BulkInsertDistributionHistory(ctx context.Context, arg BulkInsertDistributionHistoryParams) (int64, error) {
	result, err := q.db.Exec(ctx, bulkInsertDistributionHistory,
		arg.ExternalIds,
		arg.MarketIds,
		arg.Outcomes,
		arg.BetPercentages,
		arg.PreviousPercentages,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const bulkUpsertDistributions = `-- name: BulkUpsertDistributions :execrows
WITH input_data AS (
  SELECT 
    unnest($1::text[]) as external_id,
    unnest($2::int4[]) as market_id,
    unnest($3::text[]) as outcome,
    unnest($4::float4[]) as bet_percentage,
    unnest($5::float8[]) as implied_probability
)
INSERT INTO outcome_distributions (
  event_id,
  market_id,
  outcome,
  bet_percentage,
  implied_probability
)
SELECT 
  e.id,
  i.market_id,
  i.outcome,
  i.bet_percentage,
  i.implied_probability
FROM input_data i
JOIN events e ON e.external_id = i.external_id
ON CONFLICT (event_id, market_id, outcome) DO UPDATE
SET 
  bet_percentage = EXCLUDED.bet_percentage,
  implied_probability = EXCLUDED.implied_probability,
  last_updated = CURRENT_TIMESTAMP
`

type BulkUpsertDistributionsParams struct {
	ExternalIds          []string  `db:"external_ids" json:"external_ids"`
	MarketIds            []int64   `db:"market_ids" json:"market_ids"`
	Outcomes             []string  `db:"outcomes" json:"outcomes"`
	BetPercentages       []float64 `db:"bet_percentages" json:"bet_percentages"`
	ImpliedProbabilities []float64 `db:"implied_probabilities" json:"implied_probabilities"`
}

// Bulk upsert distributions with database-side calculations
func (q *Queries) BulkUpsertDistributions(ctx context.Context, arg BulkUpsertDistributionsParams) (int64, error) {
	result, err := q.db.Exec(ctx, bulkUpsertDistributions,
		arg.ExternalIds,
		arg.MarketIds,
		arg.Outcomes,
		arg.BetPercentages,
		arg.ImpliedProbabilities,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createDistributionHistory = `-- name: CreateDistributionHistory :one
INSERT INTO
  outcome_distribution_history (
    event_id,
    market_id,
    outcome,
    bet_percentage,
    previous_percentage
  )
VALUES
  (
    $1,
    $2,
    $3,
    $4,
    $5
  ) RETURNING id, event_id, market_id, outcome, bet_percentage, previous_percentage, change_amount, recorded_at
`

type CreateDistributionHistoryParams struct {
	EventID            *int32   `db:"event_id" json:"event_id"`
	MarketID           int32    `db:"market_id" json:"market_id"`
	Outcome            string   `db:"outcome" json:"outcome"`
	BetPercentage      float32  `db:"bet_percentage" json:"bet_percentage"`
	PreviousPercentage *float32 `db:"previous_percentage" json:"previous_percentage"`
}

func (q *Queries) CreateDistributionHistory(ctx context.Context, arg CreateDistributionHistoryParams) (OutcomeDistributionHistory, error) {
	row := q.db.QueryRow(ctx, createDistributionHistory,
		arg.EventID,
		arg.MarketID,
		arg.Outcome,
		arg.BetPercentage,
		arg.PreviousPercentage,
	)
	var i OutcomeDistributionHistory
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.MarketID,
		&i.Outcome,
		&i.BetPercentage,
		&i.PreviousPercentage,
		&i.ChangeAmount,
		&i.RecordedAt,
	)
	return i, err
}

const getAllDistributionsForEvents = `-- name: GetAllDistributionsForEvents :many
SELECT 
  od.id, od.event_id, od.market_id, od.market_type_id, od.outcome, od.bet_percentage, od.implied_probability, od.value_indicator, od.last_updated,
  e.external_id as event_external_id
FROM outcome_distributions od
JOIN events e ON e.id = od.event_id
WHERE e.external_id = ANY($1::text[])
`

type GetAllDistributionsForEventsRow struct {
	ID                 int32            `db:"id" json:"id"`
	EventID            *int32           `db:"event_id" json:"event_id"`
	MarketID           int32            `db:"market_id" json:"market_id"`
	MarketTypeID       *int32           `db:"market_type_id" json:"market_type_id"`
	Outcome            string           `db:"outcome" json:"outcome"`
	BetPercentage      float32          `db:"bet_percentage" json:"bet_percentage"`
	ImpliedProbability *float32         `db:"implied_probability" json:"implied_probability"`
	ValueIndicator     *float32         `db:"value_indicator" json:"value_indicator"`
	LastUpdated        pgtype.Timestamp `db:"last_updated" json:"last_updated"`
	EventExternalID    string           `db:"event_external_id" json:"event_external_id"`
}

// Bulk fetch all distributions for multiple events
func (q *Queries) GetAllDistributionsForEvents(ctx context.Context, externalIds []string) ([]GetAllDistributionsForEventsRow, error) {
	rows, err := q.db.Query(ctx, getAllDistributionsForEvents, externalIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllDistributionsForEventsRow{}
	for rows.Next() {
		var i GetAllDistributionsForEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.BetPercentage,
			&i.ImpliedProbability,
			&i.ValueIndicator,
			&i.LastUpdated,
			&i.EventExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentOddsForEvents = `-- name: GetCurrentOddsForEvents :many
SELECT 
  co.event_id,
  co.outcome,
  co.odds_value,
  e.external_id
FROM current_odds co
JOIN events e ON e.id = co.event_id
WHERE e.external_id = ANY($1::text[])
  AND co.market_type_id = 1
`

type GetCurrentOddsForEventsRow struct {
	EventID    *int32  `db:"event_id" json:"event_id"`
	Outcome    string  `db:"outcome" json:"outcome"`
	OddsValue  float64 `db:"odds_value" json:"odds_value"`
	ExternalID string  `db:"external_id" json:"external_id"`
}

// Bulk fetch current odds for implied probability calculation
func (q *Queries) GetCurrentOddsForEvents(ctx context.Context, externalIds []string) ([]GetCurrentOddsForEventsRow, error) {
	rows, err := q.db.Query(ctx, getCurrentOddsForEvents, externalIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCurrentOddsForEventsRow{}
	for rows.Next() {
		var i GetCurrentOddsForEventsRow
		if err := rows.Scan(
			&i.EventID,
			&i.Outcome,
			&i.OddsValue,
			&i.ExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentOddsForOutcome = `-- name: GetCurrentOddsForOutcome :many
SELECT
  co.id, co.event_id, co.market_type_id, co.outcome, co.odds_value, co.opening_value, co.highest_value, co.lowest_value, co.winning_odds, co.total_movement, co.movement_percentage, co.last_updated, co.market_params
FROM
  current_odds co
WHERE
  co.event_id = $1
  AND co.outcome = $2
`

type GetCurrentOddsForOutcomeParams struct {
	EventID *int32 `db:"event_id" json:"event_id"`
	Outcome string `db:"outcome" json:"outcome"`
}

func (q *Queries) GetCurrentOddsForOutcome(ctx context.Context, arg GetCurrentOddsForOutcomeParams) ([]CurrentOdd, error) {
	rows, err := q.db.Query(ctx, getCurrentOddsForOutcome, arg.EventID, arg.Outcome)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CurrentOdd{}
	for rows.Next() {
		var i CurrentOdd
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.OpeningValue,
			&i.HighestValue,
			&i.LowestValue,
			&i.WinningOdds,
			&i.TotalMovement,
			&i.MovementPercentage,
			&i.LastUpdated,
			&i.MarketParams,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByExternalIDs = `-- name: GetEventsByExternalIDs :many
SELECT id, external_id
FROM events
WHERE external_id = ANY($1::text[])
`

type GetEventsByExternalIDsRow struct {
	ID         int32  `db:"id" json:"id"`
	ExternalID string `db:"external_id" json:"external_id"`
}

// Bulk fetch events by external IDs
func (q *Queries) GetEventsByExternalIDs(ctx context.Context, externalIds []string) ([]GetEventsByExternalIDsRow, error) {
	rows, err := q.db.Query(ctx, getEventsByExternalIDs, externalIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsByExternalIDsRow{}
	for rows.Next() {
		var i GetEventsByExternalIDsRow
		if err := rows.Scan(&i.ID, &i.ExternalID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestOutcomeDistribution = `-- name: GetLatestOutcomeDistribution :one
SELECT
  id, event_id, market_id, market_type_id, outcome, bet_percentage, implied_probability, value_indicator, last_updated
FROM
  outcome_distributions
WHERE
  event_id = $1
  AND market_id = $2
  AND outcome = $3
ORDER BY
  last_updated DESC
LIMIT
  1
`

type GetLatestOutcomeDistributionParams struct {
	EventID  *int32 `db:"event_id" json:"event_id"`
	MarketID int32  `db:"market_id" json:"market_id"`
	Outcome  string `db:"outcome" json:"outcome"`
}

func (q *Queries) GetLatestOutcomeDistribution(ctx context.Context, arg GetLatestOutcomeDistributionParams) (OutcomeDistribution, error) {
	row := q.db.QueryRow(ctx, getLatestOutcomeDistribution, arg.EventID, arg.MarketID, arg.Outcome)
	var i OutcomeDistribution
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.MarketID,
		&i.MarketTypeID,
		&i.Outcome,
		&i.BetPercentage,
		&i.ImpliedProbability,
		&i.ValueIndicator,
		&i.LastUpdated,
	)
	return i, err
}

const getOutcomeDistribution = `-- name: GetOutcomeDistribution :one
SELECT
  id, event_id, market_id, market_type_id, outcome, bet_percentage, implied_probability, value_indicator, last_updated
FROM
  outcome_distributions
WHERE
  event_id = $1
  AND market_id = $2
  AND outcome = $3
`

type GetOutcomeDistributionParams struct {
	EventID  *int32 `db:"event_id" json:"event_id"`
	MarketID int32  `db:"market_id" json:"market_id"`
	Outcome  string `db:"outcome" json:"outcome"`
}

func (q *Queries) GetOutcomeDistribution(ctx context.Context, arg GetOutcomeDistributionParams) (OutcomeDistribution, error) {
	row := q.db.QueryRow(ctx, getOutcomeDistribution, arg.EventID, arg.MarketID, arg.Outcome)
	var i OutcomeDistribution
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.MarketID,
		&i.MarketTypeID,
		&i.Outcome,
		&i.BetPercentage,
		&i.ImpliedProbability,
		&i.ValueIndicator,
		&i.LastUpdated,
	)
	return i, err
}

const refreshBigMovers = `-- name: RefreshBigMovers :exec
REFRESH MATERIALIZED VIEW big_movers
`

func (q *Queries) RefreshBigMovers(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshBigMovers)
	return err
}

const refreshContrarianBets = `-- name: RefreshContrarianBets :exec
REFRESH MATERIALIZED VIEW contrarian_bets
`

func (q *Queries) RefreshContrarianBets(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshContrarianBets)
	return err
}

const refreshHighVolumeEvents = `-- name: RefreshHighVolumeEvents :exec
REFRESH MATERIALIZED VIEW high_volume_events
`

func (q *Queries) RefreshHighVolumeEvents(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshHighVolumeEvents)
	return err
}

const refreshLiveOpportunities = `-- name: RefreshLiveOpportunities :exec
REFRESH MATERIALIZED VIEW live_opportunities
`

func (q *Queries) RefreshLiveOpportunities(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshLiveOpportunities)
	return err
}

const refreshSharpMoneyMoves = `-- name: RefreshSharpMoneyMoves :exec
REFRESH MATERIALIZED VIEW sharp_money_moves
`

func (q *Queries) RefreshSharpMoneyMoves(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshSharpMoneyMoves)
	return err
}

const refreshValueSpots = `-- name: RefreshValueSpots :exec
REFRESH MATERIALIZED VIEW value_spots
`

func (q *Queries) RefreshValueSpots(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshValueSpots)
	return err
}

const upsertOutcomeDistribution = `-- name: UpsertOutcomeDistribution :one
INSERT INTO
  outcome_distributions (
    event_id,
    market_id,
    outcome,
    bet_percentage,
    implied_probability
  )
VALUES
  (
    $1,
    $2,
    $3,
    $4,
    $5::float8
  ) ON CONFLICT (event_id, market_id, outcome) DO
UPDATE
SET
  bet_percentage = EXCLUDED.bet_percentage,
  implied_probability = EXCLUDED.implied_probability,
  last_updated = CURRENT_TIMESTAMP RETURNING id, event_id, market_id, market_type_id, outcome, bet_percentage, implied_probability, value_indicator, last_updated
`

type UpsertOutcomeDistributionParams struct {
	EventID            *int32  `db:"event_id" json:"event_id"`
	MarketID           int32   `db:"market_id" json:"market_id"`
	Outcome            string  `db:"outcome" json:"outcome"`
	BetPercentage      float32 `db:"bet_percentage" json:"bet_percentage"`
	ImpliedProbability float64 `db:"implied_probability" json:"implied_probability"`
}

func (q *Queries) UpsertOutcomeDistribution(ctx context.Context, arg UpsertOutcomeDistributionParams) (OutcomeDistribution, error) {
	row := q.db.QueryRow(ctx, upsertOutcomeDistribution,
		arg.EventID,
		arg.MarketID,
		arg.Outcome,
		arg.BetPercentage,
		arg.ImpliedProbability,
	)
	var i OutcomeDistribution
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.MarketID,
		&i.MarketTypeID,
		&i.Outcome,
		&i.BetPercentage,
		&i.ImpliedProbability,
		&i.ValueIndicator,
		&i.LastUpdated,
	)
	return i, err
}
