// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: volume.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const analyzeVolumeOddsPattern = `-- name: AnalyzeVolumeOddsPattern :one
WITH patterns AS (
    SELECT
        CASE
            WHEN e.betting_volume_percentage > 5
            AND MAX(ABS(co.movement_percentage)) > 30 THEN 'HIGH_VOLUME_HIGH_MOVEMENT'
            WHEN e.betting_volume_percentage > 5
            AND MAX(ABS(co.movement_percentage)) < 10 THEN 'HIGH_VOLUME_STABLE'
            WHEN e.betting_volume_percentage < 1
            AND MAX(ABS(co.movement_percentage)) > 30 THEN 'LOW_VOLUME_HIGH_MOVEMENT'
            WHEN e.betting_volume_percentage < 1
            AND MAX(ABS(co.movement_percentage)) < 10 THEN 'LOW_VOLUME_STABLE'
            ELSE 'MODERATE'
        END as pattern,
        COUNT(*) as event_count,
        AVG(e.betting_volume_percentage) as avg_volume,
        AVG(MAX(ABS(co.movement_percentage))) as avg_movement
    FROM
        events e
        LEFT JOIN current_odds co ON co.event_id = e.id
    WHERE
        e.volume_updated_at > CURRENT_TIMESTAMP - INTERVAL '24 hours'
    GROUP BY
        e.id,
        e.betting_volume_percentage
)
SELECT
    json_object_agg(
        pattern,
        json_build_object(
            'count',
            event_count,
            'avg_volume',
            ROUND(avg_volume :: NUMERIC, 2),
            'avg_movement',
            ROUND(avg_movement :: NUMERIC, 2)
        )
    ) as analysis
FROM
    (
        SELECT
            pattern,
            SUM(event_count) as event_count,
            AVG(avg_volume) as avg_volume,
            AVG(avg_movement) as avg_movement
        FROM
            patterns
        GROUP BY
            pattern
    ) summary
`

// Analyze correlation between volume and odds movement
func (q *Queries) AnalyzeVolumeOddsPattern(ctx context.Context) ([]byte, error) {
	row := q.db.QueryRow(ctx, analyzeVolumeOddsPattern)
	var analysis []byte
	err := row.Scan(&analysis)
	return analysis, err
}

const bulkInsertVolumeHistory = `-- name: BulkInsertVolumeHistory :execrows
INSERT INTO
    betting_volume_history (
        event_id,
        volume_percentage,
        rank_position,
        total_events_tracked
    )
SELECT
    e.id,
    vd.percentage,
    vd.rank,
    $1 :: int4
FROM
    (
        SELECT
            external_id,
            percentage,
            ROW_NUMBER() OVER (
                ORDER BY
                    percentage DESC
            ) as rank
        FROM
            (
                SELECT
                    unnest($2 :: text []) as external_id,
                    unnest($3 :: float8 []) as percentage
            ) t
    ) vd
    JOIN events e ON e.external_id = vd.external_id
`

type BulkInsertVolumeHistoryParams struct {
	TotalEvents int64     `db:"total_events" json:"total_events"`
	ExternalIds []string  `db:"external_ids" json:"external_ids"`
	Percentages []float64 `db:"percentages" json:"percentages"`
}

// Bulk insert volume history records
func (q *Queries) BulkInsertVolumeHistory(ctx context.Context, arg BulkInsertVolumeHistoryParams) (int64, error) {
	result, err := q.db.Exec(ctx, bulkInsertVolumeHistory, arg.TotalEvents, arg.ExternalIds, arg.Percentages)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const bulkUpdateEventVolumes = `-- name: BulkUpdateEventVolumes :execrows
WITH volume_data AS (
    SELECT
        unnest($1 :: text []) as external_id,
        unnest($2 :: float8 []) as percentage
),
ranked_volumes AS (
    SELECT
        external_id,
        percentage,
        ROW_NUMBER() OVER (
            ORDER BY
                percentage DESC
        ) as rank
    FROM
        volume_data
)
UPDATE
    events e
SET
    betting_volume_percentage = rv.percentage,
    volume_rank = rv.rank,
    volume_updated_at = NOW()
FROM
    ranked_volumes rv
WHERE
    e.external_id = rv.external_id
`

type BulkUpdateEventVolumesParams struct {
	ExternalIds []string  `db:"external_ids" json:"external_ids"`
	Percentages []float64 `db:"percentages" json:"percentages"`
}

// Bulk update event volumes with database-calculated ranks
func (q *Queries) BulkUpdateEventVolumes(ctx context.Context, arg BulkUpdateEventVolumesParams) (int64, error) {
	result, err := q.db.Exec(ctx, bulkUpdateEventVolumes, arg.ExternalIds, arg.Percentages)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createVolumeHistory = `-- name: CreateVolumeHistory :one
INSERT INTO
    betting_volume_history (
        event_id,
        volume_percentage,
        rank_position,
        total_events_tracked
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4
    ) RETURNING id, event_id, volume_percentage, rank_position, total_events_tracked, recorded_at
`

type CreateVolumeHistoryParams struct {
	EventID            *int32  `db:"event_id" json:"event_id"`
	VolumePercentage   float32 `db:"volume_percentage" json:"volume_percentage"`
	RankPosition       *int32  `db:"rank_position" json:"rank_position"`
	TotalEventsTracked *int32  `db:"total_events_tracked" json:"total_events_tracked"`
}

func (q *Queries) CreateVolumeHistory(ctx context.Context, arg CreateVolumeHistoryParams) (BettingVolumeHistory, error) {
	row := q.db.QueryRow(ctx, createVolumeHistory,
		arg.EventID,
		arg.VolumePercentage,
		arg.RankPosition,
		arg.TotalEventsTracked,
	)
	var i BettingVolumeHistory
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.VolumePercentage,
		&i.RankPosition,
		&i.TotalEventsTracked,
		&i.RecordedAt,
	)
	return i, err
}

const getEventIDsByExternalIDs = `-- name: GetEventIDsByExternalIDs :many
SELECT
    id,
    external_id
FROM
    events
WHERE
    external_id = ANY($1 :: text [])
`

type GetEventIDsByExternalIDsRow struct {
	ID         int32  `db:"id" json:"id"`
	ExternalID string `db:"external_id" json:"external_id"`
}

// Map external IDs to internal IDs
func (q *Queries) GetEventIDsByExternalIDs(ctx context.Context, externalIds []string) ([]GetEventIDsByExternalIDsRow, error) {
	rows, err := q.db.Query(ctx, getEventIDsByExternalIDs, externalIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventIDsByExternalIDsRow{}
	for rows.Next() {
		var i GetEventIDsByExternalIDsRow
		if err := rows.Scan(&i.ID, &i.ExternalID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHiddenGems = `-- name: GetHiddenGems :many
SELECT
    e.slug,
    ht.name || ' vs ' || at.name as match_name,
    e.betting_volume_percentage,
    COALESCE(MAX(ABS(co.movement_percentage)), 0) as max_movement
FROM
    events e
    JOIN teams ht ON e.home_team_id = ht.id
    JOIN teams at ON e.away_team_id = at.id
    LEFT JOIN current_odds co ON co.event_id = e.id
WHERE
    e.betting_volume_percentage <= $1 :: float8
    AND e.betting_volume_percentage > 0
    AND e.event_date > CURRENT_TIMESTAMP
GROUP BY
    e.id,
    e.slug,
    ht.name,
    at.name,
    e.betting_volume_percentage
HAVING
    COALESCE(MAX(ABS(co.movement_percentage)), 0) >= $2 :: float8
ORDER BY
    MAX(ABS(co.movement_percentage)) DESC
LIMIT
    20
`

type GetHiddenGemsParams struct {
	MaxVolume   float64 `db:"max_volume" json:"max_volume"`
	MinMovement float64 `db:"min_movement" json:"min_movement"`
}

type GetHiddenGemsRow struct {
	Slug                    string      `db:"slug" json:"slug"`
	MatchName               interface{} `db:"match_name" json:"match_name"`
	BettingVolumePercentage *float32    `db:"betting_volume_percentage" json:"betting_volume_percentage"`
	MaxMovement             interface{} `db:"max_movement" json:"max_movement"`
}

// Find low-volume events with big movements (potential sharp money)
func (q *Queries) GetHiddenGems(ctx context.Context, arg GetHiddenGemsParams) ([]GetHiddenGemsRow, error) {
	rows, err := q.db.Query(ctx, getHiddenGems, arg.MaxVolume, arg.MinMovement)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHiddenGemsRow{}
	for rows.Next() {
		var i GetHiddenGemsRow
		if err := rows.Scan(
			&i.Slug,
			&i.MatchName,
			&i.BettingVolumePercentage,
			&i.MaxMovement,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHotMovers = `-- name: GetHotMovers :many
SELECT
    e.slug,
    ht.name || ' vs ' || at.name as match_name,
    e.betting_volume_percentage,
    e.volume_rank,
    COALESCE(MAX(ABS(co.movement_percentage)), 0) as max_movement,
    CASE
        WHEN e.betting_volume_percentage > 5 THEN 'HOT'
        WHEN e.betting_volume_percentage > 2 THEN 'POPULAR'
        WHEN e.betting_volume_percentage > 1 THEN 'MODERATE'
        ELSE 'COLD'
    END as popularity_level,
    CASE
        WHEN e.betting_volume_percentage > 5
        AND MAX(ABS(co.movement_percentage)) > 50 THEN 'HOT_MOVER'
        WHEN e.betting_volume_percentage < 1
        AND MAX(ABS(co.movement_percentage)) > 50 THEN 'HIDDEN_GEM'
        WHEN e.betting_volume_percentage > 5
        AND MAX(ABS(co.movement_percentage)) < 10 THEN 'STABLE_FAVORITE'
        ELSE 'NORMAL'
    END as event_type
FROM
    events e
    JOIN teams ht ON e.home_team_id = ht.id
    JOIN teams at ON e.away_team_id = at.id
    LEFT JOIN current_odds co ON co.event_id = e.id
WHERE
    e.betting_volume_percentage >= $1 :: float8
    AND e.event_date > CURRENT_TIMESTAMP
GROUP BY
    e.id,
    e.slug,
    ht.name,
    at.name,
    e.betting_volume_percentage,
    e.volume_rank
HAVING
    COALESCE(MAX(ABS(co.movement_percentage)), 0) >= $2 :: float8
ORDER BY
    e.betting_volume_percentage DESC
LIMIT
    50
`

type GetHotMoversParams struct {
	MinVolume   float64 `db:"min_volume" json:"min_volume"`
	MinMovement float64 `db:"min_movement" json:"min_movement"`
}

type GetHotMoversRow struct {
	Slug                    string      `db:"slug" json:"slug"`
	MatchName               interface{} `db:"match_name" json:"match_name"`
	BettingVolumePercentage *float32    `db:"betting_volume_percentage" json:"betting_volume_percentage"`
	VolumeRank              *int32      `db:"volume_rank" json:"volume_rank"`
	MaxMovement             interface{} `db:"max_movement" json:"max_movement"`
	PopularityLevel         string      `db:"popularity_level" json:"popularity_level"`
	EventType               string      `db:"event_type" json:"event_type"`
}

// Find events with high betting volume AND significant odds movement
func (q *Queries) GetHotMovers(ctx context.Context, arg GetHotMoversParams) ([]GetHotMoversRow, error) {
	rows, err := q.db.Query(ctx, getHotMovers, arg.MinVolume, arg.MinMovement)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHotMoversRow{}
	for rows.Next() {
		var i GetHotMoversRow
		if err := rows.Scan(
			&i.Slug,
			&i.MatchName,
			&i.BettingVolumePercentage,
			&i.VolumeRank,
			&i.MaxMovement,
			&i.PopularityLevel,
			&i.EventType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopVolumeEvents = `-- name: GetTopVolumeEvents :many
SELECT
    e.slug,
    ht.name || ' vs ' || at.name as match_name,
    e.event_date,
    e.betting_volume_percentage,
    e.volume_rank,
    COUNT(DISTINCT oh.id) as total_odds_changes,
    COALESCE(MAX(ABS(co.movement_percentage)), 0) as max_movement
FROM
    events e
    JOIN teams ht ON e.home_team_id = ht.id
    JOIN teams at ON e.away_team_id = at.id
    LEFT JOIN current_odds co ON co.event_id = e.id
    LEFT JOIN odds_history oh ON oh.event_id = e.id
WHERE
    e.volume_rank <= 20
    AND e.event_date > CURRENT_TIMESTAMP
GROUP BY
    e.id,
    e.slug,
    ht.name,
    at.name,
    e.event_date,
    e.betting_volume_percentage,
    e.volume_rank
ORDER BY
    e.volume_rank
`

type GetTopVolumeEventsRow struct {
	Slug                    string           `db:"slug" json:"slug"`
	MatchName               interface{}      `db:"match_name" json:"match_name"`
	EventDate               pgtype.Timestamp `db:"event_date" json:"event_date"`
	BettingVolumePercentage *float32         `db:"betting_volume_percentage" json:"betting_volume_percentage"`
	VolumeRank              *int32           `db:"volume_rank" json:"volume_rank"`
	TotalOddsChanges        int64            `db:"total_odds_changes" json:"total_odds_changes"`
	MaxMovement             interface{}      `db:"max_movement" json:"max_movement"`
}

// Get current top events by betting volume
func (q *Queries) GetTopVolumeEvents(ctx context.Context) ([]GetTopVolumeEventsRow, error) {
	rows, err := q.db.Query(ctx, getTopVolumeEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopVolumeEventsRow{}
	for rows.Next() {
		var i GetTopVolumeEventsRow
		if err := rows.Scan(
			&i.Slug,
			&i.MatchName,
			&i.EventDate,
			&i.BettingVolumePercentage,
			&i.VolumeRank,
			&i.TotalOddsChanges,
			&i.MaxMovement,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVolumeHistory = `-- name: GetVolumeHistory :many
SELECT
    bvh.id, bvh.event_id, bvh.volume_percentage, bvh.rank_position, bvh.total_events_tracked, bvh.recorded_at,
    LAG(bvh.volume_percentage) OVER (
        ORDER BY
            bvh.recorded_at
    ) as previous_volume,
    bvh.volume_percentage - LAG(bvh.volume_percentage) OVER (
        ORDER BY
            bvh.recorded_at
    ) as volume_change
FROM
    betting_volume_history bvh
WHERE
    bvh.event_id = $1
ORDER BY
    bvh.recorded_at DESC
LIMIT
    100
`

type GetVolumeHistoryRow struct {
	ID                 int32            `db:"id" json:"id"`
	EventID            *int32           `db:"event_id" json:"event_id"`
	VolumePercentage   float32          `db:"volume_percentage" json:"volume_percentage"`
	RankPosition       *int32           `db:"rank_position" json:"rank_position"`
	TotalEventsTracked *int32           `db:"total_events_tracked" json:"total_events_tracked"`
	RecordedAt         pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	PreviousVolume     interface{}      `db:"previous_volume" json:"previous_volume"`
	VolumeChange       int32            `db:"volume_change" json:"volume_change"`
}

// Get volume history for a specific event
func (q *Queries) GetVolumeHistory(ctx context.Context, eventID *int32) ([]GetVolumeHistoryRow, error) {
	rows, err := q.db.Query(ctx, getVolumeHistory, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVolumeHistoryRow{}
	for rows.Next() {
		var i GetVolumeHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.VolumePercentage,
			&i.RankPosition,
			&i.TotalEventsTracked,
			&i.RecordedAt,
			&i.PreviousVolume,
			&i.VolumeChange,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEventVolume = `-- name: UpdateEventVolume :one
UPDATE
    events
SET
    betting_volume_percentage = $1 :: float8,
    volume_rank = $2 :: float8,
    volume_updated_at = $3
WHERE
    id = $4 RETURNING id, external_id, league_id, home_team_id, away_team_id, slug, event_date, status, home_score, away_score, is_live, minute_of_match, half, betting_volume_percentage, volume_rank, volume_updated_at, bulletin_id, version, sport_id, bet_program, mbc, has_king_odd, odds_count, has_combine, created_at, updated_at
`

type UpdateEventVolumeParams struct {
	BettingVolumePercentage float64          `db:"betting_volume_percentage" json:"betting_volume_percentage"`
	VolumeRank              float64          `db:"volume_rank" json:"volume_rank"`
	VolumeUpdatedAt         pgtype.Timestamp `db:"volume_updated_at" json:"volume_updated_at"`
	ID                      int32            `db:"id" json:"id"`
}

func (q *Queries) UpdateEventVolume(ctx context.Context, arg UpdateEventVolumeParams) (Event, error) {
	row := q.db.QueryRow(ctx, updateEventVolume,
		arg.BettingVolumePercentage,
		arg.VolumeRank,
		arg.VolumeUpdatedAt,
		arg.ID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.LeagueID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.Slug,
		&i.EventDate,
		&i.Status,
		&i.HomeScore,
		&i.AwayScore,
		&i.IsLive,
		&i.MinuteOfMatch,
		&i.Half,
		&i.BettingVolumePercentage,
		&i.VolumeRank,
		&i.VolumeUpdatedAt,
		&i.BulletinID,
		&i.Version,
		&i.SportID,
		&i.BetProgram,
		&i.Mbc,
		&i.HasKingOdd,
		&i.OddsCount,
		&i.HasCombine,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
