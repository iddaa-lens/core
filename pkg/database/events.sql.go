// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: events.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (external_id, league_id, home_team_id, away_team_id, event_date, status)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, external_id, league_id, home_team_id, away_team_id, slug, event_date, status, home_score, away_score, is_live, minute_of_match, half, betting_volume_percentage, volume_rank, volume_updated_at, created_at, updated_at
`

type CreateEventParams struct {
	ExternalID string           `db:"external_id" json:"external_id"`
	LeagueID   pgtype.Int4      `db:"league_id" json:"league_id"`
	HomeTeamID pgtype.Int4      `db:"home_team_id" json:"home_team_id"`
	AwayTeamID pgtype.Int4      `db:"away_team_id" json:"away_team_id"`
	EventDate  pgtype.Timestamp `db:"event_date" json:"event_date"`
	Status     string           `db:"status" json:"status"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.ExternalID,
		arg.LeagueID,
		arg.HomeTeamID,
		arg.AwayTeamID,
		arg.EventDate,
		arg.Status,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.LeagueID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.Slug,
		&i.EventDate,
		&i.Status,
		&i.HomeScore,
		&i.AwayScore,
		&i.IsLive,
		&i.MinuteOfMatch,
		&i.Half,
		&i.BettingVolumePercentage,
		&i.VolumeRank,
		&i.VolumeUpdatedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEvent = `-- name: GetEvent :one
SELECT e.id, e.external_id, e.league_id, e.home_team_id, e.away_team_id, e.slug, e.event_date, e.status, e.home_score, e.away_score, e.is_live, e.minute_of_match, e.half, e.betting_volume_percentage, e.volume_rank, e.volume_updated_at, e.created_at, e.updated_at, 
       ht.name as home_team_name,
       at.name as away_team_name,
       l.name as league_name
FROM events e
JOIN teams ht ON e.home_team_id = ht.id
JOIN teams at ON e.away_team_id = at.id
JOIN leagues l ON e.league_id = l.id
WHERE e.id = $1
`

type GetEventRow struct {
	ID                      int32            `db:"id" json:"id"`
	ExternalID              string           `db:"external_id" json:"external_id"`
	LeagueID                pgtype.Int4      `db:"league_id" json:"league_id"`
	HomeTeamID              pgtype.Int4      `db:"home_team_id" json:"home_team_id"`
	AwayTeamID              pgtype.Int4      `db:"away_team_id" json:"away_team_id"`
	Slug                    string           `db:"slug" json:"slug"`
	EventDate               pgtype.Timestamp `db:"event_date" json:"event_date"`
	Status                  string           `db:"status" json:"status"`
	HomeScore               pgtype.Int4      `db:"home_score" json:"home_score"`
	AwayScore               pgtype.Int4      `db:"away_score" json:"away_score"`
	IsLive                  pgtype.Bool      `db:"is_live" json:"is_live"`
	MinuteOfMatch           pgtype.Int4      `db:"minute_of_match" json:"minute_of_match"`
	Half                    pgtype.Int4      `db:"half" json:"half"`
	BettingVolumePercentage pgtype.Numeric   `db:"betting_volume_percentage" json:"betting_volume_percentage"`
	VolumeRank              pgtype.Int4      `db:"volume_rank" json:"volume_rank"`
	VolumeUpdatedAt         pgtype.Timestamp `db:"volume_updated_at" json:"volume_updated_at"`
	CreatedAt               pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt               pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	HomeTeamName            string           `db:"home_team_name" json:"home_team_name"`
	AwayTeamName            string           `db:"away_team_name" json:"away_team_name"`
	LeagueName              string           `db:"league_name" json:"league_name"`
}

func (q *Queries) GetEvent(ctx context.Context, id int32) (GetEventRow, error) {
	row := q.db.QueryRow(ctx, getEvent, id)
	var i GetEventRow
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.LeagueID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.Slug,
		&i.EventDate,
		&i.Status,
		&i.HomeScore,
		&i.AwayScore,
		&i.IsLive,
		&i.MinuteOfMatch,
		&i.Half,
		&i.BettingVolumePercentage,
		&i.VolumeRank,
		&i.VolumeUpdatedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.HomeTeamName,
		&i.AwayTeamName,
		&i.LeagueName,
	)
	return i, err
}

const getEventByExternalID = `-- name: GetEventByExternalID :one
SELECT e.id, e.external_id, e.league_id, e.home_team_id, e.away_team_id, e.slug, e.event_date, e.status, e.home_score, e.away_score, e.is_live, e.minute_of_match, e.half, e.betting_volume_percentage, e.volume_rank, e.volume_updated_at, e.created_at, e.updated_at, 
       ht.name as home_team_name,
       at.name as away_team_name,
       l.name as league_name
FROM events e
JOIN teams ht ON e.home_team_id = ht.id
JOIN teams at ON e.away_team_id = at.id
JOIN leagues l ON e.league_id = l.id
WHERE e.external_id = $1
`

type GetEventByExternalIDRow struct {
	ID                      int32            `db:"id" json:"id"`
	ExternalID              string           `db:"external_id" json:"external_id"`
	LeagueID                pgtype.Int4      `db:"league_id" json:"league_id"`
	HomeTeamID              pgtype.Int4      `db:"home_team_id" json:"home_team_id"`
	AwayTeamID              pgtype.Int4      `db:"away_team_id" json:"away_team_id"`
	Slug                    string           `db:"slug" json:"slug"`
	EventDate               pgtype.Timestamp `db:"event_date" json:"event_date"`
	Status                  string           `db:"status" json:"status"`
	HomeScore               pgtype.Int4      `db:"home_score" json:"home_score"`
	AwayScore               pgtype.Int4      `db:"away_score" json:"away_score"`
	IsLive                  pgtype.Bool      `db:"is_live" json:"is_live"`
	MinuteOfMatch           pgtype.Int4      `db:"minute_of_match" json:"minute_of_match"`
	Half                    pgtype.Int4      `db:"half" json:"half"`
	BettingVolumePercentage pgtype.Numeric   `db:"betting_volume_percentage" json:"betting_volume_percentage"`
	VolumeRank              pgtype.Int4      `db:"volume_rank" json:"volume_rank"`
	VolumeUpdatedAt         pgtype.Timestamp `db:"volume_updated_at" json:"volume_updated_at"`
	CreatedAt               pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt               pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	HomeTeamName            string           `db:"home_team_name" json:"home_team_name"`
	AwayTeamName            string           `db:"away_team_name" json:"away_team_name"`
	LeagueName              string           `db:"league_name" json:"league_name"`
}

func (q *Queries) GetEventByExternalID(ctx context.Context, externalID string) (GetEventByExternalIDRow, error) {
	row := q.db.QueryRow(ctx, getEventByExternalID, externalID)
	var i GetEventByExternalIDRow
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.LeagueID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.Slug,
		&i.EventDate,
		&i.Status,
		&i.HomeScore,
		&i.AwayScore,
		&i.IsLive,
		&i.MinuteOfMatch,
		&i.Half,
		&i.BettingVolumePercentage,
		&i.VolumeRank,
		&i.VolumeUpdatedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.HomeTeamName,
		&i.AwayTeamName,
		&i.LeagueName,
	)
	return i, err
}

const listEventsByDate = `-- name: ListEventsByDate :many
SELECT e.id, e.external_id, e.league_id, e.home_team_id, e.away_team_id, e.slug, e.event_date, e.status, e.home_score, e.away_score, e.is_live, e.minute_of_match, e.half, e.betting_volume_percentage, e.volume_rank, e.volume_updated_at, e.created_at, e.updated_at, 
       ht.name as home_team_name,
       at.name as away_team_name,
       l.name as league_name
FROM events e
JOIN teams ht ON e.home_team_id = ht.id
JOIN teams at ON e.away_team_id = at.id
JOIN leagues l ON e.league_id = l.id
WHERE DATE(e.event_date) = DATE($1)
ORDER BY e.event_date
`

type ListEventsByDateRow struct {
	ID                      int32            `db:"id" json:"id"`
	ExternalID              string           `db:"external_id" json:"external_id"`
	LeagueID                pgtype.Int4      `db:"league_id" json:"league_id"`
	HomeTeamID              pgtype.Int4      `db:"home_team_id" json:"home_team_id"`
	AwayTeamID              pgtype.Int4      `db:"away_team_id" json:"away_team_id"`
	Slug                    string           `db:"slug" json:"slug"`
	EventDate               pgtype.Timestamp `db:"event_date" json:"event_date"`
	Status                  string           `db:"status" json:"status"`
	HomeScore               pgtype.Int4      `db:"home_score" json:"home_score"`
	AwayScore               pgtype.Int4      `db:"away_score" json:"away_score"`
	IsLive                  pgtype.Bool      `db:"is_live" json:"is_live"`
	MinuteOfMatch           pgtype.Int4      `db:"minute_of_match" json:"minute_of_match"`
	Half                    pgtype.Int4      `db:"half" json:"half"`
	BettingVolumePercentage pgtype.Numeric   `db:"betting_volume_percentage" json:"betting_volume_percentage"`
	VolumeRank              pgtype.Int4      `db:"volume_rank" json:"volume_rank"`
	VolumeUpdatedAt         pgtype.Timestamp `db:"volume_updated_at" json:"volume_updated_at"`
	CreatedAt               pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt               pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	HomeTeamName            string           `db:"home_team_name" json:"home_team_name"`
	AwayTeamName            string           `db:"away_team_name" json:"away_team_name"`
	LeagueName              string           `db:"league_name" json:"league_name"`
}

func (q *Queries) ListEventsByDate(ctx context.Context, eventDate interface{}) ([]ListEventsByDateRow, error) {
	rows, err := q.db.Query(ctx, listEventsByDate, eventDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventsByDateRow{}
	for rows.Next() {
		var i ListEventsByDateRow
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.LeagueID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.Slug,
			&i.EventDate,
			&i.Status,
			&i.HomeScore,
			&i.AwayScore,
			&i.IsLive,
			&i.MinuteOfMatch,
			&i.Half,
			&i.BettingVolumePercentage,
			&i.VolumeRank,
			&i.VolumeUpdatedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.LeagueName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEventStatus = `-- name: UpdateEventStatus :one
UPDATE events 
SET status = $1, home_score = $2, away_score = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $4
RETURNING id, external_id, league_id, home_team_id, away_team_id, slug, event_date, status, home_score, away_score, is_live, minute_of_match, half, betting_volume_percentage, volume_rank, volume_updated_at, created_at, updated_at
`

type UpdateEventStatusParams struct {
	Status    string      `db:"status" json:"status"`
	HomeScore pgtype.Int4 `db:"home_score" json:"home_score"`
	AwayScore pgtype.Int4 `db:"away_score" json:"away_score"`
	ID        int32       `db:"id" json:"id"`
}

func (q *Queries) UpdateEventStatus(ctx context.Context, arg UpdateEventStatusParams) (Event, error) {
	row := q.db.QueryRow(ctx, updateEventStatus,
		arg.Status,
		arg.HomeScore,
		arg.AwayScore,
		arg.ID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.LeagueID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.Slug,
		&i.EventDate,
		&i.Status,
		&i.HomeScore,
		&i.AwayScore,
		&i.IsLive,
		&i.MinuteOfMatch,
		&i.Half,
		&i.BettingVolumePercentage,
		&i.VolumeRank,
		&i.VolumeUpdatedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertEvent = `-- name: UpsertEvent :one
INSERT INTO events (external_id, league_id, home_team_id, away_team_id, event_date, status, home_score, away_score)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (external_id) DO UPDATE SET
    league_id = EXCLUDED.league_id,
    home_team_id = EXCLUDED.home_team_id,
    away_team_id = EXCLUDED.away_team_id,
    event_date = EXCLUDED.event_date,
    status = EXCLUDED.status,
    home_score = EXCLUDED.home_score,
    away_score = EXCLUDED.away_score,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, external_id, league_id, home_team_id, away_team_id, slug, event_date, status, home_score, away_score, is_live, minute_of_match, half, betting_volume_percentage, volume_rank, volume_updated_at, created_at, updated_at
`

type UpsertEventParams struct {
	ExternalID string           `db:"external_id" json:"external_id"`
	LeagueID   pgtype.Int4      `db:"league_id" json:"league_id"`
	HomeTeamID pgtype.Int4      `db:"home_team_id" json:"home_team_id"`
	AwayTeamID pgtype.Int4      `db:"away_team_id" json:"away_team_id"`
	EventDate  pgtype.Timestamp `db:"event_date" json:"event_date"`
	Status     string           `db:"status" json:"status"`
	HomeScore  pgtype.Int4      `db:"home_score" json:"home_score"`
	AwayScore  pgtype.Int4      `db:"away_score" json:"away_score"`
}

func (q *Queries) UpsertEvent(ctx context.Context, arg UpsertEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, upsertEvent,
		arg.ExternalID,
		arg.LeagueID,
		arg.HomeTeamID,
		arg.AwayTeamID,
		arg.EventDate,
		arg.Status,
		arg.HomeScore,
		arg.AwayScore,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.LeagueID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.Slug,
		&i.EventDate,
		&i.Status,
		&i.HomeScore,
		&i.AwayScore,
		&i.IsLive,
		&i.MinuteOfMatch,
		&i.Half,
		&i.BettingVolumePercentage,
		&i.VolumeRank,
		&i.VolumeUpdatedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
