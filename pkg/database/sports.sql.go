// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sports.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getSport = `-- name: GetSport :one
SELECT id, name, code, slug, live_count, upcoming_count, events_count, odds_count, has_results, has_king_odd, has_digital_content, created_at, updated_at FROM sports WHERE id = $1
`

func (q *Queries) GetSport(ctx context.Context, id int32) (Sport, error) {
	row := q.db.QueryRow(ctx, getSport, id)
	var i Sport
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Slug,
		&i.LiveCount,
		&i.UpcomingCount,
		&i.EventsCount,
		&i.OddsCount,
		&i.HasResults,
		&i.HasKingOdd,
		&i.HasDigitalContent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listSports = `-- name: ListSports :many
SELECT id, name, code, slug, live_count, upcoming_count, events_count, odds_count, has_results, has_king_odd, has_digital_content, created_at, updated_at FROM sports ORDER BY id
`

func (q *Queries) ListSports(ctx context.Context) ([]Sport, error) {
	rows, err := q.db.Query(ctx, listSports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Sport{}
	for rows.Next() {
		var i Sport
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.Slug,
			&i.LiveCount,
			&i.UpcomingCount,
			&i.EventsCount,
			&i.OddsCount,
			&i.HasResults,
			&i.HasKingOdd,
			&i.HasDigitalContent,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSportInfo = `-- name: UpdateSportInfo :one
UPDATE sports SET
    live_count = $1,
    upcoming_count = $2,
    events_count = $3,
    odds_count = $4,
    has_results = $5,
    has_king_odd = $6,
    has_digital_content = $7,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $8
RETURNING id, name, code, slug, live_count, upcoming_count, events_count, odds_count, has_results, has_king_odd, has_digital_content, created_at, updated_at
`

type UpdateSportInfoParams struct {
	LiveCount         pgtype.Int4 `db:"live_count" json:"live_count"`
	UpcomingCount     pgtype.Int4 `db:"upcoming_count" json:"upcoming_count"`
	EventsCount       pgtype.Int4 `db:"events_count" json:"events_count"`
	OddsCount         pgtype.Int4 `db:"odds_count" json:"odds_count"`
	HasResults        pgtype.Bool `db:"has_results" json:"has_results"`
	HasKingOdd        pgtype.Bool `db:"has_king_odd" json:"has_king_odd"`
	HasDigitalContent pgtype.Bool `db:"has_digital_content" json:"has_digital_content"`
	ID                int32       `db:"id" json:"id"`
}

func (q *Queries) UpdateSportInfo(ctx context.Context, arg UpdateSportInfoParams) (Sport, error) {
	row := q.db.QueryRow(ctx, updateSportInfo,
		arg.LiveCount,
		arg.UpcomingCount,
		arg.EventsCount,
		arg.OddsCount,
		arg.HasResults,
		arg.HasKingOdd,
		arg.HasDigitalContent,
		arg.ID,
	)
	var i Sport
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Slug,
		&i.LiveCount,
		&i.UpcomingCount,
		&i.EventsCount,
		&i.OddsCount,
		&i.HasResults,
		&i.HasKingOdd,
		&i.HasDigitalContent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertSport = `-- name: UpsertSport :one
INSERT INTO sports (
    id, 
    name, 
    code, 
    live_count, 
    upcoming_count, 
    events_count, 
    odds_count, 
    has_results, 
    has_king_odd, 
    has_digital_content, 
    updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    CURRENT_TIMESTAMP
)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    code = EXCLUDED.code,
    live_count = EXCLUDED.live_count,
    upcoming_count = EXCLUDED.upcoming_count,
    events_count = EXCLUDED.events_count,
    odds_count = EXCLUDED.odds_count,
    has_results = EXCLUDED.has_results,
    has_king_odd = EXCLUDED.has_king_odd,
    has_digital_content = EXCLUDED.has_digital_content,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, name, code, slug, live_count, upcoming_count, events_count, odds_count, has_results, has_king_odd, has_digital_content, created_at, updated_at
`

type UpsertSportParams struct {
	ID                int32       `db:"id" json:"id"`
	Name              string      `db:"name" json:"name"`
	Code              string      `db:"code" json:"code"`
	LiveCount         pgtype.Int4 `db:"live_count" json:"live_count"`
	UpcomingCount     pgtype.Int4 `db:"upcoming_count" json:"upcoming_count"`
	EventsCount       pgtype.Int4 `db:"events_count" json:"events_count"`
	OddsCount         pgtype.Int4 `db:"odds_count" json:"odds_count"`
	HasResults        pgtype.Bool `db:"has_results" json:"has_results"`
	HasKingOdd        pgtype.Bool `db:"has_king_odd" json:"has_king_odd"`
	HasDigitalContent pgtype.Bool `db:"has_digital_content" json:"has_digital_content"`
}

func (q *Queries) UpsertSport(ctx context.Context, arg UpsertSportParams) (Sport, error) {
	row := q.db.QueryRow(ctx, upsertSport,
		arg.ID,
		arg.Name,
		arg.Code,
		arg.LiveCount,
		arg.UpcomingCount,
		arg.EventsCount,
		arg.OddsCount,
		arg.HasResults,
		arg.HasKingOdd,
		arg.HasDigitalContent,
	)
	var i Sport
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Slug,
		&i.LiveCount,
		&i.UpcomingCount,
		&i.EventsCount,
		&i.OddsCount,
		&i.HasResults,
		&i.HasKingOdd,
		&i.HasDigitalContent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
