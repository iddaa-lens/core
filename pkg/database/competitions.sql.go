// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: competitions.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCompetition = `-- name: CreateCompetition :one
INSERT INTO competitions (iddaa_id, external_ref, country_code, parent_id, sport_id, short_name, full_name, icon_url)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, iddaa_id, external_ref, country_code, parent_id, sport_id, short_name, full_name, slug, icon_url, created_at, updated_at
`

type CreateCompetitionParams struct {
	IddaaID     int32       `db:"iddaa_id" json:"iddaa_id"`
	ExternalRef pgtype.Int4 `db:"external_ref" json:"external_ref"`
	CountryCode pgtype.Text `db:"country_code" json:"country_code"`
	ParentID    pgtype.Int4 `db:"parent_id" json:"parent_id"`
	SportID     pgtype.Int4 `db:"sport_id" json:"sport_id"`
	ShortName   pgtype.Text `db:"short_name" json:"short_name"`
	FullName    string      `db:"full_name" json:"full_name"`
	IconUrl     pgtype.Text `db:"icon_url" json:"icon_url"`
}

func (q *Queries) CreateCompetition(ctx context.Context, arg CreateCompetitionParams) (Competition, error) {
	row := q.db.QueryRow(ctx, createCompetition,
		arg.IddaaID,
		arg.ExternalRef,
		arg.CountryCode,
		arg.ParentID,
		arg.SportID,
		arg.ShortName,
		arg.FullName,
		arg.IconUrl,
	)
	var i Competition
	err := row.Scan(
		&i.ID,
		&i.IddaaID,
		&i.ExternalRef,
		&i.CountryCode,
		&i.ParentID,
		&i.SportID,
		&i.ShortName,
		&i.FullName,
		&i.Slug,
		&i.IconUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompetition = `-- name: GetCompetition :one
SELECT c.id, c.iddaa_id, c.external_ref, c.country_code, c.parent_id, c.sport_id, c.short_name, c.full_name, c.slug, c.icon_url, c.created_at, c.updated_at, s.name as sport_name, s.code as sport_code
FROM competitions c
JOIN sports s ON c.sport_id = s.id
WHERE c.id = $1
`

type GetCompetitionRow struct {
	ID          int32            `db:"id" json:"id"`
	IddaaID     int32            `db:"iddaa_id" json:"iddaa_id"`
	ExternalRef pgtype.Int4      `db:"external_ref" json:"external_ref"`
	CountryCode pgtype.Text      `db:"country_code" json:"country_code"`
	ParentID    pgtype.Int4      `db:"parent_id" json:"parent_id"`
	SportID     pgtype.Int4      `db:"sport_id" json:"sport_id"`
	ShortName   pgtype.Text      `db:"short_name" json:"short_name"`
	FullName    string           `db:"full_name" json:"full_name"`
	Slug        string           `db:"slug" json:"slug"`
	IconUrl     pgtype.Text      `db:"icon_url" json:"icon_url"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	SportName   string           `db:"sport_name" json:"sport_name"`
	SportCode   string           `db:"sport_code" json:"sport_code"`
}

func (q *Queries) GetCompetition(ctx context.Context, id int32) (GetCompetitionRow, error) {
	row := q.db.QueryRow(ctx, getCompetition, id)
	var i GetCompetitionRow
	err := row.Scan(
		&i.ID,
		&i.IddaaID,
		&i.ExternalRef,
		&i.CountryCode,
		&i.ParentID,
		&i.SportID,
		&i.ShortName,
		&i.FullName,
		&i.Slug,
		&i.IconUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SportName,
		&i.SportCode,
	)
	return i, err
}

const getCompetitionByIddaaID = `-- name: GetCompetitionByIddaaID :one
SELECT c.id, c.iddaa_id, c.external_ref, c.country_code, c.parent_id, c.sport_id, c.short_name, c.full_name, c.slug, c.icon_url, c.created_at, c.updated_at, s.name as sport_name, s.code as sport_code
FROM competitions c
JOIN sports s ON c.sport_id = s.id
WHERE c.iddaa_id = $1
`

type GetCompetitionByIddaaIDRow struct {
	ID          int32            `db:"id" json:"id"`
	IddaaID     int32            `db:"iddaa_id" json:"iddaa_id"`
	ExternalRef pgtype.Int4      `db:"external_ref" json:"external_ref"`
	CountryCode pgtype.Text      `db:"country_code" json:"country_code"`
	ParentID    pgtype.Int4      `db:"parent_id" json:"parent_id"`
	SportID     pgtype.Int4      `db:"sport_id" json:"sport_id"`
	ShortName   pgtype.Text      `db:"short_name" json:"short_name"`
	FullName    string           `db:"full_name" json:"full_name"`
	Slug        string           `db:"slug" json:"slug"`
	IconUrl     pgtype.Text      `db:"icon_url" json:"icon_url"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	SportName   string           `db:"sport_name" json:"sport_name"`
	SportCode   string           `db:"sport_code" json:"sport_code"`
}

func (q *Queries) GetCompetitionByIddaaID(ctx context.Context, iddaaID int32) (GetCompetitionByIddaaIDRow, error) {
	row := q.db.QueryRow(ctx, getCompetitionByIddaaID, iddaaID)
	var i GetCompetitionByIddaaIDRow
	err := row.Scan(
		&i.ID,
		&i.IddaaID,
		&i.ExternalRef,
		&i.CountryCode,
		&i.ParentID,
		&i.SportID,
		&i.ShortName,
		&i.FullName,
		&i.Slug,
		&i.IconUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SportName,
		&i.SportCode,
	)
	return i, err
}

const listCompetitionsByCountry = `-- name: ListCompetitionsByCountry :many
SELECT c.id, c.iddaa_id, c.external_ref, c.country_code, c.parent_id, c.sport_id, c.short_name, c.full_name, c.slug, c.icon_url, c.created_at, c.updated_at, s.name as sport_name, s.code as sport_code
FROM competitions c
JOIN sports s ON c.sport_id = s.id
WHERE c.country_code = $1
ORDER BY c.full_name
`

type ListCompetitionsByCountryRow struct {
	ID          int32            `db:"id" json:"id"`
	IddaaID     int32            `db:"iddaa_id" json:"iddaa_id"`
	ExternalRef pgtype.Int4      `db:"external_ref" json:"external_ref"`
	CountryCode pgtype.Text      `db:"country_code" json:"country_code"`
	ParentID    pgtype.Int4      `db:"parent_id" json:"parent_id"`
	SportID     pgtype.Int4      `db:"sport_id" json:"sport_id"`
	ShortName   pgtype.Text      `db:"short_name" json:"short_name"`
	FullName    string           `db:"full_name" json:"full_name"`
	Slug        string           `db:"slug" json:"slug"`
	IconUrl     pgtype.Text      `db:"icon_url" json:"icon_url"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	SportName   string           `db:"sport_name" json:"sport_name"`
	SportCode   string           `db:"sport_code" json:"sport_code"`
}

func (q *Queries) ListCompetitionsByCountry(ctx context.Context, countryCode pgtype.Text) ([]ListCompetitionsByCountryRow, error) {
	rows, err := q.db.Query(ctx, listCompetitionsByCountry, countryCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCompetitionsByCountryRow{}
	for rows.Next() {
		var i ListCompetitionsByCountryRow
		if err := rows.Scan(
			&i.ID,
			&i.IddaaID,
			&i.ExternalRef,
			&i.CountryCode,
			&i.ParentID,
			&i.SportID,
			&i.ShortName,
			&i.FullName,
			&i.Slug,
			&i.IconUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SportName,
			&i.SportCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCompetitionsBySport = `-- name: ListCompetitionsBySport :many
SELECT c.id, c.iddaa_id, c.external_ref, c.country_code, c.parent_id, c.sport_id, c.short_name, c.full_name, c.slug, c.icon_url, c.created_at, c.updated_at, s.name as sport_name, s.code as sport_code
FROM competitions c
JOIN sports s ON c.sport_id = s.id
WHERE c.sport_id = $1
ORDER BY c.full_name
`

type ListCompetitionsBySportRow struct {
	ID          int32            `db:"id" json:"id"`
	IddaaID     int32            `db:"iddaa_id" json:"iddaa_id"`
	ExternalRef pgtype.Int4      `db:"external_ref" json:"external_ref"`
	CountryCode pgtype.Text      `db:"country_code" json:"country_code"`
	ParentID    pgtype.Int4      `db:"parent_id" json:"parent_id"`
	SportID     pgtype.Int4      `db:"sport_id" json:"sport_id"`
	ShortName   pgtype.Text      `db:"short_name" json:"short_name"`
	FullName    string           `db:"full_name" json:"full_name"`
	Slug        string           `db:"slug" json:"slug"`
	IconUrl     pgtype.Text      `db:"icon_url" json:"icon_url"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	SportName   string           `db:"sport_name" json:"sport_name"`
	SportCode   string           `db:"sport_code" json:"sport_code"`
}

func (q *Queries) ListCompetitionsBySport(ctx context.Context, sportID pgtype.Int4) ([]ListCompetitionsBySportRow, error) {
	rows, err := q.db.Query(ctx, listCompetitionsBySport, sportID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCompetitionsBySportRow{}
	for rows.Next() {
		var i ListCompetitionsBySportRow
		if err := rows.Scan(
			&i.ID,
			&i.IddaaID,
			&i.ExternalRef,
			&i.CountryCode,
			&i.ParentID,
			&i.SportID,
			&i.ShortName,
			&i.FullName,
			&i.Slug,
			&i.IconUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SportName,
			&i.SportCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCompetition = `-- name: UpdateCompetition :one
UPDATE competitions 
SET external_ref = $1, country_code = $2, parent_id = $3, sport_id = $4, 
    short_name = $5, full_name = $6, icon_url = $7, updated_at = CURRENT_TIMESTAMP
WHERE iddaa_id = $8
RETURNING id, iddaa_id, external_ref, country_code, parent_id, sport_id, short_name, full_name, slug, icon_url, created_at, updated_at
`

type UpdateCompetitionParams struct {
	ExternalRef pgtype.Int4 `db:"external_ref" json:"external_ref"`
	CountryCode pgtype.Text `db:"country_code" json:"country_code"`
	ParentID    pgtype.Int4 `db:"parent_id" json:"parent_id"`
	SportID     pgtype.Int4 `db:"sport_id" json:"sport_id"`
	ShortName   pgtype.Text `db:"short_name" json:"short_name"`
	FullName    string      `db:"full_name" json:"full_name"`
	IconUrl     pgtype.Text `db:"icon_url" json:"icon_url"`
	IddaaID     int32       `db:"iddaa_id" json:"iddaa_id"`
}

func (q *Queries) UpdateCompetition(ctx context.Context, arg UpdateCompetitionParams) (Competition, error) {
	row := q.db.QueryRow(ctx, updateCompetition,
		arg.ExternalRef,
		arg.CountryCode,
		arg.ParentID,
		arg.SportID,
		arg.ShortName,
		arg.FullName,
		arg.IconUrl,
		arg.IddaaID,
	)
	var i Competition
	err := row.Scan(
		&i.ID,
		&i.IddaaID,
		&i.ExternalRef,
		&i.CountryCode,
		&i.ParentID,
		&i.SportID,
		&i.ShortName,
		&i.FullName,
		&i.Slug,
		&i.IconUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertCompetition = `-- name: UpsertCompetition :one
INSERT INTO competitions (iddaa_id, external_ref, country_code, parent_id, sport_id, short_name, full_name, icon_url)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (iddaa_id) DO UPDATE SET
    external_ref = EXCLUDED.external_ref,
    country_code = EXCLUDED.country_code,
    parent_id = EXCLUDED.parent_id,
    sport_id = EXCLUDED.sport_id,
    short_name = EXCLUDED.short_name,
    full_name = EXCLUDED.full_name,
    icon_url = EXCLUDED.icon_url,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, iddaa_id, external_ref, country_code, parent_id, sport_id, short_name, full_name, slug, icon_url, created_at, updated_at
`

type UpsertCompetitionParams struct {
	IddaaID     int32       `db:"iddaa_id" json:"iddaa_id"`
	ExternalRef pgtype.Int4 `db:"external_ref" json:"external_ref"`
	CountryCode pgtype.Text `db:"country_code" json:"country_code"`
	ParentID    pgtype.Int4 `db:"parent_id" json:"parent_id"`
	SportID     pgtype.Int4 `db:"sport_id" json:"sport_id"`
	ShortName   pgtype.Text `db:"short_name" json:"short_name"`
	FullName    string      `db:"full_name" json:"full_name"`
	IconUrl     pgtype.Text `db:"icon_url" json:"icon_url"`
}

func (q *Queries) UpsertCompetition(ctx context.Context, arg UpsertCompetitionParams) (Competition, error) {
	row := q.db.QueryRow(ctx, upsertCompetition,
		arg.IddaaID,
		arg.ExternalRef,
		arg.CountryCode,
		arg.ParentID,
		arg.SportID,
		arg.ShortName,
		arg.FullName,
		arg.IconUrl,
	)
	var i Competition
	err := row.Scan(
		&i.ID,
		&i.IddaaID,
		&i.ExternalRef,
		&i.CountryCode,
		&i.ParentID,
		&i.SportID,
		&i.ShortName,
		&i.FullName,
		&i.Slug,
		&i.IconUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
