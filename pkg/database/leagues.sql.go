// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: leagues.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLeagueMapping = `-- name: CreateLeagueMapping :one
INSERT INTO league_mappings (
    internal_league_id, 
    football_api_league_id, 
    confidence, 
    mapping_method
) VALUES (
    $1, $2, $3, $4
) RETURNING id, internal_league_id, football_api_league_id, confidence, mapping_method, created_at, updated_at
`

type CreateLeagueMappingParams struct {
	InternalLeagueID    int32          `db:"internal_league_id" json:"internal_league_id"`
	FootballApiLeagueID int32          `db:"football_api_league_id" json:"football_api_league_id"`
	Confidence          pgtype.Numeric `db:"confidence" json:"confidence"`
	MappingMethod       string         `db:"mapping_method" json:"mapping_method"`
}

func (q *Queries) CreateLeagueMapping(ctx context.Context, arg CreateLeagueMappingParams) (LeagueMapping, error) {
	row := q.db.QueryRow(ctx, createLeagueMapping,
		arg.InternalLeagueID,
		arg.FootballApiLeagueID,
		arg.Confidence,
		arg.MappingMethod,
	)
	var i LeagueMapping
	err := row.Scan(
		&i.ID,
		&i.InternalLeagueID,
		&i.FootballApiLeagueID,
		&i.Confidence,
		&i.MappingMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTeamMapping = `-- name: CreateTeamMapping :one
INSERT INTO team_mappings (
    internal_team_id, 
    football_api_team_id, 
    confidence, 
    mapping_method
) VALUES (
    $1, $2, $3, $4
) RETURNING id, internal_team_id, football_api_team_id, confidence, mapping_method, created_at, updated_at
`

type CreateTeamMappingParams struct {
	InternalTeamID    int32          `db:"internal_team_id" json:"internal_team_id"`
	FootballApiTeamID int32          `db:"football_api_team_id" json:"football_api_team_id"`
	Confidence        pgtype.Numeric `db:"confidence" json:"confidence"`
	MappingMethod     string         `db:"mapping_method" json:"mapping_method"`
}

func (q *Queries) CreateTeamMapping(ctx context.Context, arg CreateTeamMappingParams) (TeamMapping, error) {
	row := q.db.QueryRow(ctx, createTeamMapping,
		arg.InternalTeamID,
		arg.FootballApiTeamID,
		arg.Confidence,
		arg.MappingMethod,
	)
	var i TeamMapping
	err := row.Scan(
		&i.ID,
		&i.InternalTeamID,
		&i.FootballApiTeamID,
		&i.Confidence,
		&i.MappingMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLeague = `-- name: DeleteLeague :exec
DELETE FROM leagues WHERE id = $1
`

func (q *Queries) DeleteLeague(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteLeague, id)
	return err
}

const getLeague = `-- name: GetLeague :one
SELECT id, external_id, name, country, sport_id, is_active, slug, created_at, updated_at FROM leagues WHERE id = $1
`

func (q *Queries) GetLeague(ctx context.Context, id int32) (League, error) {
	row := q.db.QueryRow(ctx, getLeague, id)
	var i League
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Country,
		&i.SportID,
		&i.IsActive,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeagueByExternalID = `-- name: GetLeagueByExternalID :one
SELECT id, external_id, name, country, sport_id, is_active, slug, created_at, updated_at FROM leagues WHERE external_id = $1
`

func (q *Queries) GetLeagueByExternalID(ctx context.Context, externalID string) (League, error) {
	row := q.db.QueryRow(ctx, getLeagueByExternalID, externalID)
	var i League
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Country,
		&i.SportID,
		&i.IsActive,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeagueMapping = `-- name: GetLeagueMapping :one
SELECT id, internal_league_id, football_api_league_id, confidence, mapping_method, created_at, updated_at FROM league_mappings 
WHERE internal_league_id = $1
`

func (q *Queries) GetLeagueMapping(ctx context.Context, internalLeagueID int32) (LeagueMapping, error) {
	row := q.db.QueryRow(ctx, getLeagueMapping, internalLeagueID)
	var i LeagueMapping
	err := row.Scan(
		&i.ID,
		&i.InternalLeagueID,
		&i.FootballApiLeagueID,
		&i.Confidence,
		&i.MappingMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTeamMapping = `-- name: GetTeamMapping :one
SELECT id, internal_team_id, football_api_team_id, confidence, mapping_method, created_at, updated_at FROM team_mappings 
WHERE internal_team_id = $1
`

func (q *Queries) GetTeamMapping(ctx context.Context, internalTeamID int32) (TeamMapping, error) {
	row := q.db.QueryRow(ctx, getTeamMapping, internalTeamID)
	var i TeamMapping
	err := row.Scan(
		&i.ID,
		&i.InternalTeamID,
		&i.FootballApiTeamID,
		&i.Confidence,
		&i.MappingMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listLeagueMappings = `-- name: ListLeagueMappings :many
SELECT id, internal_league_id, football_api_league_id, confidence, mapping_method, created_at, updated_at FROM league_mappings ORDER BY confidence DESC
`

func (q *Queries) ListLeagueMappings(ctx context.Context) ([]LeagueMapping, error) {
	rows, err := q.db.Query(ctx, listLeagueMappings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LeagueMapping{}
	for rows.Next() {
		var i LeagueMapping
		if err := rows.Scan(
			&i.ID,
			&i.InternalLeagueID,
			&i.FootballApiLeagueID,
			&i.Confidence,
			&i.MappingMethod,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeagues = `-- name: ListLeagues :many
SELECT id, external_id, name, country, sport_id, is_active, slug, created_at, updated_at FROM leagues ORDER BY name
`

func (q *Queries) ListLeagues(ctx context.Context) ([]League, error) {
	rows, err := q.db.Query(ctx, listLeagues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []League{}
	for rows.Next() {
		var i League
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.SportID,
			&i.IsActive,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamMappings = `-- name: ListTeamMappings :many
SELECT id, internal_team_id, football_api_team_id, confidence, mapping_method, created_at, updated_at FROM team_mappings ORDER BY confidence DESC
`

func (q *Queries) ListTeamMappings(ctx context.Context) ([]TeamMapping, error) {
	rows, err := q.db.Query(ctx, listTeamMappings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TeamMapping{}
	for rows.Next() {
		var i TeamMapping
		if err := rows.Scan(
			&i.ID,
			&i.InternalTeamID,
			&i.FootballApiTeamID,
			&i.Confidence,
			&i.MappingMethod,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamsByLeague = `-- name: ListTeamsByLeague :many
SELECT t.id, t.external_id, t.name, t.country, t.logo_url, t.is_active, t.slug, t.created_at, t.updated_at FROM teams t
INNER JOIN events e ON (t.id = e.home_team_id OR t.id = e.away_team_id)
WHERE e.league_id = $1
GROUP BY t.id, t.external_id, t.name, t.country, t.logo_url, t.is_active, t.slug, t.created_at, t.updated_at
`

func (q *Queries) ListTeamsByLeague(ctx context.Context, leagueID pgtype.Int4) ([]Team, error) {
	rows, err := q.db.Query(ctx, listTeamsByLeague, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.LogoUrl,
			&i.IsActive,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmappedFootballLeagues = `-- name: ListUnmappedFootballLeagues :many
SELECT l.id, l.external_id, l.name, l.country, l.sport_id, l.is_active, l.slug, l.created_at, l.updated_at FROM leagues l 
LEFT JOIN league_mappings lm ON l.id = lm.internal_league_id 
WHERE lm.id IS NULL AND l.sport_id = 1
`

func (q *Queries) ListUnmappedFootballLeagues(ctx context.Context) ([]League, error) {
	rows, err := q.db.Query(ctx, listUnmappedFootballLeagues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []League{}
	for rows.Next() {
		var i League
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.SportID,
			&i.IsActive,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmappedLeagues = `-- name: ListUnmappedLeagues :many
SELECT l.id, l.external_id, l.name, l.country, l.sport_id, l.is_active, l.slug, l.created_at, l.updated_at FROM leagues l 
LEFT JOIN league_mappings lm ON l.id = lm.internal_league_id 
WHERE lm.id IS NULL
`

func (q *Queries) ListUnmappedLeagues(ctx context.Context) ([]League, error) {
	rows, err := q.db.Query(ctx, listUnmappedLeagues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []League{}
	for rows.Next() {
		var i League
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Country,
			&i.SportID,
			&i.IsActive,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLeague = `-- name: UpdateLeague :one
UPDATE leagues 
SET name = $1, country = $2, sport_id = $3, is_active = $4, updated_at = CURRENT_TIMESTAMP
WHERE id = $5
RETURNING id, external_id, name, country, sport_id, is_active, slug, created_at, updated_at
`

type UpdateLeagueParams struct {
	Name     string      `db:"name" json:"name"`
	Country  pgtype.Text `db:"country" json:"country"`
	SportID  pgtype.Int4 `db:"sport_id" json:"sport_id"`
	IsActive pgtype.Bool `db:"is_active" json:"is_active"`
	ID       int32       `db:"id" json:"id"`
}

func (q *Queries) UpdateLeague(ctx context.Context, arg UpdateLeagueParams) (League, error) {
	row := q.db.QueryRow(ctx, updateLeague,
		arg.Name,
		arg.Country,
		arg.SportID,
		arg.IsActive,
		arg.ID,
	)
	var i League
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Country,
		&i.SportID,
		&i.IsActive,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertLeague = `-- name: UpsertLeague :one
INSERT INTO leagues (external_id, name, country, sport_id, is_active)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (external_id) DO UPDATE SET
    name = EXCLUDED.name,
    country = EXCLUDED.country,
    sport_id = EXCLUDED.sport_id,
    is_active = EXCLUDED.is_active,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, external_id, name, country, sport_id, is_active, slug, created_at, updated_at
`

type UpsertLeagueParams struct {
	ExternalID string      `db:"external_id" json:"external_id"`
	Name       string      `db:"name" json:"name"`
	Country    pgtype.Text `db:"country" json:"country"`
	SportID    pgtype.Int4 `db:"sport_id" json:"sport_id"`
	IsActive   pgtype.Bool `db:"is_active" json:"is_active"`
}

func (q *Queries) UpsertLeague(ctx context.Context, arg UpsertLeagueParams) (League, error) {
	row := q.db.QueryRow(ctx, upsertLeague,
		arg.ExternalID,
		arg.Name,
		arg.Country,
		arg.SportID,
		arg.IsActive,
	)
	var i League
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Country,
		&i.SportID,
		&i.IsActive,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
