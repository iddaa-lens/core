// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: odds_tracking.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getOddsChangesByMarket = `-- name: GetOddsChangesByMarket :many
SELECT 
    oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.recorded_at, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff,
    mt.code as market_code,
    mt.name as market_name
FROM odds_history oh
JOIN market_types mt ON oh.market_type_id = mt.id
WHERE oh.event_id = $1
AND oh.market_type_id = $2
AND ABS(oh.change_percentage) > $3
ORDER BY oh.recorded_at DESC
`

type GetOddsChangesByMarketParams struct {
	EventID             pgtype.Int4    `db:"event_id" json:"event_id"`
	MarketTypeID        pgtype.Int4    `db:"market_type_id" json:"market_type_id"`
	MinChangePercentage pgtype.Numeric `db:"min_change_percentage" json:"min_change_percentage"`
}

type GetOddsChangesByMarketRow struct {
	ID                  int32            `db:"id" json:"id"`
	EventID             pgtype.Int4      `db:"event_id" json:"event_id"`
	MarketTypeID        pgtype.Int4      `db:"market_type_id" json:"market_type_id"`
	Outcome             string           `db:"outcome" json:"outcome"`
	OddsValue           pgtype.Numeric   `db:"odds_value" json:"odds_value"`
	PreviousValue       pgtype.Numeric   `db:"previous_value" json:"previous_value"`
	WinningOdds         pgtype.Numeric   `db:"winning_odds" json:"winning_odds"`
	ChangeAmount        pgtype.Numeric   `db:"change_amount" json:"change_amount"`
	ChangePercentage    pgtype.Numeric   `db:"change_percentage" json:"change_percentage"`
	Multiplier          pgtype.Numeric   `db:"multiplier" json:"multiplier"`
	RecordedAt          pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	SharpMoneyIndicator pgtype.Numeric   `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement   pgtype.Bool      `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel   pgtype.Text      `db:"significance_level" json:"significance_level"`
	MinutesToKickoff    pgtype.Int4      `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	MarketCode          string           `db:"market_code" json:"market_code"`
	MarketName          string           `db:"market_name" json:"market_name"`
}

// Get odds changes for a specific market
func (q *Queries) GetOddsChangesByMarket(ctx context.Context, arg GetOddsChangesByMarketParams) ([]GetOddsChangesByMarketRow, error) {
	rows, err := q.db.Query(ctx, getOddsChangesByMarket, arg.EventID, arg.MarketTypeID, arg.MinChangePercentage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOddsChangesByMarketRow{}
	for rows.Next() {
		var i GetOddsChangesByMarketRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.RecordedAt,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.MarketCode,
			&i.MarketName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOddsHistory = `-- name: GetOddsHistory :many
SELECT 
    oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.recorded_at, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff,
    mt.code as market_code,
    mt.name as market_name
FROM odds_history oh
JOIN market_types mt ON oh.market_type_id = mt.id
WHERE oh.event_id = $1
ORDER BY oh.market_type_id, oh.outcome, oh.recorded_at DESC
`

type GetOddsHistoryRow struct {
	ID                  int32            `db:"id" json:"id"`
	EventID             pgtype.Int4      `db:"event_id" json:"event_id"`
	MarketTypeID        pgtype.Int4      `db:"market_type_id" json:"market_type_id"`
	Outcome             string           `db:"outcome" json:"outcome"`
	OddsValue           pgtype.Numeric   `db:"odds_value" json:"odds_value"`
	PreviousValue       pgtype.Numeric   `db:"previous_value" json:"previous_value"`
	WinningOdds         pgtype.Numeric   `db:"winning_odds" json:"winning_odds"`
	ChangeAmount        pgtype.Numeric   `db:"change_amount" json:"change_amount"`
	ChangePercentage    pgtype.Numeric   `db:"change_percentage" json:"change_percentage"`
	Multiplier          pgtype.Numeric   `db:"multiplier" json:"multiplier"`
	RecordedAt          pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	SharpMoneyIndicator pgtype.Numeric   `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement   pgtype.Bool      `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel   pgtype.Text      `db:"significance_level" json:"significance_level"`
	MinutesToKickoff    pgtype.Int4      `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	MarketCode          string           `db:"market_code" json:"market_code"`
	MarketName          string           `db:"market_name" json:"market_name"`
}

// Get full odds history for a specific event
func (q *Queries) GetOddsHistory(ctx context.Context, eventID pgtype.Int4) ([]GetOddsHistoryRow, error) {
	rows, err := q.db.Query(ctx, getOddsHistory, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOddsHistoryRow{}
	for rows.Next() {
		var i GetOddsHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.RecordedAt,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.MarketCode,
			&i.MarketName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentMovements = `-- name: GetRecentMovements :many
SELECT 
    oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.recorded_at, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff,
    e.slug as event_slug,
    e.event_date,
    e.status as event_status,
    e.is_live,
    e.home_score,
    e.away_score,
    e.minute_of_match,
    e.betting_volume_percentage,
    mt.code as market_code,
    mt.name as market_name,
    mt.description as market_description,
    ht.name as home_team,
    ht.country as home_team_country,
    at.name as away_team,
    at.country as away_team_country,
    l.name as league_name,
    l.country as league_country,
    s.name as sport_name,
    s.code as sport_code
FROM odds_history oh
JOIN events e ON oh.event_id = e.id
JOIN teams ht ON e.home_team_id = ht.id
JOIN teams at ON e.away_team_id = at.id
JOIN market_types mt ON oh.market_type_id = mt.id
JOIN leagues l ON e.league_id = l.id
JOIN sports s ON e.sport_id = s.id
WHERE oh.recorded_at > $1
AND ABS(oh.change_percentage) > $2
ORDER BY oh.recorded_at DESC
LIMIT $3
`

type GetRecentMovementsParams struct {
	SinceTime           pgtype.Timestamp `db:"since_time" json:"since_time"`
	MinChangePercentage pgtype.Numeric   `db:"min_change_percentage" json:"min_change_percentage"`
	LimitCount          int32            `db:"limit_count" json:"limit_count"`
}

type GetRecentMovementsRow struct {
	ID                      int32            `db:"id" json:"id"`
	EventID                 pgtype.Int4      `db:"event_id" json:"event_id"`
	MarketTypeID            pgtype.Int4      `db:"market_type_id" json:"market_type_id"`
	Outcome                 string           `db:"outcome" json:"outcome"`
	OddsValue               pgtype.Numeric   `db:"odds_value" json:"odds_value"`
	PreviousValue           pgtype.Numeric   `db:"previous_value" json:"previous_value"`
	WinningOdds             pgtype.Numeric   `db:"winning_odds" json:"winning_odds"`
	ChangeAmount            pgtype.Numeric   `db:"change_amount" json:"change_amount"`
	ChangePercentage        pgtype.Numeric   `db:"change_percentage" json:"change_percentage"`
	Multiplier              pgtype.Numeric   `db:"multiplier" json:"multiplier"`
	RecordedAt              pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	SharpMoneyIndicator     pgtype.Numeric   `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement       pgtype.Bool      `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel       pgtype.Text      `db:"significance_level" json:"significance_level"`
	MinutesToKickoff        pgtype.Int4      `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	EventSlug               string           `db:"event_slug" json:"event_slug"`
	EventDate               pgtype.Timestamp `db:"event_date" json:"event_date"`
	EventStatus             string           `db:"event_status" json:"event_status"`
	IsLive                  pgtype.Bool      `db:"is_live" json:"is_live"`
	HomeScore               pgtype.Int4      `db:"home_score" json:"home_score"`
	AwayScore               pgtype.Int4      `db:"away_score" json:"away_score"`
	MinuteOfMatch           pgtype.Int4      `db:"minute_of_match" json:"minute_of_match"`
	BettingVolumePercentage pgtype.Numeric   `db:"betting_volume_percentage" json:"betting_volume_percentage"`
	MarketCode              string           `db:"market_code" json:"market_code"`
	MarketName              string           `db:"market_name" json:"market_name"`
	MarketDescription       pgtype.Text      `db:"market_description" json:"market_description"`
	HomeTeam                string           `db:"home_team" json:"home_team"`
	HomeTeamCountry         pgtype.Text      `db:"home_team_country" json:"home_team_country"`
	AwayTeam                string           `db:"away_team" json:"away_team"`
	AwayTeamCountry         pgtype.Text      `db:"away_team_country" json:"away_team_country"`
	LeagueName              string           `db:"league_name" json:"league_name"`
	LeagueCountry           pgtype.Text      `db:"league_country" json:"league_country"`
	SportName               string           `db:"sport_name" json:"sport_name"`
	SportCode               string           `db:"sport_code" json:"sport_code"`
}

// Get recent significant odds movements across all events
func (q *Queries) GetRecentMovements(ctx context.Context, arg GetRecentMovementsParams) ([]GetRecentMovementsRow, error) {
	rows, err := q.db.Query(ctx, getRecentMovements, arg.SinceTime, arg.MinChangePercentage, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentMovementsRow{}
	for rows.Next() {
		var i GetRecentMovementsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.RecordedAt,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.EventSlug,
			&i.EventDate,
			&i.EventStatus,
			&i.IsLive,
			&i.HomeScore,
			&i.AwayScore,
			&i.MinuteOfMatch,
			&i.BettingVolumePercentage,
			&i.MarketCode,
			&i.MarketName,
			&i.MarketDescription,
			&i.HomeTeam,
			&i.HomeTeamCountry,
			&i.AwayTeam,
			&i.AwayTeamCountry,
			&i.LeagueName,
			&i.LeagueCountry,
			&i.SportName,
			&i.SportCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSuspiciousMovements = `-- name: GetSuspiciousMovements :many
SELECT 
    oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.recorded_at, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff,
    e.slug as event_slug,
    mt.code as market_code
FROM odds_history oh
JOIN events e ON oh.event_id = e.id
JOIN market_types mt ON oh.market_type_id = mt.id
WHERE oh.multiplier > 1.5 OR oh.multiplier < 0.67
AND oh.recorded_at > $1
ORDER BY CASE 
    WHEN oh.multiplier > 1.0 THEN oh.multiplier
    ELSE (1.0 / oh.multiplier)
END DESC
LIMIT $2
`

type GetSuspiciousMovementsParams struct {
	SinceTime  pgtype.Timestamp `db:"since_time" json:"since_time"`
	LimitCount int32            `db:"limit_count" json:"limit_count"`
}

type GetSuspiciousMovementsRow struct {
	ID                  int32            `db:"id" json:"id"`
	EventID             pgtype.Int4      `db:"event_id" json:"event_id"`
	MarketTypeID        pgtype.Int4      `db:"market_type_id" json:"market_type_id"`
	Outcome             string           `db:"outcome" json:"outcome"`
	OddsValue           pgtype.Numeric   `db:"odds_value" json:"odds_value"`
	PreviousValue       pgtype.Numeric   `db:"previous_value" json:"previous_value"`
	WinningOdds         pgtype.Numeric   `db:"winning_odds" json:"winning_odds"`
	ChangeAmount        pgtype.Numeric   `db:"change_amount" json:"change_amount"`
	ChangePercentage    pgtype.Numeric   `db:"change_percentage" json:"change_percentage"`
	Multiplier          pgtype.Numeric   `db:"multiplier" json:"multiplier"`
	RecordedAt          pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	SharpMoneyIndicator pgtype.Numeric   `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement   pgtype.Bool      `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel   pgtype.Text      `db:"significance_level" json:"significance_level"`
	MinutesToKickoff    pgtype.Int4      `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	EventSlug           string           `db:"event_slug" json:"event_slug"`
	MarketCode          string           `db:"market_code" json:"market_code"`
}

// Get potentially suspicious odds movements (sharp money indicators)
func (q *Queries) GetSuspiciousMovements(ctx context.Context, arg GetSuspiciousMovementsParams) ([]GetSuspiciousMovementsRow, error) {
	rows, err := q.db.Query(ctx, getSuspiciousMovements, arg.SinceTime, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSuspiciousMovementsRow{}
	for rows.Next() {
		var i GetSuspiciousMovementsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.RecordedAt,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.EventSlug,
			&i.MarketCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
