// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: volume.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const analyzeVolumeOddsPattern = `-- name: AnalyzeVolumeOddsPattern :one
WITH patterns AS (
    SELECT 
        CASE 
            WHEN e.betting_volume_percentage > 5 AND MAX(ABS(co.movement_percentage)) > 30 THEN 'HIGH_VOLUME_HIGH_MOVEMENT'
            WHEN e.betting_volume_percentage > 5 AND MAX(ABS(co.movement_percentage)) < 10 THEN 'HIGH_VOLUME_STABLE'
            WHEN e.betting_volume_percentage < 1 AND MAX(ABS(co.movement_percentage)) > 30 THEN 'LOW_VOLUME_HIGH_MOVEMENT'
            WHEN e.betting_volume_percentage < 1 AND MAX(ABS(co.movement_percentage)) < 10 THEN 'LOW_VOLUME_STABLE'
            ELSE 'MODERATE'
        END as pattern,
        COUNT(*) as event_count,
        AVG(e.betting_volume_percentage) as avg_volume,
        AVG(MAX(ABS(co.movement_percentage))) as avg_movement
    FROM events e
    LEFT JOIN current_odds co ON co.event_id = e.id
    WHERE e.volume_updated_at > CURRENT_TIMESTAMP - INTERVAL '24 hours'
    GROUP BY e.id, e.betting_volume_percentage
)
SELECT 
    json_object_agg(
        pattern,
        json_build_object(
            'count', event_count,
            'avg_volume', ROUND(avg_volume, 2),
            'avg_movement', ROUND(avg_movement, 2)
        )
    ) as analysis
FROM (
    SELECT 
        pattern,
        SUM(event_count) as event_count,
        AVG(avg_volume) as avg_volume,
        AVG(avg_movement) as avg_movement
    FROM patterns
    GROUP BY pattern
) summary
`

// Analyze correlation between volume and odds movement
func (q *Queries) AnalyzeVolumeOddsPattern(ctx context.Context) ([]byte, error) {
	row := q.db.QueryRow(ctx, analyzeVolumeOddsPattern)
	var analysis []byte
	err := row.Scan(&analysis)
	return analysis, err
}

const createVolumeHistory = `-- name: CreateVolumeHistory :one
INSERT INTO betting_volume_history (
    event_id,
    volume_percentage,
    rank_position,
    total_events_tracked
) VALUES (
    $1,
    $2,
    $3,
    $4
)
RETURNING id, event_id, volume_percentage, rank_position, total_events_tracked, recorded_at
`

type CreateVolumeHistoryParams struct {
	EventID            pgtype.Int4    `db:"event_id" json:"event_id"`
	VolumePercentage   pgtype.Numeric `db:"volume_percentage" json:"volume_percentage"`
	RankPosition       pgtype.Int4    `db:"rank_position" json:"rank_position"`
	TotalEventsTracked pgtype.Int4    `db:"total_events_tracked" json:"total_events_tracked"`
}

func (q *Queries) CreateVolumeHistory(ctx context.Context, arg CreateVolumeHistoryParams) (BettingVolumeHistory, error) {
	row := q.db.QueryRow(ctx, createVolumeHistory,
		arg.EventID,
		arg.VolumePercentage,
		arg.RankPosition,
		arg.TotalEventsTracked,
	)
	var i BettingVolumeHistory
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.VolumePercentage,
		&i.RankPosition,
		&i.TotalEventsTracked,
		&i.RecordedAt,
	)
	return i, err
}

const getHiddenGems = `-- name: GetHiddenGems :many
SELECT 
    e.slug,
    ht.name || ' vs ' || at.name as match_name,
    e.betting_volume_percentage,
    COALESCE(MAX(ABS(co.movement_percentage)), 0) as max_movement
FROM events e
JOIN teams ht ON e.home_team_id = ht.id
JOIN teams at ON e.away_team_id = at.id
LEFT JOIN current_odds co ON co.event_id = e.id
WHERE e.betting_volume_percentage <= $1
  AND e.betting_volume_percentage > 0
  AND e.event_date > CURRENT_TIMESTAMP
GROUP BY e.id, e.slug, ht.name, at.name, e.betting_volume_percentage
HAVING COALESCE(MAX(ABS(co.movement_percentage)), 0) >= $2
ORDER BY MAX(ABS(co.movement_percentage)) DESC
LIMIT 20
`

type GetHiddenGemsParams struct {
	MaxVolume   pgtype.Numeric `db:"max_volume" json:"max_volume"`
	MinMovement pgtype.Numeric `db:"min_movement" json:"min_movement"`
}

type GetHiddenGemsRow struct {
	Slug                    string         `db:"slug" json:"slug"`
	MatchName               interface{}    `db:"match_name" json:"match_name"`
	BettingVolumePercentage pgtype.Numeric `db:"betting_volume_percentage" json:"betting_volume_percentage"`
	MaxMovement             interface{}    `db:"max_movement" json:"max_movement"`
}

// Find low-volume events with big movements (potential sharp money)
func (q *Queries) GetHiddenGems(ctx context.Context, arg GetHiddenGemsParams) ([]GetHiddenGemsRow, error) {
	rows, err := q.db.Query(ctx, getHiddenGems, arg.MaxVolume, arg.MinMovement)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHiddenGemsRow{}
	for rows.Next() {
		var i GetHiddenGemsRow
		if err := rows.Scan(
			&i.Slug,
			&i.MatchName,
			&i.BettingVolumePercentage,
			&i.MaxMovement,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHotMovers = `-- name: GetHotMovers :many
SELECT 
    e.slug,
    ht.name || ' vs ' || at.name as match_name,
    e.betting_volume_percentage,
    e.volume_rank,
    COALESCE(MAX(ABS(co.movement_percentage)), 0) as max_movement,
    CASE 
        WHEN e.betting_volume_percentage > 5 THEN 'HOT'
        WHEN e.betting_volume_percentage > 2 THEN 'POPULAR'
        WHEN e.betting_volume_percentage > 1 THEN 'MODERATE'
        ELSE 'COLD'
    END as popularity_level,
    CASE 
        WHEN e.betting_volume_percentage > 5 AND MAX(ABS(co.movement_percentage)) > 50 THEN 'HOT_MOVER'
        WHEN e.betting_volume_percentage < 1 AND MAX(ABS(co.movement_percentage)) > 50 THEN 'HIDDEN_GEM'
        WHEN e.betting_volume_percentage > 5 AND MAX(ABS(co.movement_percentage)) < 10 THEN 'STABLE_FAVORITE'
        ELSE 'NORMAL'
    END as event_type
FROM events e
JOIN teams ht ON e.home_team_id = ht.id
JOIN teams at ON e.away_team_id = at.id
LEFT JOIN current_odds co ON co.event_id = e.id
WHERE e.betting_volume_percentage >= $1
  AND e.event_date > CURRENT_TIMESTAMP
GROUP BY e.id, e.slug, ht.name, at.name, e.betting_volume_percentage, e.volume_rank
HAVING COALESCE(MAX(ABS(co.movement_percentage)), 0) >= $2
ORDER BY e.betting_volume_percentage DESC
LIMIT 50
`

type GetHotMoversParams struct {
	MinVolume   pgtype.Numeric `db:"min_volume" json:"min_volume"`
	MinMovement pgtype.Numeric `db:"min_movement" json:"min_movement"`
}

type GetHotMoversRow struct {
	Slug                    string         `db:"slug" json:"slug"`
	MatchName               interface{}    `db:"match_name" json:"match_name"`
	BettingVolumePercentage pgtype.Numeric `db:"betting_volume_percentage" json:"betting_volume_percentage"`
	VolumeRank              pgtype.Int4    `db:"volume_rank" json:"volume_rank"`
	MaxMovement             interface{}    `db:"max_movement" json:"max_movement"`
	PopularityLevel         string         `db:"popularity_level" json:"popularity_level"`
	EventType               string         `db:"event_type" json:"event_type"`
}

// Find events with high betting volume AND significant odds movement
func (q *Queries) GetHotMovers(ctx context.Context, arg GetHotMoversParams) ([]GetHotMoversRow, error) {
	rows, err := q.db.Query(ctx, getHotMovers, arg.MinVolume, arg.MinMovement)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHotMoversRow{}
	for rows.Next() {
		var i GetHotMoversRow
		if err := rows.Scan(
			&i.Slug,
			&i.MatchName,
			&i.BettingVolumePercentage,
			&i.VolumeRank,
			&i.MaxMovement,
			&i.PopularityLevel,
			&i.EventType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopVolumeEvents = `-- name: GetTopVolumeEvents :many
SELECT 
    e.slug,
    ht.name || ' vs ' || at.name as match_name,
    e.event_date,
    e.betting_volume_percentage,
    e.volume_rank,
    COUNT(DISTINCT oh.id) as total_odds_changes,
    COALESCE(MAX(ABS(co.movement_percentage)), 0) as max_movement
FROM events e
JOIN teams ht ON e.home_team_id = ht.id
JOIN teams at ON e.away_team_id = at.id
LEFT JOIN current_odds co ON co.event_id = e.id
LEFT JOIN odds_history oh ON oh.event_id = e.id
WHERE e.volume_rank <= 20
  AND e.event_date > CURRENT_TIMESTAMP
GROUP BY e.id, e.slug, ht.name, at.name, e.event_date, e.betting_volume_percentage, e.volume_rank
ORDER BY e.volume_rank
`

type GetTopVolumeEventsRow struct {
	Slug                    string           `db:"slug" json:"slug"`
	MatchName               interface{}      `db:"match_name" json:"match_name"`
	EventDate               pgtype.Timestamp `db:"event_date" json:"event_date"`
	BettingVolumePercentage pgtype.Numeric   `db:"betting_volume_percentage" json:"betting_volume_percentage"`
	VolumeRank              pgtype.Int4      `db:"volume_rank" json:"volume_rank"`
	TotalOddsChanges        int64            `db:"total_odds_changes" json:"total_odds_changes"`
	MaxMovement             interface{}      `db:"max_movement" json:"max_movement"`
}

// Get current top events by betting volume
func (q *Queries) GetTopVolumeEvents(ctx context.Context) ([]GetTopVolumeEventsRow, error) {
	rows, err := q.db.Query(ctx, getTopVolumeEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopVolumeEventsRow{}
	for rows.Next() {
		var i GetTopVolumeEventsRow
		if err := rows.Scan(
			&i.Slug,
			&i.MatchName,
			&i.EventDate,
			&i.BettingVolumePercentage,
			&i.VolumeRank,
			&i.TotalOddsChanges,
			&i.MaxMovement,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVolumeHistory = `-- name: GetVolumeHistory :many
SELECT 
    bvh.id, bvh.event_id, bvh.volume_percentage, bvh.rank_position, bvh.total_events_tracked, bvh.recorded_at,
    LAG(bvh.volume_percentage) OVER (ORDER BY bvh.recorded_at) as previous_volume,
    bvh.volume_percentage - LAG(bvh.volume_percentage) OVER (ORDER BY bvh.recorded_at) as volume_change
FROM betting_volume_history bvh
WHERE bvh.event_id = $1
ORDER BY bvh.recorded_at DESC
LIMIT 100
`

type GetVolumeHistoryRow struct {
	ID                 int32            `db:"id" json:"id"`
	EventID            pgtype.Int4      `db:"event_id" json:"event_id"`
	VolumePercentage   pgtype.Numeric   `db:"volume_percentage" json:"volume_percentage"`
	RankPosition       pgtype.Int4      `db:"rank_position" json:"rank_position"`
	TotalEventsTracked pgtype.Int4      `db:"total_events_tracked" json:"total_events_tracked"`
	RecordedAt         pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	PreviousVolume     interface{}      `db:"previous_volume" json:"previous_volume"`
	VolumeChange       int32            `db:"volume_change" json:"volume_change"`
}

// Get volume history for a specific event
func (q *Queries) GetVolumeHistory(ctx context.Context, eventID pgtype.Int4) ([]GetVolumeHistoryRow, error) {
	rows, err := q.db.Query(ctx, getVolumeHistory, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVolumeHistoryRow{}
	for rows.Next() {
		var i GetVolumeHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.VolumePercentage,
			&i.RankPosition,
			&i.TotalEventsTracked,
			&i.RecordedAt,
			&i.PreviousVolume,
			&i.VolumeChange,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEventVolume = `-- name: UpdateEventVolume :one
UPDATE events 
SET 
    betting_volume_percentage = $1,
    volume_rank = $2,
    volume_updated_at = $3
WHERE id = $4
RETURNING id, external_id, competition_id, home_team_id, away_team_id, slug, event_date, status, home_score, away_score, is_live, minute_of_match, half, betting_volume_percentage, volume_rank, volume_updated_at, created_at, updated_at
`

type UpdateEventVolumeParams struct {
	BettingVolumePercentage pgtype.Numeric   `db:"betting_volume_percentage" json:"betting_volume_percentage"`
	VolumeRank              pgtype.Int4      `db:"volume_rank" json:"volume_rank"`
	VolumeUpdatedAt         pgtype.Timestamp `db:"volume_updated_at" json:"volume_updated_at"`
	ID                      int32            `db:"id" json:"id"`
}

func (q *Queries) UpdateEventVolume(ctx context.Context, arg UpdateEventVolumeParams) (Event, error) {
	row := q.db.QueryRow(ctx, updateEventVolume,
		arg.BettingVolumePercentage,
		arg.VolumeRank,
		arg.VolumeUpdatedAt,
		arg.ID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.CompetitionID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.Slug,
		&i.EventDate,
		&i.Status,
		&i.HomeScore,
		&i.AwayScore,
		&i.IsLive,
		&i.MinuteOfMatch,
		&i.Half,
		&i.BettingVolumePercentage,
		&i.VolumeRank,
		&i.VolumeUpdatedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
