// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: odds.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOddsHistory = `-- name: CreateOddsHistory :one
INSERT INTO odds_history (
    event_id, 
    market_type_id, 
    outcome, 
    odds_value, 
    previous_value,
    winning_odds,
    change_amount,
    change_percentage,
    multiplier
) VALUES (
    $1::int, 
    $2::int, 
    $3::text, 
    $4::decimal, 
    $5::decimal,
    $6::decimal,
    -- Calculate change amount: new_odds - previous_odds
    $4::decimal - $5::decimal,
    -- Calculate change percentage: ((new_odds - previous_odds) / previous_odds) * 100
    CASE 
        WHEN $5::decimal > 0 THEN 
            ROUND((($4::decimal - $5::decimal) / $5::decimal * 100), 2)
        ELSE 0 
    END,
    -- Calculate multiplier: new_odds / previous_odds
    CASE 
        WHEN $5::decimal > 0 THEN 
            ROUND(($4::decimal / $5::decimal), 3)
        ELSE 1 
    END
)
RETURNING id, event_id, market_type_id, outcome, odds_value, previous_value, winning_odds, change_amount, change_percentage, multiplier, recorded_at, sharp_money_indicator, is_reverse_movement, significance_level, minutes_to_kickoff
`

type CreateOddsHistoryParams struct {
	EventID       int32          `db:"event_id" json:"event_id"`
	MarketTypeID  int32          `db:"market_type_id" json:"market_type_id"`
	Outcome       string         `db:"outcome" json:"outcome"`
	OddsValue     pgtype.Numeric `db:"odds_value" json:"odds_value"`
	PreviousValue pgtype.Numeric `db:"previous_value" json:"previous_value"`
	WinningOdds   pgtype.Numeric `db:"winning_odds" json:"winning_odds"`
}

func (q *Queries) CreateOddsHistory(ctx context.Context, arg CreateOddsHistoryParams) (OddsHistory, error) {
	row := q.db.QueryRow(ctx, createOddsHistory,
		arg.EventID,
		arg.MarketTypeID,
		arg.Outcome,
		arg.OddsValue,
		arg.PreviousValue,
		arg.WinningOdds,
	)
	var i OddsHistory
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.MarketTypeID,
		&i.Outcome,
		&i.OddsValue,
		&i.PreviousValue,
		&i.WinningOdds,
		&i.ChangeAmount,
		&i.ChangePercentage,
		&i.Multiplier,
		&i.RecordedAt,
		&i.SharpMoneyIndicator,
		&i.IsReverseMovement,
		&i.SignificanceLevel,
		&i.MinutesToKickoff,
	)
	return i, err
}

const getBigMovers = `-- name: GetBigMovers :many
SELECT 
    oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.recorded_at, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff,
    e.slug as event_slug,
    mt.code as market_code
FROM odds_history oh
JOIN events e ON oh.event_id = e.id
JOIN market_types mt ON oh.market_type_id = mt.id
WHERE ABS(oh.change_percentage) > $1::decimal
AND oh.recorded_at > $2::timestamp
ORDER BY ABS(oh.change_percentage) DESC
LIMIT $3::int
`

type GetBigMoversParams struct {
	MinChangePct pgtype.Numeric   `db:"min_change_pct" json:"min_change_pct"`
	SinceTime    pgtype.Timestamp `db:"since_time" json:"since_time"`
	LimitCount   int32            `db:"limit_count" json:"limit_count"`
}

type GetBigMoversRow struct {
	ID                  int32            `db:"id" json:"id"`
	EventID             pgtype.Int4      `db:"event_id" json:"event_id"`
	MarketTypeID        pgtype.Int4      `db:"market_type_id" json:"market_type_id"`
	Outcome             string           `db:"outcome" json:"outcome"`
	OddsValue           pgtype.Numeric   `db:"odds_value" json:"odds_value"`
	PreviousValue       pgtype.Numeric   `db:"previous_value" json:"previous_value"`
	WinningOdds         pgtype.Numeric   `db:"winning_odds" json:"winning_odds"`
	ChangeAmount        pgtype.Numeric   `db:"change_amount" json:"change_amount"`
	ChangePercentage    pgtype.Numeric   `db:"change_percentage" json:"change_percentage"`
	Multiplier          pgtype.Numeric   `db:"multiplier" json:"multiplier"`
	RecordedAt          pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	SharpMoneyIndicator pgtype.Numeric   `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement   pgtype.Bool      `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel   pgtype.Text      `db:"significance_level" json:"significance_level"`
	MinutesToKickoff    pgtype.Int4      `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	EventSlug           string           `db:"event_slug" json:"event_slug"`
	MarketCode          string           `db:"market_code" json:"market_code"`
}

func (q *Queries) GetBigMovers(ctx context.Context, arg GetBigMoversParams) ([]GetBigMoversRow, error) {
	rows, err := q.db.Query(ctx, getBigMovers, arg.MinChangePct, arg.SinceTime, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBigMoversRow{}
	for rows.Next() {
		var i GetBigMoversRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.RecordedAt,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.EventSlug,
			&i.MarketCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentOdds = `-- name: GetCurrentOdds :many
SELECT co.id, co.event_id, co.market_type_id, co.outcome, co.odds_value, co.opening_value, co.highest_value, co.lowest_value, co.winning_odds, co.total_movement, co.movement_percentage, co.last_updated, mt.name as market_name, mt.code as market_code
FROM current_odds co
JOIN market_types mt ON co.market_type_id = mt.id
WHERE co.event_id = $1::int
`

type GetCurrentOddsRow struct {
	ID                 int32            `db:"id" json:"id"`
	EventID            pgtype.Int4      `db:"event_id" json:"event_id"`
	MarketTypeID       pgtype.Int4      `db:"market_type_id" json:"market_type_id"`
	Outcome            string           `db:"outcome" json:"outcome"`
	OddsValue          pgtype.Numeric   `db:"odds_value" json:"odds_value"`
	OpeningValue       pgtype.Numeric   `db:"opening_value" json:"opening_value"`
	HighestValue       pgtype.Numeric   `db:"highest_value" json:"highest_value"`
	LowestValue        pgtype.Numeric   `db:"lowest_value" json:"lowest_value"`
	WinningOdds        pgtype.Numeric   `db:"winning_odds" json:"winning_odds"`
	TotalMovement      pgtype.Numeric   `db:"total_movement" json:"total_movement"`
	MovementPercentage pgtype.Numeric   `db:"movement_percentage" json:"movement_percentage"`
	LastUpdated        pgtype.Timestamp `db:"last_updated" json:"last_updated"`
	MarketName         string           `db:"market_name" json:"market_name"`
	MarketCode         string           `db:"market_code" json:"market_code"`
}

func (q *Queries) GetCurrentOdds(ctx context.Context, eventID int32) ([]GetCurrentOddsRow, error) {
	rows, err := q.db.Query(ctx, getCurrentOdds, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCurrentOddsRow{}
	for rows.Next() {
		var i GetCurrentOddsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.OpeningValue,
			&i.HighestValue,
			&i.LowestValue,
			&i.WinningOdds,
			&i.TotalMovement,
			&i.MovementPercentage,
			&i.LastUpdated,
			&i.MarketName,
			&i.MarketCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentOddsByMarket = `-- name: GetCurrentOddsByMarket :many
SELECT co.id, co.event_id, co.market_type_id, co.outcome, co.odds_value, co.opening_value, co.highest_value, co.lowest_value, co.winning_odds, co.total_movement, co.movement_percentage, co.last_updated, mt.name as market_name, mt.code as market_code
FROM current_odds co
JOIN market_types mt ON co.market_type_id = mt.id
WHERE co.event_id = $1::int 
AND co.market_type_id = $2::int
`

type GetCurrentOddsByMarketParams struct {
	EventID      int32 `db:"event_id" json:"event_id"`
	MarketTypeID int32 `db:"market_type_id" json:"market_type_id"`
}

type GetCurrentOddsByMarketRow struct {
	ID                 int32            `db:"id" json:"id"`
	EventID            pgtype.Int4      `db:"event_id" json:"event_id"`
	MarketTypeID       pgtype.Int4      `db:"market_type_id" json:"market_type_id"`
	Outcome            string           `db:"outcome" json:"outcome"`
	OddsValue          pgtype.Numeric   `db:"odds_value" json:"odds_value"`
	OpeningValue       pgtype.Numeric   `db:"opening_value" json:"opening_value"`
	HighestValue       pgtype.Numeric   `db:"highest_value" json:"highest_value"`
	LowestValue        pgtype.Numeric   `db:"lowest_value" json:"lowest_value"`
	WinningOdds        pgtype.Numeric   `db:"winning_odds" json:"winning_odds"`
	TotalMovement      pgtype.Numeric   `db:"total_movement" json:"total_movement"`
	MovementPercentage pgtype.Numeric   `db:"movement_percentage" json:"movement_percentage"`
	LastUpdated        pgtype.Timestamp `db:"last_updated" json:"last_updated"`
	MarketName         string           `db:"market_name" json:"market_name"`
	MarketCode         string           `db:"market_code" json:"market_code"`
}

func (q *Queries) GetCurrentOddsByMarket(ctx context.Context, arg GetCurrentOddsByMarketParams) ([]GetCurrentOddsByMarketRow, error) {
	rows, err := q.db.Query(ctx, getCurrentOddsByMarket, arg.EventID, arg.MarketTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCurrentOddsByMarketRow{}
	for rows.Next() {
		var i GetCurrentOddsByMarketRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.OpeningValue,
			&i.HighestValue,
			&i.LowestValue,
			&i.WinningOdds,
			&i.TotalMovement,
			&i.MovementPercentage,
			&i.LastUpdated,
			&i.MarketName,
			&i.MarketCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentOddsByOutcome = `-- name: GetCurrentOddsByOutcome :one
SELECT co.id, co.event_id, co.market_type_id, co.outcome, co.odds_value, co.opening_value, co.highest_value, co.lowest_value, co.winning_odds, co.total_movement, co.movement_percentage, co.last_updated, mt.name as market_name, mt.code as market_code
FROM current_odds co
JOIN market_types mt ON co.market_type_id = mt.id
WHERE co.event_id = $1::int 
AND co.market_type_id = $2::int
AND co.outcome = $3::text
`

type GetCurrentOddsByOutcomeParams struct {
	EventID      int32  `db:"event_id" json:"event_id"`
	MarketTypeID int32  `db:"market_type_id" json:"market_type_id"`
	Outcome      string `db:"outcome" json:"outcome"`
}

type GetCurrentOddsByOutcomeRow struct {
	ID                 int32            `db:"id" json:"id"`
	EventID            pgtype.Int4      `db:"event_id" json:"event_id"`
	MarketTypeID       pgtype.Int4      `db:"market_type_id" json:"market_type_id"`
	Outcome            string           `db:"outcome" json:"outcome"`
	OddsValue          pgtype.Numeric   `db:"odds_value" json:"odds_value"`
	OpeningValue       pgtype.Numeric   `db:"opening_value" json:"opening_value"`
	HighestValue       pgtype.Numeric   `db:"highest_value" json:"highest_value"`
	LowestValue        pgtype.Numeric   `db:"lowest_value" json:"lowest_value"`
	WinningOdds        pgtype.Numeric   `db:"winning_odds" json:"winning_odds"`
	TotalMovement      pgtype.Numeric   `db:"total_movement" json:"total_movement"`
	MovementPercentage pgtype.Numeric   `db:"movement_percentage" json:"movement_percentage"`
	LastUpdated        pgtype.Timestamp `db:"last_updated" json:"last_updated"`
	MarketName         string           `db:"market_name" json:"market_name"`
	MarketCode         string           `db:"market_code" json:"market_code"`
}

func (q *Queries) GetCurrentOddsByOutcome(ctx context.Context, arg GetCurrentOddsByOutcomeParams) (GetCurrentOddsByOutcomeRow, error) {
	row := q.db.QueryRow(ctx, getCurrentOddsByOutcome, arg.EventID, arg.MarketTypeID, arg.Outcome)
	var i GetCurrentOddsByOutcomeRow
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.MarketTypeID,
		&i.Outcome,
		&i.OddsValue,
		&i.OpeningValue,
		&i.HighestValue,
		&i.LowestValue,
		&i.WinningOdds,
		&i.TotalMovement,
		&i.MovementPercentage,
		&i.LastUpdated,
		&i.MarketName,
		&i.MarketCode,
	)
	return i, err
}

const getOddsHistoryByID = `-- name: GetOddsHistoryByID :one
SELECT id, event_id, market_type_id, outcome, odds_value, previous_value, winning_odds, change_amount, change_percentage, multiplier, recorded_at, sharp_money_indicator, is_reverse_movement, significance_level, minutes_to_kickoff FROM odds_history WHERE id = $1::bigint
`

func (q *Queries) GetOddsHistoryByID(ctx context.Context, id int64) (OddsHistory, error) {
	row := q.db.QueryRow(ctx, getOddsHistoryByID, id)
	var i OddsHistory
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.MarketTypeID,
		&i.Outcome,
		&i.OddsValue,
		&i.PreviousValue,
		&i.WinningOdds,
		&i.ChangeAmount,
		&i.ChangePercentage,
		&i.Multiplier,
		&i.RecordedAt,
		&i.SharpMoneyIndicator,
		&i.IsReverseMovement,
		&i.SignificanceLevel,
		&i.MinutesToKickoff,
	)
	return i, err
}

const getOddsMovements = `-- name: GetOddsMovements :many
SELECT oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.recorded_at, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff, mt.name as market_name, mt.code as market_code
FROM odds_history oh
JOIN market_types mt ON oh.market_type_id = mt.id
WHERE oh.event_id = $1::int
ORDER BY oh.recorded_at DESC
LIMIT $2::int
`

type GetOddsMovementsParams struct {
	EventID    int32 `db:"event_id" json:"event_id"`
	LimitCount int32 `db:"limit_count" json:"limit_count"`
}

type GetOddsMovementsRow struct {
	ID                  int32            `db:"id" json:"id"`
	EventID             pgtype.Int4      `db:"event_id" json:"event_id"`
	MarketTypeID        pgtype.Int4      `db:"market_type_id" json:"market_type_id"`
	Outcome             string           `db:"outcome" json:"outcome"`
	OddsValue           pgtype.Numeric   `db:"odds_value" json:"odds_value"`
	PreviousValue       pgtype.Numeric   `db:"previous_value" json:"previous_value"`
	WinningOdds         pgtype.Numeric   `db:"winning_odds" json:"winning_odds"`
	ChangeAmount        pgtype.Numeric   `db:"change_amount" json:"change_amount"`
	ChangePercentage    pgtype.Numeric   `db:"change_percentage" json:"change_percentage"`
	Multiplier          pgtype.Numeric   `db:"multiplier" json:"multiplier"`
	RecordedAt          pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	SharpMoneyIndicator pgtype.Numeric   `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement   pgtype.Bool      `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel   pgtype.Text      `db:"significance_level" json:"significance_level"`
	MinutesToKickoff    pgtype.Int4      `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	MarketName          string           `db:"market_name" json:"market_name"`
	MarketCode          string           `db:"market_code" json:"market_code"`
}

func (q *Queries) GetOddsMovements(ctx context.Context, arg GetOddsMovementsParams) ([]GetOddsMovementsRow, error) {
	rows, err := q.db.Query(ctx, getOddsMovements, arg.EventID, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOddsMovementsRow{}
	for rows.Next() {
		var i GetOddsMovementsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.RecordedAt,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.MarketName,
			&i.MarketCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentOddsHistory = `-- name: GetRecentOddsHistory :many
SELECT oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.recorded_at, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff, e.event_date, e.is_live, mt.name as market_name, mt.code as market_code
FROM odds_history oh
JOIN events e ON oh.event_id = e.id
JOIN market_types mt ON oh.market_type_id = mt.id
WHERE oh.recorded_at >= $1::timestamp
AND e.event_date > NOW()
AND ABS(oh.change_percentage) >= $2::decimal
ORDER BY oh.recorded_at DESC
LIMIT $3::int
`

type GetRecentOddsHistoryParams struct {
	SinceTime    pgtype.Timestamp `db:"since_time" json:"since_time"`
	MinChangePct pgtype.Numeric   `db:"min_change_pct" json:"min_change_pct"`
	LimitCount   int32            `db:"limit_count" json:"limit_count"`
}

type GetRecentOddsHistoryRow struct {
	ID                  int32            `db:"id" json:"id"`
	EventID             pgtype.Int4      `db:"event_id" json:"event_id"`
	MarketTypeID        pgtype.Int4      `db:"market_type_id" json:"market_type_id"`
	Outcome             string           `db:"outcome" json:"outcome"`
	OddsValue           pgtype.Numeric   `db:"odds_value" json:"odds_value"`
	PreviousValue       pgtype.Numeric   `db:"previous_value" json:"previous_value"`
	WinningOdds         pgtype.Numeric   `db:"winning_odds" json:"winning_odds"`
	ChangeAmount        pgtype.Numeric   `db:"change_amount" json:"change_amount"`
	ChangePercentage    pgtype.Numeric   `db:"change_percentage" json:"change_percentage"`
	Multiplier          pgtype.Numeric   `db:"multiplier" json:"multiplier"`
	RecordedAt          pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	SharpMoneyIndicator pgtype.Numeric   `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement   pgtype.Bool      `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel   pgtype.Text      `db:"significance_level" json:"significance_level"`
	MinutesToKickoff    pgtype.Int4      `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	EventDate           pgtype.Timestamp `db:"event_date" json:"event_date"`
	IsLive              pgtype.Bool      `db:"is_live" json:"is_live"`
	MarketName          string           `db:"market_name" json:"market_name"`
	MarketCode          string           `db:"market_code" json:"market_code"`
}

func (q *Queries) GetRecentOddsHistory(ctx context.Context, arg GetRecentOddsHistoryParams) ([]GetRecentOddsHistoryRow, error) {
	rows, err := q.db.Query(ctx, getRecentOddsHistory, arg.SinceTime, arg.MinChangePct, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentOddsHistoryRow{}
	for rows.Next() {
		var i GetRecentOddsHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.RecordedAt,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.EventDate,
			&i.IsLive,
			&i.MarketName,
			&i.MarketCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertCurrentOdds = `-- name: UpsertCurrentOdds :one
INSERT INTO current_odds (
    event_id, 
    market_type_id, 
    outcome, 
    odds_value, 
    opening_value, 
    highest_value, 
    lowest_value,
    winning_odds,
    total_movement,
    movement_percentage
) VALUES (
    $1::int, 
    $2::int, 
    $3::text, 
    $4::decimal, 
    $5::decimal, 
    $6::decimal, 
    $7::decimal,
    $8::decimal,
    0, -- First time, no movement
    0  -- First time, no movement percentage
)
ON CONFLICT (event_id, market_type_id, outcome) DO UPDATE SET
    odds_value = EXCLUDED.odds_value,
    winning_odds = EXCLUDED.winning_odds,
    highest_value = GREATEST(current_odds.highest_value, EXCLUDED.odds_value),
    lowest_value = LEAST(current_odds.lowest_value, EXCLUDED.odds_value),
    -- Calculate movement: new_odds - opening_odds
    total_movement = EXCLUDED.odds_value - current_odds.opening_value,
    -- Calculate movement percentage: ((new_odds - opening_odds) / opening_odds) * 100
    movement_percentage = CASE 
        WHEN current_odds.opening_value > 0 THEN 
            ROUND(((EXCLUDED.odds_value - current_odds.opening_value) / current_odds.opening_value * 100)::numeric, 2)
        ELSE 0 
    END,
    last_updated = CURRENT_TIMESTAMP
RETURNING id, event_id, market_type_id, outcome, odds_value, opening_value, highest_value, lowest_value, winning_odds, total_movement, movement_percentage, last_updated
`

type UpsertCurrentOddsParams struct {
	EventID      int32          `db:"event_id" json:"event_id"`
	MarketTypeID int32          `db:"market_type_id" json:"market_type_id"`
	Outcome      string         `db:"outcome" json:"outcome"`
	OddsValue    pgtype.Numeric `db:"odds_value" json:"odds_value"`
	OpeningValue pgtype.Numeric `db:"opening_value" json:"opening_value"`
	HighestValue pgtype.Numeric `db:"highest_value" json:"highest_value"`
	LowestValue  pgtype.Numeric `db:"lowest_value" json:"lowest_value"`
	WinningOdds  pgtype.Numeric `db:"winning_odds" json:"winning_odds"`
}

func (q *Queries) UpsertCurrentOdds(ctx context.Context, arg UpsertCurrentOddsParams) (CurrentOdd, error) {
	row := q.db.QueryRow(ctx, upsertCurrentOdds,
		arg.EventID,
		arg.MarketTypeID,
		arg.Outcome,
		arg.OddsValue,
		arg.OpeningValue,
		arg.HighestValue,
		arg.LowestValue,
		arg.WinningOdds,
	)
	var i CurrentOdd
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.MarketTypeID,
		&i.Outcome,
		&i.OddsValue,
		&i.OpeningValue,
		&i.HighestValue,
		&i.LowestValue,
		&i.WinningOdds,
		&i.TotalMovement,
		&i.MovementPercentage,
		&i.LastUpdated,
	)
	return i, err
}
