// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: smart_money.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMovementAlert = `-- name: CreateMovementAlert :one
INSERT INTO movement_alerts (
    odds_history_id,
    alert_type,
    severity,
    title,
    message,
    change_percentage,
    multiplier,
    confidence_score,
    minutes_to_kickoff,
    expires_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    CURRENT_TIMESTAMP + INTERVAL '24 hours'
)
ON CONFLICT (odds_history_id, alert_type) DO UPDATE SET
    severity = EXCLUDED.severity,
    title = EXCLUDED.title,
    message = EXCLUDED.message,
    change_percentage = EXCLUDED.change_percentage,
    multiplier = EXCLUDED.multiplier,
    confidence_score = EXCLUDED.confidence_score,
    minutes_to_kickoff = EXCLUDED.minutes_to_kickoff,
    expires_at = CURRENT_TIMESTAMP + INTERVAL '24 hours',
    updated_at = CURRENT_TIMESTAMP
RETURNING id, odds_history_id, alert_type, severity, title, message, change_percentage, multiplier, confidence_score, minutes_to_kickoff, created_at, expires_at, is_active, views, clicks
`

type CreateMovementAlertParams struct {
	OddsHistoryID    int32          `db:"odds_history_id" json:"odds_history_id"`
	AlertType        string         `db:"alert_type" json:"alert_type"`
	Severity         string         `db:"severity" json:"severity"`
	Title            string         `db:"title" json:"title"`
	Message          string         `db:"message" json:"message"`
	ChangePercentage pgtype.Numeric `db:"change_percentage" json:"change_percentage"`
	Multiplier       pgtype.Numeric `db:"multiplier" json:"multiplier"`
	ConfidenceScore  pgtype.Numeric `db:"confidence_score" json:"confidence_score"`
	MinutesToKickoff pgtype.Int4    `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
}

func (q *Queries) CreateMovementAlert(ctx context.Context, arg CreateMovementAlertParams) (MovementAlert, error) {
	row := q.db.QueryRow(ctx, createMovementAlert,
		arg.OddsHistoryID,
		arg.AlertType,
		arg.Severity,
		arg.Title,
		arg.Message,
		arg.ChangePercentage,
		arg.Multiplier,
		arg.ConfidenceScore,
		arg.MinutesToKickoff,
	)
	var i MovementAlert
	err := row.Scan(
		&i.ID,
		&i.OddsHistoryID,
		&i.AlertType,
		&i.Severity,
		&i.Title,
		&i.Message,
		&i.ChangePercentage,
		&i.Multiplier,
		&i.ConfidenceScore,
		&i.MinutesToKickoff,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.Views,
		&i.Clicks,
	)
	return i, err
}

const deactivateExpiredAlerts = `-- name: DeactivateExpiredAlerts :exec
UPDATE movement_alerts 
SET is_active = false 
WHERE expires_at <= NOW() AND is_active = true
`

func (q *Queries) DeactivateExpiredAlerts(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deactivateExpiredAlerts)
	return err
}

const getActiveAlerts = `-- name: GetActiveAlerts :many
SELECT 
    ma.id, ma.odds_history_id, ma.alert_type, ma.severity, ma.title, ma.message, ma.change_percentage, ma.multiplier, ma.confidence_score, ma.minutes_to_kickoff, ma.created_at, ma.expires_at, ma.is_active, ma.views, ma.clicks,
    oh.event_id,
    oh.market_type_id,
    oh.outcome,
    e.external_id as event_external_id,
    e.event_date,
    e.home_team_id,
    e.away_team_id,
    ht.name as home_team_name,
    at.name as away_team_name,
    mt.code as market_code,
    mt.name as market_name
FROM movement_alerts ma
JOIN odds_history oh ON ma.odds_history_id = oh.id
JOIN events e ON oh.event_id = e.id
LEFT JOIN teams ht ON e.home_team_id = ht.id
LEFT JOIN teams at ON e.away_team_id = at.id
JOIN market_types mt ON oh.market_type_id = mt.id
WHERE 
    ma.is_active = true
    AND ma.expires_at > NOW()
    AND ($1 = '' OR ma.alert_type = $1)
    AND ($2 = '' OR 
         (ma.severity = 'critical' AND $2 IN ('low', 'medium', 'high', 'critical')) OR
         (ma.severity = 'high' AND $2 IN ('low', 'medium', 'high')) OR
         (ma.severity = 'medium' AND $2 IN ('low', 'medium')) OR
         (ma.severity = 'low' AND $2 = 'low'))
ORDER BY 
    CASE ma.severity 
        WHEN 'critical' THEN 4
        WHEN 'high' THEN 3
        WHEN 'medium' THEN 2
        ELSE 1
    END DESC,
    ma.created_at DESC
LIMIT $3
`

type GetActiveAlertsParams struct {
	AlertType   interface{} `db:"alert_type" json:"alert_type"`
	MinSeverity interface{} `db:"min_severity" json:"min_severity"`
	LimitCount  int32       `db:"limit_count" json:"limit_count"`
}

type GetActiveAlertsRow struct {
	ID               int32            `db:"id" json:"id"`
	OddsHistoryID    int32            `db:"odds_history_id" json:"odds_history_id"`
	AlertType        string           `db:"alert_type" json:"alert_type"`
	Severity         string           `db:"severity" json:"severity"`
	Title            string           `db:"title" json:"title"`
	Message          string           `db:"message" json:"message"`
	ChangePercentage pgtype.Numeric   `db:"change_percentage" json:"change_percentage"`
	Multiplier       pgtype.Numeric   `db:"multiplier" json:"multiplier"`
	ConfidenceScore  pgtype.Numeric   `db:"confidence_score" json:"confidence_score"`
	MinutesToKickoff pgtype.Int4      `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	CreatedAt        pgtype.Timestamp `db:"created_at" json:"created_at"`
	ExpiresAt        pgtype.Timestamp `db:"expires_at" json:"expires_at"`
	IsActive         pgtype.Bool      `db:"is_active" json:"is_active"`
	Views            pgtype.Int4      `db:"views" json:"views"`
	Clicks           pgtype.Int4      `db:"clicks" json:"clicks"`
	EventID          pgtype.Int4      `db:"event_id" json:"event_id"`
	MarketTypeID     pgtype.Int4      `db:"market_type_id" json:"market_type_id"`
	Outcome          string           `db:"outcome" json:"outcome"`
	EventExternalID  string           `db:"event_external_id" json:"event_external_id"`
	EventDate        pgtype.Timestamp `db:"event_date" json:"event_date"`
	HomeTeamID       pgtype.Int4      `db:"home_team_id" json:"home_team_id"`
	AwayTeamID       pgtype.Int4      `db:"away_team_id" json:"away_team_id"`
	HomeTeamName     pgtype.Text      `db:"home_team_name" json:"home_team_name"`
	AwayTeamName     pgtype.Text      `db:"away_team_name" json:"away_team_name"`
	MarketCode       string           `db:"market_code" json:"market_code"`
	MarketName       string           `db:"market_name" json:"market_name"`
}

func (q *Queries) GetActiveAlerts(ctx context.Context, arg GetActiveAlertsParams) ([]GetActiveAlertsRow, error) {
	rows, err := q.db.Query(ctx, getActiveAlerts, arg.AlertType, arg.MinSeverity, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveAlertsRow{}
	for rows.Next() {
		var i GetActiveAlertsRow
		if err := rows.Scan(
			&i.ID,
			&i.OddsHistoryID,
			&i.AlertType,
			&i.Severity,
			&i.Title,
			&i.Message,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.ConfidenceScore,
			&i.MinutesToKickoff,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.IsActive,
			&i.Views,
			&i.Clicks,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.EventExternalID,
			&i.EventDate,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.MarketCode,
			&i.MarketName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlertsByUser = `-- name: GetAlertsByUser :many
SELECT 
    ma.id, ma.odds_history_id, ma.alert_type, ma.severity, ma.title, ma.message, ma.change_percentage, ma.multiplier, ma.confidence_score, ma.minutes_to_kickoff, ma.created_at, ma.expires_at, ma.is_active, ma.views, ma.clicks,
    oh.event_id,
    oh.outcome,
    e.external_id as event_external_id,
    e.event_date,
    ht.name as home_team_name,
    at.name as away_team_name,
    mt.name as market_name
FROM movement_alerts ma
JOIN odds_history oh ON ma.odds_history_id = oh.id
JOIN events e ON oh.event_id = e.id
LEFT JOIN teams ht ON e.home_team_id = ht.id
LEFT JOIN teams at ON e.away_team_id = at.id
JOIN market_types mt ON oh.market_type_id = mt.id
JOIN smart_money_preferences smp ON smp.user_id = $1
WHERE 
    ma.is_active = true
    AND ma.expires_at > NOW()
    AND ma.change_percentage >= smp.min_change_percentage
    AND ma.multiplier >= smp.min_multiplier
    AND ma.confidence_score >= smp.min_confidence_score
    AND (
        (ma.alert_type = 'big_mover' AND smp.big_mover_alerts = true) OR
        (ma.alert_type = 'reverse_line' AND smp.reverse_line_alerts = true) OR
        (ma.alert_type = 'sharp_money' AND smp.sharp_money_alerts = true) OR
        (ma.alert_type = 'value_spot' AND smp.value_spot_alerts = true)
    )
    -- Filter by preferred sports/leagues if specified
    AND (
        smp.preferred_sports = '[]'::jsonb OR 
        e.sport_id::text = ANY(SELECT jsonb_array_elements_text(smp.preferred_sports))
    )
ORDER BY ma.created_at DESC
LIMIT $2
`

type GetAlertsByUserParams struct {
	UserID     string `db:"user_id" json:"user_id"`
	LimitCount int32  `db:"limit_count" json:"limit_count"`
}

type GetAlertsByUserRow struct {
	ID               int32            `db:"id" json:"id"`
	OddsHistoryID    int32            `db:"odds_history_id" json:"odds_history_id"`
	AlertType        string           `db:"alert_type" json:"alert_type"`
	Severity         string           `db:"severity" json:"severity"`
	Title            string           `db:"title" json:"title"`
	Message          string           `db:"message" json:"message"`
	ChangePercentage pgtype.Numeric   `db:"change_percentage" json:"change_percentage"`
	Multiplier       pgtype.Numeric   `db:"multiplier" json:"multiplier"`
	ConfidenceScore  pgtype.Numeric   `db:"confidence_score" json:"confidence_score"`
	MinutesToKickoff pgtype.Int4      `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	CreatedAt        pgtype.Timestamp `db:"created_at" json:"created_at"`
	ExpiresAt        pgtype.Timestamp `db:"expires_at" json:"expires_at"`
	IsActive         pgtype.Bool      `db:"is_active" json:"is_active"`
	Views            pgtype.Int4      `db:"views" json:"views"`
	Clicks           pgtype.Int4      `db:"clicks" json:"clicks"`
	EventID          pgtype.Int4      `db:"event_id" json:"event_id"`
	Outcome          string           `db:"outcome" json:"outcome"`
	EventExternalID  string           `db:"event_external_id" json:"event_external_id"`
	EventDate        pgtype.Timestamp `db:"event_date" json:"event_date"`
	HomeTeamName     pgtype.Text      `db:"home_team_name" json:"home_team_name"`
	AwayTeamName     pgtype.Text      `db:"away_team_name" json:"away_team_name"`
	MarketName       string           `db:"market_name" json:"market_name"`
}

func (q *Queries) GetAlertsByUser(ctx context.Context, arg GetAlertsByUserParams) ([]GetAlertsByUserRow, error) {
	rows, err := q.db.Query(ctx, getAlertsByUser, arg.UserID, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAlertsByUserRow{}
	for rows.Next() {
		var i GetAlertsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.OddsHistoryID,
			&i.AlertType,
			&i.Severity,
			&i.Title,
			&i.Message,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.ConfidenceScore,
			&i.MinutesToKickoff,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.IsActive,
			&i.Views,
			&i.Clicks,
			&i.EventID,
			&i.Outcome,
			&i.EventExternalID,
			&i.EventDate,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.MarketName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentBigMovers = `-- name: GetRecentBigMovers :many

SELECT 
    oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.recorded_at, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff,
    e.external_id as event_external_id,
    e.event_date,
    e.home_team_id,
    e.away_team_id,
    e.is_live,
    ht.name as home_team_name,
    at.name as away_team_name,
    mt.code as market_code,
    mt.name as market_name
FROM odds_history oh
JOIN events e ON oh.event_id = e.id
LEFT JOIN teams ht ON e.home_team_id = ht.id
LEFT JOIN teams at ON e.away_team_id = at.id
JOIN market_types mt ON oh.market_type_id = mt.id
WHERE 
    (ABS(oh.change_percentage) >= $1 OR oh.multiplier >= $2)
    AND oh.recorded_at >= $3
    AND e.event_date > NOW()
ORDER BY oh.recorded_at DESC
LIMIT $4
`

type GetRecentBigMoversParams struct {
	MinChangePct  pgtype.Numeric   `db:"min_change_pct" json:"min_change_pct"`
	MinMultiplier pgtype.Numeric   `db:"min_multiplier" json:"min_multiplier"`
	SinceTime     pgtype.Timestamp `db:"since_time" json:"since_time"`
	LimitCount    int32            `db:"limit_count" json:"limit_count"`
}

type GetRecentBigMoversRow struct {
	ID                  int32            `db:"id" json:"id"`
	EventID             pgtype.Int4      `db:"event_id" json:"event_id"`
	MarketTypeID        pgtype.Int4      `db:"market_type_id" json:"market_type_id"`
	Outcome             string           `db:"outcome" json:"outcome"`
	OddsValue           pgtype.Numeric   `db:"odds_value" json:"odds_value"`
	PreviousValue       pgtype.Numeric   `db:"previous_value" json:"previous_value"`
	WinningOdds         pgtype.Numeric   `db:"winning_odds" json:"winning_odds"`
	ChangeAmount        pgtype.Numeric   `db:"change_amount" json:"change_amount"`
	ChangePercentage    pgtype.Numeric   `db:"change_percentage" json:"change_percentage"`
	Multiplier          pgtype.Numeric   `db:"multiplier" json:"multiplier"`
	RecordedAt          pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	SharpMoneyIndicator pgtype.Numeric   `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement   pgtype.Bool      `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel   pgtype.Text      `db:"significance_level" json:"significance_level"`
	MinutesToKickoff    pgtype.Int4      `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	EventExternalID     string           `db:"event_external_id" json:"event_external_id"`
	EventDate           pgtype.Timestamp `db:"event_date" json:"event_date"`
	HomeTeamID          pgtype.Int4      `db:"home_team_id" json:"home_team_id"`
	AwayTeamID          pgtype.Int4      `db:"away_team_id" json:"away_team_id"`
	IsLive              pgtype.Bool      `db:"is_live" json:"is_live"`
	HomeTeamName        pgtype.Text      `db:"home_team_name" json:"home_team_name"`
	AwayTeamName        pgtype.Text      `db:"away_team_name" json:"away_team_name"`
	MarketCode          string           `db:"market_code" json:"market_code"`
	MarketName          string           `db:"market_name" json:"market_name"`
}

// Smart Money Tracker queries
func (q *Queries) GetRecentBigMovers(ctx context.Context, arg GetRecentBigMoversParams) ([]GetRecentBigMoversRow, error) {
	rows, err := q.db.Query(ctx, getRecentBigMovers,
		arg.MinChangePct,
		arg.MinMultiplier,
		arg.SinceTime,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentBigMoversRow{}
	for rows.Next() {
		var i GetRecentBigMoversRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.RecordedAt,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.EventExternalID,
			&i.EventDate,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.IsLive,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.MarketCode,
			&i.MarketName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReverseLineMovements = `-- name: GetReverseLineMovements :many
SELECT 
    oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.recorded_at, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff,
    e.external_id as event_external_id,
    e.event_date,
    e.home_team_id,
    e.away_team_id,
    ht.name as home_team_name,
    at.name as away_team_name,
    mt.code as market_code,
    mt.name as market_name
FROM odds_history oh
JOIN events e ON oh.event_id = e.id
LEFT JOIN teams ht ON e.home_team_id = ht.id
LEFT JOIN teams at ON e.away_team_id = at.id
JOIN market_types mt ON oh.market_type_id = mt.id
WHERE 
    oh.recorded_at >= $1
    AND e.event_date > NOW()
    -- Look for movements against typical patterns
    AND (
        (oh.previous_value < 2.0 AND oh.change_percentage > 15) OR  -- Favorites drifting
        (oh.previous_value > 4.0 AND oh.change_percentage < -15)    -- Big underdogs shortening
    )
ORDER BY ABS(oh.change_percentage) DESC
LIMIT $2
`

type GetReverseLineMovementsParams struct {
	SinceTime  pgtype.Timestamp `db:"since_time" json:"since_time"`
	LimitCount int32            `db:"limit_count" json:"limit_count"`
}

type GetReverseLineMovementsRow struct {
	ID                  int32            `db:"id" json:"id"`
	EventID             pgtype.Int4      `db:"event_id" json:"event_id"`
	MarketTypeID        pgtype.Int4      `db:"market_type_id" json:"market_type_id"`
	Outcome             string           `db:"outcome" json:"outcome"`
	OddsValue           pgtype.Numeric   `db:"odds_value" json:"odds_value"`
	PreviousValue       pgtype.Numeric   `db:"previous_value" json:"previous_value"`
	WinningOdds         pgtype.Numeric   `db:"winning_odds" json:"winning_odds"`
	ChangeAmount        pgtype.Numeric   `db:"change_amount" json:"change_amount"`
	ChangePercentage    pgtype.Numeric   `db:"change_percentage" json:"change_percentage"`
	Multiplier          pgtype.Numeric   `db:"multiplier" json:"multiplier"`
	RecordedAt          pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	SharpMoneyIndicator pgtype.Numeric   `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement   pgtype.Bool      `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel   pgtype.Text      `db:"significance_level" json:"significance_level"`
	MinutesToKickoff    pgtype.Int4      `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	EventExternalID     string           `db:"event_external_id" json:"event_external_id"`
	EventDate           pgtype.Timestamp `db:"event_date" json:"event_date"`
	HomeTeamID          pgtype.Int4      `db:"home_team_id" json:"home_team_id"`
	AwayTeamID          pgtype.Int4      `db:"away_team_id" json:"away_team_id"`
	HomeTeamName        pgtype.Text      `db:"home_team_name" json:"home_team_name"`
	AwayTeamName        pgtype.Text      `db:"away_team_name" json:"away_team_name"`
	MarketCode          string           `db:"market_code" json:"market_code"`
	MarketName          string           `db:"market_name" json:"market_name"`
}

func (q *Queries) GetReverseLineMovements(ctx context.Context, arg GetReverseLineMovementsParams) ([]GetReverseLineMovementsRow, error) {
	rows, err := q.db.Query(ctx, getReverseLineMovements, arg.SinceTime, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReverseLineMovementsRow{}
	for rows.Next() {
		var i GetReverseLineMovementsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.RecordedAt,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.EventExternalID,
			&i.EventDate,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.MarketCode,
			&i.MarketName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSmartMoneyPreferences = `-- name: GetUserSmartMoneyPreferences :one
SELECT id, user_id, min_change_percentage, min_multiplier, min_confidence_score, big_mover_alerts, reverse_line_alerts, sharp_money_alerts, value_spot_alerts, preferred_sports, preferred_leagues, max_daily_alerts, push_notifications, quiet_hours_start, quiet_hours_end, created_at, updated_at FROM smart_money_preferences WHERE user_id = $1
`

func (q *Queries) GetUserSmartMoneyPreferences(ctx context.Context, userID string) (SmartMoneyPreference, error) {
	row := q.db.QueryRow(ctx, getUserSmartMoneyPreferences, userID)
	var i SmartMoneyPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MinChangePercentage,
		&i.MinMultiplier,
		&i.MinConfidenceScore,
		&i.BigMoverAlerts,
		&i.ReverseLineAlerts,
		&i.SharpMoneyAlerts,
		&i.ValueSpotAlerts,
		&i.PreferredSports,
		&i.PreferredLeagues,
		&i.MaxDailyAlerts,
		&i.PushNotifications,
		&i.QuietHoursStart,
		&i.QuietHoursEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getValueSpots = `-- name: GetValueSpots :many
SELECT 
    oh.id, oh.event_id, oh.market_type_id, oh.outcome, oh.odds_value, oh.previous_value, oh.winning_odds, oh.change_amount, oh.change_percentage, oh.multiplier, oh.recorded_at, oh.sharp_money_indicator, oh.is_reverse_movement, oh.significance_level, oh.minutes_to_kickoff,
    od.bet_percentage,
    od.implied_probability,
    e.external_id as event_external_id,
    e.event_date,
    e.home_team_id,
    e.away_team_id,
    ht.name as home_team_name,
    at.name as away_team_name,
    mt.code as market_code,
    mt.name as market_name,
    (od.bet_percentage - od.implied_probability) as public_bias
FROM odds_history oh
JOIN events e ON oh.event_id = e.id
LEFT JOIN teams ht ON e.home_team_id = ht.id
LEFT JOIN teams at ON e.away_team_id = at.id
JOIN market_types mt ON oh.market_type_id = mt.id
LEFT JOIN outcome_distributions od ON (
    oh.event_id = od.event_id 
    AND oh.market_type_id = od.market_type_id 
    AND oh.outcome = od.outcome
)
WHERE 
    oh.recorded_at >= $1
    AND e.event_date > NOW()
    AND od.bet_percentage > od.implied_probability + $2
    AND ABS(oh.change_percentage) >= $3
ORDER BY (od.bet_percentage - od.implied_probability) DESC
LIMIT $4
`

type GetValueSpotsParams struct {
	SinceTime      pgtype.Timestamp `db:"since_time" json:"since_time"`
	MinBiasPct     pgtype.Numeric   `db:"min_bias_pct" json:"min_bias_pct"`
	MinMovementPct pgtype.Numeric   `db:"min_movement_pct" json:"min_movement_pct"`
	LimitCount     int32            `db:"limit_count" json:"limit_count"`
}

type GetValueSpotsRow struct {
	ID                  int32            `db:"id" json:"id"`
	EventID             pgtype.Int4      `db:"event_id" json:"event_id"`
	MarketTypeID        pgtype.Int4      `db:"market_type_id" json:"market_type_id"`
	Outcome             string           `db:"outcome" json:"outcome"`
	OddsValue           pgtype.Numeric   `db:"odds_value" json:"odds_value"`
	PreviousValue       pgtype.Numeric   `db:"previous_value" json:"previous_value"`
	WinningOdds         pgtype.Numeric   `db:"winning_odds" json:"winning_odds"`
	ChangeAmount        pgtype.Numeric   `db:"change_amount" json:"change_amount"`
	ChangePercentage    pgtype.Numeric   `db:"change_percentage" json:"change_percentage"`
	Multiplier          pgtype.Numeric   `db:"multiplier" json:"multiplier"`
	RecordedAt          pgtype.Timestamp `db:"recorded_at" json:"recorded_at"`
	SharpMoneyIndicator pgtype.Numeric   `db:"sharp_money_indicator" json:"sharp_money_indicator"`
	IsReverseMovement   pgtype.Bool      `db:"is_reverse_movement" json:"is_reverse_movement"`
	SignificanceLevel   pgtype.Text      `db:"significance_level" json:"significance_level"`
	MinutesToKickoff    pgtype.Int4      `db:"minutes_to_kickoff" json:"minutes_to_kickoff"`
	BetPercentage       pgtype.Numeric   `db:"bet_percentage" json:"bet_percentage"`
	ImpliedProbability  pgtype.Numeric   `db:"implied_probability" json:"implied_probability"`
	EventExternalID     string           `db:"event_external_id" json:"event_external_id"`
	EventDate           pgtype.Timestamp `db:"event_date" json:"event_date"`
	HomeTeamID          pgtype.Int4      `db:"home_team_id" json:"home_team_id"`
	AwayTeamID          pgtype.Int4      `db:"away_team_id" json:"away_team_id"`
	HomeTeamName        pgtype.Text      `db:"home_team_name" json:"home_team_name"`
	AwayTeamName        pgtype.Text      `db:"away_team_name" json:"away_team_name"`
	MarketCode          string           `db:"market_code" json:"market_code"`
	MarketName          string           `db:"market_name" json:"market_name"`
	PublicBias          int32            `db:"public_bias" json:"public_bias"`
}

func (q *Queries) GetValueSpots(ctx context.Context, arg GetValueSpotsParams) ([]GetValueSpotsRow, error) {
	rows, err := q.db.Query(ctx, getValueSpots,
		arg.SinceTime,
		arg.MinBiasPct,
		arg.MinMovementPct,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetValueSpotsRow{}
	for rows.Next() {
		var i GetValueSpotsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Outcome,
			&i.OddsValue,
			&i.PreviousValue,
			&i.WinningOdds,
			&i.ChangeAmount,
			&i.ChangePercentage,
			&i.Multiplier,
			&i.RecordedAt,
			&i.SharpMoneyIndicator,
			&i.IsReverseMovement,
			&i.SignificanceLevel,
			&i.MinutesToKickoff,
			&i.BetPercentage,
			&i.ImpliedProbability,
			&i.EventExternalID,
			&i.EventDate,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.MarketCode,
			&i.MarketName,
			&i.PublicBias,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAlertClicked = `-- name: MarkAlertClicked :exec
UPDATE movement_alerts 
SET clicks = clicks + 1 
WHERE id = $1
`

func (q *Queries) MarkAlertClicked(ctx context.Context, alertID int32) error {
	_, err := q.db.Exec(ctx, markAlertClicked, alertID)
	return err
}

const markAlertViewed = `-- name: MarkAlertViewed :exec
UPDATE movement_alerts 
SET views = views + 1 
WHERE id = $1
`

func (q *Queries) MarkAlertViewed(ctx context.Context, alertID int32) error {
	_, err := q.db.Exec(ctx, markAlertViewed, alertID)
	return err
}

const upsertUserSmartMoneyPreferences = `-- name: UpsertUserSmartMoneyPreferences :one
INSERT INTO smart_money_preferences (
    user_id,
    min_change_percentage,
    min_multiplier,
    min_confidence_score,
    big_mover_alerts,
    reverse_line_alerts,
    sharp_money_alerts,
    value_spot_alerts,
    preferred_sports,
    preferred_leagues,
    max_daily_alerts,
    push_notifications,
    quiet_hours_start,
    quiet_hours_end
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14
)
ON CONFLICT (user_id) DO UPDATE SET
    min_change_percentage = EXCLUDED.min_change_percentage,
    min_multiplier = EXCLUDED.min_multiplier,
    min_confidence_score = EXCLUDED.min_confidence_score,
    big_mover_alerts = EXCLUDED.big_mover_alerts,
    reverse_line_alerts = EXCLUDED.reverse_line_alerts,
    sharp_money_alerts = EXCLUDED.sharp_money_alerts,
    value_spot_alerts = EXCLUDED.value_spot_alerts,
    preferred_sports = EXCLUDED.preferred_sports,
    preferred_leagues = EXCLUDED.preferred_leagues,
    max_daily_alerts = EXCLUDED.max_daily_alerts,
    push_notifications = EXCLUDED.push_notifications,
    quiet_hours_start = EXCLUDED.quiet_hours_start,
    quiet_hours_end = EXCLUDED.quiet_hours_end,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, user_id, min_change_percentage, min_multiplier, min_confidence_score, big_mover_alerts, reverse_line_alerts, sharp_money_alerts, value_spot_alerts, preferred_sports, preferred_leagues, max_daily_alerts, push_notifications, quiet_hours_start, quiet_hours_end, created_at, updated_at
`

type UpsertUserSmartMoneyPreferencesParams struct {
	UserID              string         `db:"user_id" json:"user_id"`
	MinChangePercentage pgtype.Numeric `db:"min_change_percentage" json:"min_change_percentage"`
	MinMultiplier       pgtype.Numeric `db:"min_multiplier" json:"min_multiplier"`
	MinConfidenceScore  pgtype.Numeric `db:"min_confidence_score" json:"min_confidence_score"`
	BigMoverAlerts      pgtype.Bool    `db:"big_mover_alerts" json:"big_mover_alerts"`
	ReverseLineAlerts   pgtype.Bool    `db:"reverse_line_alerts" json:"reverse_line_alerts"`
	SharpMoneyAlerts    pgtype.Bool    `db:"sharp_money_alerts" json:"sharp_money_alerts"`
	ValueSpotAlerts     pgtype.Bool    `db:"value_spot_alerts" json:"value_spot_alerts"`
	PreferredSports     []byte         `db:"preferred_sports" json:"preferred_sports"`
	PreferredLeagues    []byte         `db:"preferred_leagues" json:"preferred_leagues"`
	MaxDailyAlerts      pgtype.Int4    `db:"max_daily_alerts" json:"max_daily_alerts"`
	PushNotifications   pgtype.Bool    `db:"push_notifications" json:"push_notifications"`
	QuietHoursStart     pgtype.Time    `db:"quiet_hours_start" json:"quiet_hours_start"`
	QuietHoursEnd       pgtype.Time    `db:"quiet_hours_end" json:"quiet_hours_end"`
}

func (q *Queries) UpsertUserSmartMoneyPreferences(ctx context.Context, arg UpsertUserSmartMoneyPreferencesParams) (SmartMoneyPreference, error) {
	row := q.db.QueryRow(ctx, upsertUserSmartMoneyPreferences,
		arg.UserID,
		arg.MinChangePercentage,
		arg.MinMultiplier,
		arg.MinConfidenceScore,
		arg.BigMoverAlerts,
		arg.ReverseLineAlerts,
		arg.SharpMoneyAlerts,
		arg.ValueSpotAlerts,
		arg.PreferredSports,
		arg.PreferredLeagues,
		arg.MaxDailyAlerts,
		arg.PushNotifications,
		arg.QuietHoursStart,
		arg.QuietHoursEnd,
	)
	var i SmartMoneyPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MinChangePercentage,
		&i.MinMultiplier,
		&i.MinConfidenceScore,
		&i.BigMoverAlerts,
		&i.ReverseLineAlerts,
		&i.SharpMoneyAlerts,
		&i.ValueSpotAlerts,
		&i.PreferredSports,
		&i.PreferredLeagues,
		&i.MaxDailyAlerts,
		&i.PushNotifications,
		&i.QuietHoursStart,
		&i.QuietHoursEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
