// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: predictions.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPrediction = `-- name: CreatePrediction :one
INSERT INTO predictions (event_id, market_type_id, predicted_outcome, confidence_score, model_version, features_used)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, event_id, market_type_id, slug, predicted_outcome, confidence_score, model_version, features_used, created_at
`

type CreatePredictionParams struct {
	EventID          pgtype.Int4    `db:"event_id" json:"event_id"`
	MarketTypeID     pgtype.Int4    `db:"market_type_id" json:"market_type_id"`
	PredictedOutcome string         `db:"predicted_outcome" json:"predicted_outcome"`
	ConfidenceScore  pgtype.Numeric `db:"confidence_score" json:"confidence_score"`
	ModelVersion     string         `db:"model_version" json:"model_version"`
	FeaturesUsed     pgtype.Text    `db:"features_used" json:"features_used"`
}

func (q *Queries) CreatePrediction(ctx context.Context, arg CreatePredictionParams) (Prediction, error) {
	row := q.db.QueryRow(ctx, createPrediction,
		arg.EventID,
		arg.MarketTypeID,
		arg.PredictedOutcome,
		arg.ConfidenceScore,
		arg.ModelVersion,
		arg.FeaturesUsed,
	)
	var i Prediction
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.MarketTypeID,
		&i.Slug,
		&i.PredictedOutcome,
		&i.ConfidenceScore,
		&i.ModelVersion,
		&i.FeaturesUsed,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestPredictions = `-- name: GetLatestPredictions :many
SELECT p.id, p.event_id, p.market_type_id, p.slug, p.predicted_outcome, p.confidence_score, p.model_version, p.features_used, p.created_at, mt.name as market_name, mt.code as market_code
FROM predictions p
JOIN market_types mt ON p.market_type_id = mt.id
WHERE p.event_id = $1
AND p.created_at = (
    SELECT MAX(created_at) 
    FROM predictions p2 
    WHERE p2.event_id = p.event_id 
    AND p2.market_type_id = p.market_type_id
)
`

type GetLatestPredictionsRow struct {
	ID               int32            `db:"id" json:"id"`
	EventID          pgtype.Int4      `db:"event_id" json:"event_id"`
	MarketTypeID     pgtype.Int4      `db:"market_type_id" json:"market_type_id"`
	Slug             string           `db:"slug" json:"slug"`
	PredictedOutcome string           `db:"predicted_outcome" json:"predicted_outcome"`
	ConfidenceScore  pgtype.Numeric   `db:"confidence_score" json:"confidence_score"`
	ModelVersion     string           `db:"model_version" json:"model_version"`
	FeaturesUsed     pgtype.Text      `db:"features_used" json:"features_used"`
	CreatedAt        pgtype.Timestamp `db:"created_at" json:"created_at"`
	MarketName       string           `db:"market_name" json:"market_name"`
	MarketCode       string           `db:"market_code" json:"market_code"`
}

func (q *Queries) GetLatestPredictions(ctx context.Context, eventID pgtype.Int4) ([]GetLatestPredictionsRow, error) {
	rows, err := q.db.Query(ctx, getLatestPredictions, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLatestPredictionsRow{}
	for rows.Next() {
		var i GetLatestPredictionsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Slug,
			&i.PredictedOutcome,
			&i.ConfidenceScore,
			&i.ModelVersion,
			&i.FeaturesUsed,
			&i.CreatedAt,
			&i.MarketName,
			&i.MarketCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPredictionAccuracy = `-- name: GetPredictionAccuracy :many
SELECT 
    p.market_type_id,
    mt.name as market_name,
    p.model_version,
    COUNT(*) as total_predictions,
    SUM(CASE 
        WHEN e.status = 'finished' AND (
            (p.predicted_outcome = '1' AND e.home_score > e.away_score) OR
            (p.predicted_outcome = 'X' AND e.home_score = e.away_score) OR
            (p.predicted_outcome = '2' AND e.home_score < e.away_score)
        ) THEN 1 
        ELSE 0 
    END) as correct_predictions,
    AVG(p.confidence_score) as avg_confidence
FROM predictions p
JOIN market_types mt ON p.market_type_id = mt.id
JOIN events e ON p.event_id = e.id
WHERE e.status = 'finished'
AND p.created_at >= $1
GROUP BY p.market_type_id, mt.name, p.model_version
`

type GetPredictionAccuracyRow struct {
	MarketTypeID       pgtype.Int4 `db:"market_type_id" json:"market_type_id"`
	MarketName         string      `db:"market_name" json:"market_name"`
	ModelVersion       string      `db:"model_version" json:"model_version"`
	TotalPredictions   int64       `db:"total_predictions" json:"total_predictions"`
	CorrectPredictions int64       `db:"correct_predictions" json:"correct_predictions"`
	AvgConfidence      float64     `db:"avg_confidence" json:"avg_confidence"`
}

func (q *Queries) GetPredictionAccuracy(ctx context.Context, sinceDate pgtype.Timestamp) ([]GetPredictionAccuracyRow, error) {
	rows, err := q.db.Query(ctx, getPredictionAccuracy, sinceDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPredictionAccuracyRow{}
	for rows.Next() {
		var i GetPredictionAccuracyRow
		if err := rows.Scan(
			&i.MarketTypeID,
			&i.MarketName,
			&i.ModelVersion,
			&i.TotalPredictions,
			&i.CorrectPredictions,
			&i.AvgConfidence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPredictionsByEvent = `-- name: GetPredictionsByEvent :many
SELECT p.id, p.event_id, p.market_type_id, p.slug, p.predicted_outcome, p.confidence_score, p.model_version, p.features_used, p.created_at, mt.name as market_name, mt.code as market_code
FROM predictions p
JOIN market_types mt ON p.market_type_id = mt.id
WHERE p.event_id = $1
ORDER BY p.confidence_score DESC
`

type GetPredictionsByEventRow struct {
	ID               int32            `db:"id" json:"id"`
	EventID          pgtype.Int4      `db:"event_id" json:"event_id"`
	MarketTypeID     pgtype.Int4      `db:"market_type_id" json:"market_type_id"`
	Slug             string           `db:"slug" json:"slug"`
	PredictedOutcome string           `db:"predicted_outcome" json:"predicted_outcome"`
	ConfidenceScore  pgtype.Numeric   `db:"confidence_score" json:"confidence_score"`
	ModelVersion     string           `db:"model_version" json:"model_version"`
	FeaturesUsed     pgtype.Text      `db:"features_used" json:"features_used"`
	CreatedAt        pgtype.Timestamp `db:"created_at" json:"created_at"`
	MarketName       string           `db:"market_name" json:"market_name"`
	MarketCode       string           `db:"market_code" json:"market_code"`
}

func (q *Queries) GetPredictionsByEvent(ctx context.Context, eventID pgtype.Int4) ([]GetPredictionsByEventRow, error) {
	rows, err := q.db.Query(ctx, getPredictionsByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPredictionsByEventRow{}
	for rows.Next() {
		var i GetPredictionsByEventRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.MarketTypeID,
			&i.Slug,
			&i.PredictedOutcome,
			&i.ConfidenceScore,
			&i.ModelVersion,
			&i.FeaturesUsed,
			&i.CreatedAt,
			&i.MarketName,
			&i.MarketCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
