// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: statistics.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMatchEvent = `-- name: CreateMatchEvent :one
INSERT INTO match_events (event_id, minute, event_type, team, player, description, is_home)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (event_id, minute, event_type, team, player) DO NOTHING
RETURNING id, event_id, minute, event_type, team, player, description, is_home, created_at
`

type CreateMatchEventParams struct {
	EventID     pgtype.Int4 `db:"event_id" json:"event_id"`
	Minute      int32       `db:"minute" json:"minute"`
	EventType   string      `db:"event_type" json:"event_type"`
	Team        string      `db:"team" json:"team"`
	Player      pgtype.Text `db:"player" json:"player"`
	Description string      `db:"description" json:"description"`
	IsHome      bool        `db:"is_home" json:"is_home"`
}

func (q *Queries) CreateMatchEvent(ctx context.Context, arg CreateMatchEventParams) (MatchEvent, error) {
	row := q.db.QueryRow(ctx, createMatchEvent,
		arg.EventID,
		arg.Minute,
		arg.EventType,
		arg.Team,
		arg.Player,
		arg.Description,
		arg.IsHome,
	)
	var i MatchEvent
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Minute,
		&i.EventType,
		&i.Team,
		&i.Player,
		&i.Description,
		&i.IsHome,
		&i.CreatedAt,
	)
	return i, err
}

const getEventStatisticsSummary = `-- name: GetEventStatisticsSummary :one
SELECT 
    e.slug,
    ht.name as home_team,
    at.name as away_team,
    e.home_score,
    e.away_score,
    e.minute_of_match,
    e.half,
    e.status,
    e.is_live,
    (SELECT COUNT(*) FROM match_events me WHERE me.event_id = e.id) as total_events,
    (SELECT COUNT(*) FROM match_statistics ms WHERE ms.event_id = e.id) as has_statistics
FROM events e
JOIN teams ht ON e.home_team_id = ht.id
JOIN teams at ON e.away_team_id = at.id
WHERE e.id = $1
`

type GetEventStatisticsSummaryRow struct {
	Slug          string      `db:"slug" json:"slug"`
	HomeTeam      string      `db:"home_team" json:"home_team"`
	AwayTeam      string      `db:"away_team" json:"away_team"`
	HomeScore     pgtype.Int4 `db:"home_score" json:"home_score"`
	AwayScore     pgtype.Int4 `db:"away_score" json:"away_score"`
	MinuteOfMatch pgtype.Int4 `db:"minute_of_match" json:"minute_of_match"`
	Half          pgtype.Int4 `db:"half" json:"half"`
	Status        string      `db:"status" json:"status"`
	IsLive        pgtype.Bool `db:"is_live" json:"is_live"`
	TotalEvents   int64       `db:"total_events" json:"total_events"`
	HasStatistics int64       `db:"has_statistics" json:"has_statistics"`
}

func (q *Queries) GetEventStatisticsSummary(ctx context.Context, eventID int32) (GetEventStatisticsSummaryRow, error) {
	row := q.db.QueryRow(ctx, getEventStatisticsSummary, eventID)
	var i GetEventStatisticsSummaryRow
	err := row.Scan(
		&i.Slug,
		&i.HomeTeam,
		&i.AwayTeam,
		&i.HomeScore,
		&i.AwayScore,
		&i.MinuteOfMatch,
		&i.Half,
		&i.Status,
		&i.IsLive,
		&i.TotalEvents,
		&i.HasStatistics,
	)
	return i, err
}

const getLiveEvents = `-- name: GetLiveEvents :many
SELECT 
    e.slug,
    ht.name as home_team,
    at.name as away_team,
    e.home_score,
    e.away_score,
    e.minute_of_match,
    e.half,
    e.status
FROM events e
JOIN teams ht ON e.home_team_id = ht.id
JOIN teams at ON e.away_team_id = at.id
WHERE e.is_live = true
ORDER BY e.event_date ASC
`

type GetLiveEventsRow struct {
	Slug          string      `db:"slug" json:"slug"`
	HomeTeam      string      `db:"home_team" json:"home_team"`
	AwayTeam      string      `db:"away_team" json:"away_team"`
	HomeScore     pgtype.Int4 `db:"home_score" json:"home_score"`
	AwayScore     pgtype.Int4 `db:"away_score" json:"away_score"`
	MinuteOfMatch pgtype.Int4 `db:"minute_of_match" json:"minute_of_match"`
	Half          pgtype.Int4 `db:"half" json:"half"`
	Status        string      `db:"status" json:"status"`
}

func (q *Queries) GetLiveEvents(ctx context.Context) ([]GetLiveEventsRow, error) {
	rows, err := q.db.Query(ctx, getLiveEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLiveEventsRow{}
	for rows.Next() {
		var i GetLiveEventsRow
		if err := rows.Scan(
			&i.Slug,
			&i.HomeTeam,
			&i.AwayTeam,
			&i.HomeScore,
			&i.AwayScore,
			&i.MinuteOfMatch,
			&i.Half,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchEvents = `-- name: GetMatchEvents :many
SELECT id, event_id, minute, event_type, team, player, description, is_home, created_at FROM match_events
WHERE event_id = $1
ORDER BY minute ASC, id ASC
`

func (q *Queries) GetMatchEvents(ctx context.Context, eventID pgtype.Int4) ([]MatchEvent, error) {
	rows, err := q.db.Query(ctx, getMatchEvents, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MatchEvent{}
	for rows.Next() {
		var i MatchEvent
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.Minute,
			&i.EventType,
			&i.Team,
			&i.Player,
			&i.Description,
			&i.IsHome,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchStatistics = `-- name: GetMatchStatistics :many
SELECT id, event_id, is_home, shots, shots_on_target, possession, corners, yellow_cards, red_cards, fouls, offsides, free_kicks, throw_ins, goal_kicks, saves, created_at, updated_at FROM match_statistics
WHERE event_id = $1
ORDER BY is_home DESC
`

func (q *Queries) GetMatchStatistics(ctx context.Context, eventID pgtype.Int4) ([]MatchStatistic, error) {
	rows, err := q.db.Query(ctx, getMatchStatistics, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MatchStatistic{}
	for rows.Next() {
		var i MatchStatistic
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.IsHome,
			&i.Shots,
			&i.ShotsOnTarget,
			&i.Possession,
			&i.Corners,
			&i.YellowCards,
			&i.RedCards,
			&i.Fouls,
			&i.Offsides,
			&i.FreeKicks,
			&i.ThrowIns,
			&i.GoalKicks,
			&i.Saves,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEventLiveData = `-- name: UpdateEventLiveData :one
UPDATE events 
SET 
    is_live = $1,
    status = $2,
    home_score = $3,
    away_score = $4,
    minute_of_match = $5,
    half = $6,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $7
RETURNING id, external_id, league_id, home_team_id, away_team_id, slug, event_date, status, home_score, away_score, is_live, minute_of_match, half, betting_volume_percentage, volume_rank, volume_updated_at, created_at, updated_at
`

type UpdateEventLiveDataParams struct {
	IsLive        pgtype.Bool `db:"is_live" json:"is_live"`
	Status        string      `db:"status" json:"status"`
	HomeScore     pgtype.Int4 `db:"home_score" json:"home_score"`
	AwayScore     pgtype.Int4 `db:"away_score" json:"away_score"`
	MinuteOfMatch pgtype.Int4 `db:"minute_of_match" json:"minute_of_match"`
	Half          pgtype.Int4 `db:"half" json:"half"`
	ID            int32       `db:"id" json:"id"`
}

func (q *Queries) UpdateEventLiveData(ctx context.Context, arg UpdateEventLiveDataParams) (Event, error) {
	row := q.db.QueryRow(ctx, updateEventLiveData,
		arg.IsLive,
		arg.Status,
		arg.HomeScore,
		arg.AwayScore,
		arg.MinuteOfMatch,
		arg.Half,
		arg.ID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.LeagueID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.Slug,
		&i.EventDate,
		&i.Status,
		&i.HomeScore,
		&i.AwayScore,
		&i.IsLive,
		&i.MinuteOfMatch,
		&i.Half,
		&i.BettingVolumePercentage,
		&i.VolumeRank,
		&i.VolumeUpdatedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertMatchStatistics = `-- name: UpsertMatchStatistics :one
INSERT INTO match_statistics (
    event_id, is_home, shots, shots_on_target, possession, corners,
    yellow_cards, red_cards, fouls, offsides, free_kicks, throw_ins, 
    goal_kicks, saves
)
VALUES (
    $1, $2, $3, $4,
    $5, $6, $7, $8,
    $9, $10, $11, $12,
    $13, $14
)
ON CONFLICT (event_id, is_home) DO UPDATE SET
    shots = EXCLUDED.shots,
    shots_on_target = EXCLUDED.shots_on_target,
    possession = EXCLUDED.possession,
    corners = EXCLUDED.corners,
    yellow_cards = EXCLUDED.yellow_cards,
    red_cards = EXCLUDED.red_cards,
    fouls = EXCLUDED.fouls,
    offsides = EXCLUDED.offsides,
    free_kicks = EXCLUDED.free_kicks,
    throw_ins = EXCLUDED.throw_ins,
    goal_kicks = EXCLUDED.goal_kicks,
    saves = EXCLUDED.saves,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, event_id, is_home, shots, shots_on_target, possession, corners, yellow_cards, red_cards, fouls, offsides, free_kicks, throw_ins, goal_kicks, saves, created_at, updated_at
`

type UpsertMatchStatisticsParams struct {
	EventID       pgtype.Int4 `db:"event_id" json:"event_id"`
	IsHome        bool        `db:"is_home" json:"is_home"`
	Shots         pgtype.Int4 `db:"shots" json:"shots"`
	ShotsOnTarget pgtype.Int4 `db:"shots_on_target" json:"shots_on_target"`
	Possession    pgtype.Int4 `db:"possession" json:"possession"`
	Corners       pgtype.Int4 `db:"corners" json:"corners"`
	YellowCards   pgtype.Int4 `db:"yellow_cards" json:"yellow_cards"`
	RedCards      pgtype.Int4 `db:"red_cards" json:"red_cards"`
	Fouls         pgtype.Int4 `db:"fouls" json:"fouls"`
	Offsides      pgtype.Int4 `db:"offsides" json:"offsides"`
	FreeKicks     pgtype.Int4 `db:"free_kicks" json:"free_kicks"`
	ThrowIns      pgtype.Int4 `db:"throw_ins" json:"throw_ins"`
	GoalKicks     pgtype.Int4 `db:"goal_kicks" json:"goal_kicks"`
	Saves         pgtype.Int4 `db:"saves" json:"saves"`
}

func (q *Queries) UpsertMatchStatistics(ctx context.Context, arg UpsertMatchStatisticsParams) (MatchStatistic, error) {
	row := q.db.QueryRow(ctx, upsertMatchStatistics,
		arg.EventID,
		arg.IsHome,
		arg.Shots,
		arg.ShotsOnTarget,
		arg.Possession,
		arg.Corners,
		arg.YellowCards,
		arg.RedCards,
		arg.Fouls,
		arg.Offsides,
		arg.FreeKicks,
		arg.ThrowIns,
		arg.GoalKicks,
		arg.Saves,
	)
	var i MatchStatistic
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.IsHome,
		&i.Shots,
		&i.ShotsOnTarget,
		&i.Possession,
		&i.Corners,
		&i.YellowCards,
		&i.RedCards,
		&i.Fouls,
		&i.Offsides,
		&i.FreeKicks,
		&i.ThrowIns,
		&i.GoalKicks,
		&i.Saves,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
